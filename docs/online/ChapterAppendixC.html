<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.28">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Appendix C — Estimation and Prediction for Dynamic Spatio-Temporal Models – Spatio-Temporal Statistics with R (1st edition)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./ChapterAppendixD.html" rel="next">
<link href="./ChapterAppendixB.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-b719d3d4935f2b08311a76135e2bf442.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-7d2e1f8220df954187ab24ed36a0da9c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/quarto-contrib/foldbox/foldbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
.Algorithm {
  --color1: #948bde;
  --color2: #584eab;
}
</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./ChapterAppendixA.html">Appendices</a></li><li class="breadcrumb-item"><a href="./ChapterAppendixC.html"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Estimation and Prediction for Dynamic Spatio-Temporal Models</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Spatio-Temporal Statistics with R (1st edition)</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction to Spatio-Temporal Statistics</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Exploring Spatio-Temporal Data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Spatio-Temporal Statistical Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Descriptive Spatio-Temporal Statistical Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Dynamic Spatio-Temporal Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Evaluating Spatio-Temporal Statistical Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterPergimus.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Pergimus (Epilogue)</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixA.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Some Useful Matrix-Algebra Definitions and Properties</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixB.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">General Smoothing Kernels</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixC.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Estimation and Prediction for Dynamic Spatio-Temporal Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixD.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Mechanistically Motivated Dynamic Spatio-Temporal Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">Case Study: Physical-Statistical Bayesian Hierarchical Model for Predicting Mediterranean Surface Winds</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixF.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">Case Study: Quadratic Echo State Networks for Sea Surface Temperature Long-Lead Prediction</span></span></a>
  </div>
</li>
      </ul>
  </li>
  <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterRPackages.html" class="sidebar-item-text sidebar-link">
  <span class="menu-text">List of <code>R</code> packages</span></a>
  </div>
  </li>
  <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
  <span class="menu-text">References</span></a>
  </div>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-estimationMoM" id="toc-sec-estimationMoM" class="nav-link active" data-scroll-target="#sec-estimationMoM"><span class="header-section-number">C.1</span> Estimation in Vector Autoregressive Spatio-Temporal Models via the Method of Moments</a></li>
  <li><a href="#sec-estimationLDSTM" id="toc-sec-estimationLDSTM" class="nav-link" data-scroll-target="#sec-estimationLDSTM"><span class="header-section-number">C.2</span> Prediction and Estimation in Fully Parameterized Linear DSTMs</a>
  <ul class="collapse">
  <li><a href="#sequential-prediction-of-the-process-via-kalman-filtering-and-smoothing" id="toc-sequential-prediction-of-the-process-via-kalman-filtering-and-smoothing" class="nav-link" data-scroll-target="#sequential-prediction-of-the-process-via-kalman-filtering-and-smoothing">Sequential Prediction of the Process via Kalman Filtering and Smoothing</a></li>
  <li><a href="#parameter-estimation-via-the-em-algorithm" id="toc-parameter-estimation-via-the-em-algorithm" class="nav-link" data-scroll-target="#parameter-estimation-via-the-em-algorithm">Parameter Estimation via the EM Algorithm</a></li>
  </ul></li>
  <li><a href="#sec-Est_and_pred" id="toc-sec-Est_and_pred" class="nav-link" data-scroll-target="#sec-Est_and_pred"><span class="header-section-number">C.3</span> Estimation for Non-Gaussian and Nonlinear DSTMs</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./ChapterAppendixA.html">Appendices</a></li><li class="breadcrumb-item"><a href="./ChapterAppendixC.html"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Estimation and Prediction for Dynamic Spatio-Temporal Models</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-Appendix5a" class="quarto-section-identifier">Appendix C — Estimation and Prediction for Dynamic Spatio-Temporal Models</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Estimation and prediction for linear dynamic spatio-temporal models (DSTMs) with Gaussian errors can sometimes be done using methods developed for state-space models (when there are many more temporal observations than spatial locations). In particular, after conditioning on parameter estimates, the hidden (state) process can be predicted using a Kalman filter or smoother, and the parameters might be estimated using an expectation-maximization (EM) algorithm or a Markov chain Monte Carlo (MCMC) algorithm. This appendix illustrates, first, a method-of-moments estimation approach that is common in vector autoregression modeling in time series, and second, a detailed description of parameter estimation and prediction of the process in linear DSTMs with Gaussian errors using the Kalman filter, Kalman smoother, and the EM algorithm.</p>
<section id="sec-estimationMoM" class="level2" data-number="C.1">
<h2 data-number="C.1" class="anchored" data-anchor-id="sec-estimationMoM"><span class="header-section-number">C.1</span> Estimation in Vector Autoregressive Spatio-Temporal Models via the Method of Moments</h2>
<p>In traditional vector autoregressive (VAR) time-series applications, the autoregressive process is assumed to correspond directly to the data-generating process (i.e., there is no separate data model and process model). In the spatio-temporal context this implies a model such as</p>
<p><span id="eq-linearVAR"><span class="math display">\[
\mathbf{Z}_t = \mathbf{M}\mathbf{Z}_{t-1} + \boldsymbol{\eta}_t,\quad \boldsymbol{\eta}_t \sim \; Gau(\mathbf{0},\mathbf{C}_{\eta}),
\tag{C.1}\]</span></span></p>
<p>for <span class="math inline">\(t=1,\ldots,T\)</span>, where we assume that <span class="math inline">\(\mathbf{Z}_0\)</span> is known and recall that <span class="math inline">\(\mathbf{Z}_t = (Z_t(\mathbf{s}_1),\ldots,Z_t(\mathbf{s}_m))'\)</span>. Estimation of the matrices <span class="math inline">\(\mathbf{M}\)</span> and <span class="math inline">\(\mathbf{C}_{\eta}\)</span> can be obtained via maximum likelihood, least squares, or the method of moments (see <span class="citation" data-cites="lutkepohl2005new">Lütkepohl (<a href="references.html#ref-lutkepohl2005new" role="doc-biblioref">2005</a>)</span>, Chapter 3). We illustrate the latter here.</p>
<p>For simplicity, we assume <span class="math inline">\(\{\mathbf{Z}_t\}\)</span> has mean zero and is second-order stationary in time. If we post-multiply both sides of <a href="#eq-linearVAR" class="quarto-xref">Equation&nbsp;<span>C.1</span></a> by <span class="math inline">\(\mathbf{Z}'_{t-1}\)</span> and take the expectation, we get,</p>
<p><span class="math display">\[
E(\mathbf{Z}_t \mathbf{Z}'_{t-1}) =  \mathbf{M}E(\mathbf{Z}_{t-1} \mathbf{Z}'_{t-1}),
\]</span></p>
<p>which we write as</p>
<p><span id="eq-CovVAR"><span class="math display">\[
\mathbf{C}_z^{(1)}  =  \mathbf{M}\mathbf{C}_z^{(0)}.
\tag{C.2}\]</span></span></p>
<p>Recall from Chapter 2 that <span class="math inline">\(\mathbf{C}_z^{(\tau)}\)</span> is the lag-<span class="math inline">\(\tau\)</span> spatial covariance matrix for <span class="math inline">\(\{\mathbf{Z}_t\}\)</span>. Now, <a href="#eq-CovVAR" class="quarto-xref">Equation&nbsp;<span>C.2</span></a> implies that</p>
<p><span id="eq-MfromMoM"><span class="math display">\[
\mathbf{M}= \mathbf{C}_z^{(1)} (\mathbf{C}_z^{(0)})^{-1}.
\tag{C.3}\]</span></span></p>
<p>Similarly, if we post-multiply <a href="#eq-linearVAR" class="quarto-xref">Equation&nbsp;<span>C.1</span></a> by <span class="math inline">\(\mathbf{Z}'_t\)</span> and take expectations, we can show that</p>
<p><span id="eq-CetafromMoM"><span class="math display">\[
\mathbf{C}_{\eta} = \mathbf{C}_z^{(0)} - \mathbf{M}\mathbf{C}_z^{(1)'} = \mathbf{C}_z^{(0)} - \mathbf{C}_z^{(1)} (\mathbf{C}_z^{(0)})^{-1} \mathbf{C}_z^{(1)'}.
\tag{C.4}\]</span></span></p>
<p>It follows that the method-of-moments estimators (where empirical moments are equated with theoretical moments) of <a href="#eq-MfromMoM" class="quarto-xref">Equation&nbsp;<span>C.3</span></a> and <a href="#eq-CetafromMoM" class="quarto-xref">Equation&nbsp;<span>C.4</span></a> are given by</p>
<p><span id="eq-MestMoM"><span class="math display">\[
\widehat{\mathbf{M}} =  \widehat{\mathbf{C}}_z^{(1)} (\widehat{\mathbf{C}}_z^{(0)})^{-1},
\tag{C.5}\]</span></span></p>
<p><span id="eq-CetaestMoM"><span class="math display">\[
\widehat{\mathbf{C}}_\eta =  \widehat{\mathbf{C}}_z^{(0)} - \widehat{\mathbf{C}}_z^{(1)} (\widehat{\mathbf{C}}_z^{(0)})^{-1} \widehat{\mathbf{C}}_z^{(1)'}.
\tag{C.6}\]</span></span></p>
<p>In <a href="#eq-CetaestMoM" class="quarto-xref">Equation&nbsp;<span>C.6</span></a>, the empirical lag-<span class="math inline">\(\tau\)</span> covariance matrices, <span class="math inline">\(\widehat{\mathbf{C}}_z^{(\tau)}\)</span>, are calculated as shown in <a href="Chapter2.html#eq-emp_cov" class="quarto-xref">Equation&nbsp;<span>2.4</span></a>. Note that <span class="math inline">\(T\)</span> needs to be larger than the dimension of <span class="math inline">\(\mathbf{Z}_t\)</span> to ensure that <span class="math inline">\(\widehat{\mathbf{C}}_z^{(0)}\)</span> is invertible.</p>
<p>As we have said throughout this book, we prefer to consider DSTMs that have a separate data and process model. Estimation for these models is described below in <a href="#sec-estimationLDSTM" class="quarto-xref"><span>Section C.2</span></a>. So, what is the benefit of the method-of-moments approach in the context of DSTMs? In cases where the signal-to-noise ratio is high, the estimates given by <a href="#eq-MestMoM" class="quarto-xref">Equation&nbsp;<span>C.5</span></a> and <a href="#eq-CetaestMoM" class="quarto-xref">Equation&nbsp;<span>C.6</span></a> can provide reasonable estimates for exploratory data analysis. We illustrate an example using method-of-moments estimation in Lab 5.3. Specifically, assume that we project the spatial-mean-centered data onto orthogonal basis functions, <span class="math inline">\(\boldsymbol{\Phi}\)</span>: <span class="math inline">\(\boldsymbol{\alpha}_t = \boldsymbol{\Phi}' (\mathbf{Z}_t - \widehat{\boldsymbol{\mu}})\)</span>. We then assume that the projected data come from the model, <span class="math inline">\(\boldsymbol{\alpha}_t = \mathbf{M}\boldsymbol{\alpha}_{t-\tau} + \boldsymbol{\eta}_t\)</span>, and we obtain estimates <span class="math inline">\(\widehat{\mathbf{M}}\)</span> and <span class="math inline">\(\widehat{\mathbf{C}}_\eta\)</span> based on the projected data. One can then produce forecasts such as <span class="math inline">\(\widehat{\boldsymbol{\alpha}}_{T+\tau} = \widehat{\mathbf{M}} \widehat{\boldsymbol{\alpha}}_T\)</span>, with estimated forecast covariance matrix, <span class="math inline">\(\widehat{\mathbf{C}}_{\alpha} = \widehat{\mathbf{M}} \widehat{\mathbf{C}}_\alpha^{(0)} \widehat{\mathbf{M}}' + \widehat{\mathbf{C}}_\eta\)</span>, where <span class="math inline">\(\widehat{\mathbf{C}}_\alpha^{(0)}\)</span> is the empirical estimate of <span class="math inline">\(E(\boldsymbol{\alpha}_t \boldsymbol{\alpha}_t')\)</span>. To obtain a forecast for <span class="math inline">\(\widehat{\mathbf{Z}}_{T+\tau}\)</span>, one would have to multiply the forecast <span class="math inline">\(\widehat{\boldsymbol{\alpha}}_{T+\tau}\)</span> by the basis-function matrix and add back the spatial mean: <span class="math inline">\(\widehat{\mathbf{Z}}_{T+\tau} = \widehat{\boldsymbol{\mu}} + \boldsymbol{\Phi}\widehat{\boldsymbol{\alpha}}_{T+\tau}\)</span>. The forecast covariance matrix is then approximated by <span class="math inline">\(\widehat{\mathbf{C}}_{Z} = \boldsymbol{\Phi}\widehat{\mathbf{C}}_{\alpha} \boldsymbol{\Phi}'\)</span>, where we have ignored the truncation and measurement error when projecting onto the basis functions. Although this procedure is somewhat <em>ad hoc</em>, it is simple and can give a quick forecast. More importantly, the parameter estimates in this procedure would be used as starting values in the state-space EM algorithm described in <a href="#sec-estimationLDSTM" class="quarto-xref"><span>Section C.2</span></a>. This is demonstrated in the second portion of Lab 5.3.</p>
<p>For completeness, note that when one makes the assumption that the initial spatial data vector <span class="math inline">\(\mathbf{Z}_0\)</span> is known, it can be shown that, conditional on <span class="math inline">\(\mathbf{Z}_0\)</span>, maximum likelihood, least squares, and method-of-moments estimation all give equivalent estimates, <span class="math inline">\(\widehat{\mathbf{M}}\)</span> and <span class="math inline">\(\widehat{\mathbf{C}}_\eta\)</span> <span class="citation" data-cites="harvey1993time">(see, for example, <a href="references.html#ref-harvey1993time" role="doc-biblioref">Harvey, 1993, Section 7.4</a>)</span>.</p>
</section>
<section id="sec-estimationLDSTM" class="level2" data-number="C.2">
<h2 data-number="C.2" class="anchored" data-anchor-id="sec-estimationLDSTM"><span class="header-section-number">C.2</span> Prediction and Estimation in Fully Parameterized Linear DSTMs</h2>
<p>Traditionally, from the data model,</p>
<p><span id="eq-ZlinearGaunobias"><span class="math display">\[
\mathbf{Z}_t =  \mathbf{H}_t \mathbf{Y}_t + \boldsymbol{\varepsilon}_t,\quad \boldsymbol{\varepsilon}_t \sim \; Gau(\mathbf{0},\mathbf{C}_{\epsilon,t}),
\tag{C.7}\]</span></span></p>
<p>and from the process model,</p>
<p><span id="eq-linearDSTMVARb"><span class="math display">\[
\mathbf{Y}_t = \mathbf{M}\mathbf{Y}_{t-1} + \boldsymbol{\eta}_t,\quad \boldsymbol{\eta}_t \sim \; Gau(\mathbf{0},\mathbf{C}_{\eta}),
\tag{C.8}\]</span></span></p>
<p>we obtain a hierarchical model (HM). Note that we have assumed here that there is no additive offset in the data model and that the process has mean zero to simplify the exposition. Next, we can perform prediction on the hidden process via the Kalman filter and Kalman smoother if the parameter matrices are all known. In practice, these are not known, and estimates are sometimes used in their place, which is an empirical hierarchical model (EHM) approach. Note that although in general <span class="math inline">\(\mathbf{M}\)</span> could depend on time (and hence would be written as <span class="math inline">\(\mathbf{M}_t\)</span>), we consider the simpler time-invariant case here.</p>
<section id="sequential-prediction-of-the-process-via-kalman-filtering-and-smoothing" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="sequential-prediction-of-the-process-via-kalman-filtering-and-smoothing">Sequential Prediction of the Process via Kalman Filtering and Smoothing</h3>
<p>In Chapter 1 we discussed the notions of smoothing, filtering, and forecasting. Before we show the filtering and smoothing distributions and algorithms, we need to define some notation and terms. In particular, let <span class="math inline">\(\mathbf{w}_{c:d} \equiv \{\mathbf{w}_c,\ldots,\mathbf{w}_d\}\)</span>, for the generic vector <span class="math inline">\(\mathbf{w}_t\)</span> at times <span class="math inline">\(t \in \{c, c+1,\ldots,d-1,d\}\)</span>. Then we define the <em>forecasting distribution</em> to be the distribution of <span class="math inline">\(\mathbf{Y}_t\)</span> given all of the observations that occur before time <span class="math inline">\(t\)</span>, namely, <span class="math inline">\([\mathbf{Y}_t | \mathbf{Z}_{1:t-1}]\)</span>. We also define the <em>filtering distribution</em> to be the distribution of <span class="math inline">\(\mathbf{Y}_t\)</span> given all of the observations up to and including time <span class="math inline">\(t\)</span>, namely, <span class="math inline">\([\mathbf{Y}_t | \mathbf{Z}_{1:t}]\)</span>. Finally, we define the <em>smoothing distribution</em> to be the distribution of <span class="math inline">\(\mathbf{Y}_t\)</span> given all the observations before, including, and after time <span class="math inline">\(t\)</span>, namely, <span class="math inline">\([\mathbf{Y}_t | \mathbf{Z}_{1:T}]\)</span>, for <span class="math inline">\(1 \leq t \leq T\)</span>.</p>
<p>The forecasting distribution is of most interest when one would like to predict the process one time step into the future; the filtering distribution is typically most useful when one seeks to “filter out” observation error from the true process as data come along sequentially (e.g., in real time); and the smoothing distribution is most useful when one retrospectively wants to smooth out the observation errors for any time in the entire observation period. Now, consider the following notation for the conditional expectations of the forecast and filtering distributions, respectively: <span class="math inline">\(\mathbf{Y}_{t | t-1} \equiv E[\mathbf{Y}_t | \mathbf{Z}_{1:t-1}]\)</span> and <span class="math inline">\(\mathbf{Y}_{t:t} \equiv E[\mathbf{Y}_t | \mathbf{Z}_{1:t}]\)</span>. Similarly, define the conditional covariance matrices for the forecast error and filtering error distributions, respectively, as: <span class="math inline">\(\mathbf{P}_{t|t-1} \equiv E[(\mathbf{Y}_t - \mathbf{Y}_{t|t-1})(\mathbf{Y}_t - \mathbf{Y}_{t|t-1})' | \mathbf{Z}_{1:t-1}]\)</span> and <span class="math inline">\(\mathbf{P}_{t|t} \equiv E[(\mathbf{Y}_t - \mathbf{Y}_{t|t})(\mathbf{Y}_t - \mathbf{Y}_{t|t})' | \mathbf{Z}_{1:t}]\)</span>.</p>
<p>In the case of linear Gaussian data models and process models given by <a href="#eq-ZlinearGaunobias" class="quarto-xref">Equation&nbsp;<span>C.7</span></a> and <a href="#eq-linearDSTMVARb" class="quarto-xref">Equation&nbsp;<span>C.8</span></a>, the forecast and filtering distributions can be found analytically by using standard conditional expectation/variance relationships and Bayes’ Rule, respectively. In particular, the forecast and filtering distributions are denoted, respectively, by</p>
<p><span class="math display">\[
\mathbf{Y}_t | \mathbf{Z}_{1:t-1} \sim \; Gau(\mathbf{Y}_{t | t-1},\mathbf{P}_{t | t-1}),
\]</span></p>
<p>and</p>
<p><span class="math display">\[
\mathbf{Y}_t | \mathbf{Z}_{1:t} \sim \; Gau(\mathbf{Y}_{t | t},\mathbf{P}_{t | t}),
\]</span></p>
<p>and they can be found through the famous <em>Kalman filter algorithm</em> given in <a href="#nte-algorithm-KalmanFilter" class="quarto-xref">Note&nbsp;<span>C.1</span></a>. Thus, given the initial conditions <span class="math inline">\(\mathbf{Y}_{0 | 0} \equiv \boldsymbol{\mu}_0\)</span> and <span class="math inline">\(\mathbf{P}_{0 | 0} \equiv \mathbf{C}_0\)</span> and the parameter matrices, <span class="math inline">\(\{\mathbf{H}_t\}_{t=1}^T\)</span>, <span class="math inline">\(\{\mathbf{C}_{\epsilon,t}\}_{t=1}^T\)</span>, <span class="math inline">\(\mathbf{M}\)</span>, and <span class="math inline">\(\mathbf{C}_{\eta}\)</span>, one can iterate sequentially between the forecast and filtering steps to obtain these distributions for all times <span class="math inline">\(t=1,\ldots,T\)</span>.</p>
<div id="nte-algorithm-KalmanFilter" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;C.1: Kalman Filter
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Set initial conditions: <span class="math inline">\(\mathbf{Y}_{0 | 0} = \boldsymbol{\mu}_0\)</span> and <span class="math inline">\(\mathbf{P}_{0 | 0} = \mathbf{C}_0\)</span></li>
<li><strong>for</strong> <span class="math inline">\(t = 1\)</span> to <span class="math inline">\(T\)</span> <strong>do</strong>
<ol type="1">
<li>Forecast distribution step:
<ol type="a">
<li>Obtain <span class="math inline">\(\mathbf{Y}_{t | t-1} =  \mathbf{M}\mathbf{Y}_{t-1 | t-1}\)</span></li>
<li>Obtain <span class="math inline">\(\mathbf{P}_{t | t-1} = \mathbf{C}_{\eta} + \mathbf{M}\mathbf{P}_{t-1 | t-1} \mathbf{M}'\)</span></li>
</ol></li>
<li>Filtering distribution step:
<ol type="a">
<li>Obtain the Kalman gain, <span class="math inline">\(\mathbf{K}_t \equiv \mathbf{P}_{t | t-1} \mathbf{H}'_t (\mathbf{H}_t \mathbf{P}_{t | t-1} \mathbf{H}'_t + \mathbf{C}_{\epsilon,t})^{-1}\)</span></li>
<li>Obtain <span class="math inline">\(\mathbf{Y}_{t|t} = \mathbf{Y}_{t | t-1} + \mathbf{K}_t (\mathbf{Z}_t - \mathbf{H}_t \mathbf{Y}_{t | t-1})\)</span></li>
<li>Obtain <span class="math inline">\(\mathbf{P}_{t | t} = (\mathbf{I}- \mathbf{K}_t \mathbf{H}_t)\mathbf{P}_{t | t-1}\)</span></li>
</ol></li>
</ol>
<strong>end for</strong></li>
</ul>
</div>
</div>
<p>Recall that the smoothing distribution considers the distribution of the process at time <span class="math inline">\(t\)</span> given <em>all</em> of the observations regardless of whether they come before, during, or after time <span class="math inline">\(t\)</span>. This smoothing distribution is denoted by</p>
<p><span class="math display">\[
\mathbf{Y}_t | \mathbf{Z}_{1:T} \sim \; Gau(\mathbf{Y}_{t | T}, \mathbf{P}_{t | T})
\]</span></p>
<p>and, if one saves the results from the Kalman filter, this can be obtained for all <span class="math inline">\(t\)</span> by the <em>Kalman smoother algorithm</em> (also known as the Rauch–Tung–Striebel smoother) given in <a href="#nte-algorithm-KalmanSmoother" class="quarto-xref">Note&nbsp;<span>C.2</span></a>.</p>
<div id="nte-algorithm-KalmanSmoother" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;C.2: Kalman Smoother
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Obtain <span class="math inline">\(\{\mathbf{Y}_{t|t-1}, \mathbf{P}_{t|t-1}\}_{t=1}^T\)</span> and <span class="math inline">\(\{\mathbf{Y}_{t|t}, \mathbf{P}_{t|t}\}_{t=0}^T\)</span> from the Kalman filter algorithm (<a href="#nte-algorithm-KalmanFilter" class="quarto-xref">Note&nbsp;<span>C.1</span></a>).</li>
<li><strong>for</strong> <span class="math inline">\(t = T-1\)</span> down to <span class="math inline">\(0\)</span> <strong>do</strong>
<ol type="1">
<li>Obtain <span class="math inline">\(\mathbf{J}_t \equiv \mathbf{P}_{t|t} \; \mathbf{M}' \; \mathbf{P}_{t+1|t}^{-1}\)</span>.</li>
<li>Obtain <span class="math inline">\(\mathbf{Y}_{t|T} = \mathbf{Y}_{t|t} + \mathbf{J}_t (\mathbf{Y}_{t+1|T} - \mathbf{Y}_{t+1|t})\)</span>.</li>
<li>Obtain <span class="math inline">\(\mathbf{P}_{t|T} = \mathbf{P}_{t|t} + \mathbf{J}_t (\mathbf{P}_{t+1|T} - \mathbf{P}_{t+1 | t})\mathbf{J}'_t\)</span>.</li>
</ol>
<strong>end for</strong></li>
</ul>
</div>
</div>
</section>
<section id="parameter-estimation-via-the-em-algorithm" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="parameter-estimation-via-the-em-algorithm">Parameter Estimation via the EM Algorithm</h3>
<p>The state-space approach discussed above in terms of the Kalman filter and smoother makes the assumption that the parameter matrices in the data and process models are known. This is unrealistic in most cases, and one must use the data to estimate these parameters; that is, the HM being used is an EHM. One of the most popular (and effective) ways to do this in the state-space time-series case is through the EM algorithm (recall the general EM algorithm presented in <a href="Chapter4.html#nte-algorithm-EMbasic" class="quarto-xref">Note&nbsp;<span>4.4</span></a>).</p>
<p>The state-space version of the EM algorithm, originally developed by <span class="citation" data-cites="shumway1982approach">Shumway &amp; Stoffer (<a href="references.html#ref-shumway1982approach" role="doc-biblioref">1982</a>)</span>, denotes by <span class="math inline">\(\mathbf{Z}_{1:T}\)</span> the observations and the unobservable latent process, and by <span class="math inline">\(\mathbf{Y}_{0:T}\)</span> the “missing data.” Denote the parameters by <span class="math inline">\(\boldsymbol{\Theta}\equiv \{\boldsymbol{\mu}_0, \mathbf{C}_0, \mathbf{C}_\eta, \mathbf{C}_{\epsilon},\mathbf{M}\}\)</span>, where we assume typically that the observation matrices, <span class="math inline">\(\{\mathbf{H}_t\}\)</span>, are all known. We assume that the initial distribution is given by <span class="math inline">\(\mathbf{Y}_{0|0} \sim \; Gau(\boldsymbol{\mu}_0, \mathbf{C}_0)\)</span>, and we further assume here (for simplicity) that <span class="math inline">\(\mathbf{C}_{\epsilon}\)</span> corresponds to the <span class="math inline">\(m \times m\)</span> measurement-error covariance matrix for all possible observation locations (thus, <span class="math inline">\(\mathbf{C}_{\epsilon,t} = \mathbf{C}_{\epsilon}\)</span>, for all <span class="math inline">\(t\)</span>, so <span class="math inline">\(m_t = m\)</span> and we assume no missing observations at each time point). The EM algorithm is then based on the complete-data likelihood given by <span class="math inline">\([\mathbf{Z}_{1:T}, \mathbf{Y}_{0:T} | \boldsymbol{\Theta}] = \left(\prod_{t=1}^T [\mathbf{Z}_t | \mathbf{Y}_t]\right) \left(\prod_{t=1}^T [\mathbf{Y}_t | \mathbf{Y}_{t-1}]\right) [\mathbf{Y}_0]\)</span>, which again makes use of the conditional independencies in the data model and the Markov property of the process model. The EM algorithm for a linear DSTM, presented in <a href="#nte-algorithm-DSTMEM" class="quarto-xref">Note&nbsp;<span>C.3</span></a>, makes use of the Kalman smoother algorithm to evaluate both the E-step and the M-step. Note that, in addition to running the Kalman smoother at each iteration of the algorithm, we also have to obtain the so-called “lagged-one smoother” variance-covariance matrix, <span class="math inline">\(\mathbf{P}_{t,t-1|T} \equiv E((\mathbf{Y}_t - \mathbf{Y}_{t|T})(\mathbf{Y}_{t-1} - \mathbf{Y}_{t-1|T})' | \mathbf{Z}_{1:T})\)</span>, for <span class="math inline">\(t=T,T-1,\ldots.\)</span> This is accomplished by the so-called <em>lag-one covariance smoother</em>, which is part of the algorithm in <a href="#nte-algorithm-DSTMEM" class="quarto-xref">Note&nbsp;<span>C.3</span></a>. Convergence can be assessed by considering parameter changes and/or changes to the log complete-data likelihood (i.e., see <a href="#eq-EMlogL" class="quarto-xref">Equation&nbsp;<span>C.9</span></a> in <a href="#nte-algorithm-DSTMEM" class="quarto-xref">Note&nbsp;<span>C.3</span></a>). Typically, in the linear DSTM case, one considers the latter because there are a large number of parameters. An example of using the EM algorithm for a linear DSTM is given in Lab 5.3.</p>
<div id="nte-algorithm-DSTMEM" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;C.3: Linear DSTM EM Algorithm
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Choose initial condition covariance matrix, <span class="math inline">\(\mathbf{C}_0\)</span></li>
<li>Choose starting values: <span class="math inline">\(\widehat{\boldsymbol{\Theta}}^{(0)} =\{\widehat{\boldsymbol{\mu}}_0^{(0)}, \widehat{\mathbf{C}}_{\eta}^{(0)}, \widehat{\mathbf{C}}_{\epsilon}^{(0)}, \widehat{\mathbf{M}}^{(0)} \}\)</span></li>
<li><strong>repeat</strong> <span class="math inline">\(i=1,2,\ldots\)</span></li>
</ul>
<ol type="1">
<li>E-step:
<ul>
<li><p>Use <span class="math inline">\(\widehat{\boldsymbol{\Theta}}^{(i-1)}\)</span> in the Kalman smoother (<a href="#nte-algorithm-KalmanSmoother" class="quarto-xref">Note&nbsp;<span>C.2</span></a>) to obtain <span class="math inline">\(\{\mathbf{Y}_{t|T}^{(i-1)}, \mathbf{P}_{t|T}^{(i-1)}\}\)</span></p></li>
<li><p>Use Kalman smoother output to obtain the lag-one covariance smoother estimates</p></li>
<li><p>Calculate <span class="math inline">\(\mathbf{P}^{(i-1)}_{T,T-1|T} = (\mathbf{I}- \mathbf{K}^{(i-1)}_T \mathbf{H}_T)\mathbf{M}^{(i-1)} \mathbf{P}^{(i-1)}_{T-1|T-1}\)</span></p></li>
<li><p><strong>for</strong> <span class="math inline">\(t=T,T-1,\ldots,2\)</span> <strong>do</strong> <span class="math display">\[
\mathbf{P}^{(i-1)}_{t-1,t-2|T}  =  \mathbf{P}^{(i-1)}_{t-1|t-1} \mathbf{J}^{(i-1)'}_{t-2} + \mathbf{J}^{(i-1)'}_{t-1}(\mathbf{P}^{(i-1)}_{t,t-1|T} - \mathbf{M}^{(i-1)} \mathbf{P}^{(i-1)}_{t-1|t-1})\mathbf{J}^{(i-1)'}_{t-2}
\]</span></p>
<p><strong>end for</strong></p></li>
<li><p>Calculate <span class="math inline">\(\mathbf{S}_{00} \equiv \sum_{t=1}^T (\mathbf{P}^{(i-1)}_{t-1 | T} + \mathbf{Y}^{(i-1)}_{t-1|T} \mathbf{Y}^{(i-1)'}_{t-1|T})\)</span></p></li>
<li><p>Calculate <span class="math inline">\(\mathbf{S}_{11} \equiv \sum_{t=1}^T (\mathbf{P}^{(i-1)}_{t | T} + \mathbf{Y}^{(i-1)}_{t|T} \mathbf{Y}^{(i-1)'}_{t|T})\)</span></p></li>
<li><p>Calculate <span class="math inline">\(\mathbf{S}_{10} \equiv \sum_{t=1}^T (\mathbf{P}^{(i-1)}_{t,t-1 | T} + \mathbf{Y}^{(i-1)}_{t|T} \mathbf{Y}^{(i-1)'}_{t-1|T})\)</span></p></li>
</ul></li>
<li>M-step:
<ul>
<li>Update: <span class="math inline">\(\widehat{\boldsymbol{\mu}}_0^{(i)} = \mathbf{Y}^{(i-1)}_{0|T}\)</span></li>
<li>Update: <span class="math inline">\(\widehat{\mathbf{M}}^{(i)} = \mathbf{S}_{10}\mathbf{S}_{00}^{-1}\)</span></li>
<li>Update: <span class="math inline">\(\widehat{\mathbf{C}}_{\eta}^{(i)} = (1/T)(\mathbf{S}_{11} - \mathbf{S}_{10}\mathbf{S}_{00}^{-1} \mathbf{S}_{10}')\)</span></li>
<li>Update: <span class="math display">\[
\widehat{\mathbf{C}}_{\epsilon}^{(i)}  =  \frac1T \sum_{t=1}^T ((\mathbf{Z}_t - \mathbf{H}_t \mathbf{Y}^{(i-1)}_{t|T})(\mathbf{Z}_t - \mathbf{H}_t \mathbf{Y}^{(i-1)}_{t|T})' + \mathbf{H}_t \mathbf{P}^{(i-1)}_{t|T} \mathbf{H}'_t)
\]</span></li>
</ul>
<strong>until</strong> convergence (typically, based on differences in <span class="math inline">\(-2\ln(L(\boldsymbol{\Theta}| \mathbf{Z}_{1:T},\mathbf{Y}_{0:T}))\)</span> as calculated in <a href="#eq-EMlogL" class="quarto-xref">Equation&nbsp;<span>C.9</span></a>:</li>
</ol>
<p><span id="eq-EMlogL"><span class="math display">\[
\small
\begin{aligned}
-2 \ln(L(\boldsymbol{\Theta}^{(i)} | \mathbf{Z}_{1:T},\mathbf{Y}^{(i)}_{0:T}))  =  \ln(|\widehat{\mathbf{C}}^{(i)}_0|) + (\mathbf{Y}^{(i)}_{0|T} - \widehat{\boldsymbol{\mu}}^{(i)}_0)'\widehat{\mathbf{C}}_0^{-1{(i)}}(\mathbf{Y}^{(i)}_{0|T} - \widehat{\boldsymbol{\mu}}^{(i)}_0) \\
+  T \ln(|\widehat{\mathbf{C}}^{(i)}_{\eta}|) + \sum_{t=1}^T (\mathbf{Y}^{(i)}_{t|T} - \widehat{\mathbf{M}}^{(i)} \mathbf{Y}^{(i)}_{t-1|T})'\widehat{\mathbf{C}}_{\eta}^{-1{(i)}}(\mathbf{Y}^{(i)}_{t|T} - \widehat{\mathbf{M}}^{(i)} \mathbf{Y}^{(i)}_{t-1|T}) \\
  +   T \ln(|\widehat{\mathbf{C}}^{(i)}_{\epsilon}|) + \sum_{t=1}^T (\mathbf{Z}_t - \mathbf{H}_t \mathbf{Y}^{(i)}_{t|T})'\widehat{\mathbf{C}}_{\epsilon}^{-1{(i)}}(\mathbf{Z}_t - \mathbf{H}_t \mathbf{Y}^{(i)}_{t|T}).
\end{aligned}
\tag{C.9}\]</span></span></p>
</div>
</div>
<p>Uncertainty estimates are less easily obtained for the parameter estimates than they are for the state-process estimates, but they can be obtained through considering the inverse of the associated asymptotic information matrix or by parametric bootstrap methods. Unfortunately, obtaining uncertainty estimates even for the state-process estimates is not often done in practice and, as discussed in the comments motivating DSTMs in <a href="Chapter5.html#sec-LinGaussProcess" class="quarto-xref"><span>Section 5.2.3</span></a>, it can be problematic because of the potential for explosive behavior by some of the transition matrices whose parameters are within the joint confidence region.</p>
<p>More flexible inference for DSTMs can be accomplished by the fully hierarchical Bayesian hierarchical model (BHM); see <a href="Chapter4.html#sec-BHMest" class="quarto-xref"><span>Section 4.5.2</span></a> as well as <span class="citation" data-cites="cressie2011statistics">(<a href="references.html#ref-cressie2011statistics" role="doc-biblioref">Cressie &amp; Wikle, 2011, Chapter 8</a>)</span>. These BHM implementations are often problem-specific, and they are often best implemented directly in <code>R</code> or in a so-called probabilistic programming language (e.g., Stan, WinBugs, JAGS). For an example, see the Gibbs sampler MCMC algorithm (corresponding to a BHM) to predict Mediterranean surface winds implemented in <a href="ChapterAppendixE.html" class="quarto-xref"><span>Appendix E</span></a>.</p>
</section>
</section>
<section id="sec-Est_and_pred" class="level2" data-number="C.3">
<h2 data-number="C.3" class="anchored" data-anchor-id="sec-Est_and_pred"><span class="header-section-number">C.3</span> Estimation for Non-Gaussian and Nonlinear DSTMs</h2>
<p>In principle, the filtering and smoothing methods presented in <a href="#sec-estimationLDSTM" class="quarto-xref"><span>Section C.2</span></a> can be generalized to the setting of non-Gaussian and nonlinear DSTMs (e.g., particle filters and smoothers, ensemble Kalman filters; see Chapter 8 of <span class="citation" data-cites="cressie2011statistics">Cressie &amp; Wikle (<a href="references.html#ref-cressie2011statistics" role="doc-biblioref">2011</a>)</span>). However, in the high-dimensional settings with deep BHMs with complicated parameter-dependence structures, one typically has to consider fully Bayesian implementations. As mentioned above, these implementations are often programmed “from scratch” rather than from particular <code>R</code> packages. As an example, see the BHM based on a linear DSTM with Gaussian error given in <a href="ChapterAppendixE.html" class="quarto-xref"><span>Appendix E</span></a>.</p>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" data-line-spacing="2" role="list" style="display: none">
<div id="ref-cressie2011statistics" class="csl-entry" role="listitem">
Cressie, N., &amp; Wikle, C. K. (2011). <em>Statistics for spatio-temporal data</em>. John Wiley &amp; Sons.
</div>
<div id="ref-harvey1993time" class="csl-entry" role="listitem">
Harvey, A. C. (1993). <em>Time series models</em> (2nd ed.). MIT Press.
</div>
<div id="ref-lutkepohl2005new" class="csl-entry" role="listitem">
Lütkepohl, H. (2005). <em>New introduction to multiple time series analysis</em>. Springer.
</div>
<div id="ref-shumway1982approach" class="csl-entry" role="listitem">
Shumway, R. H., &amp; Stoffer, D. S. (1982). An approach to time series smoothing and forecasting using the EM algorithm. <em>Journal of Time Series Analysis</em>, <em>3</em>(4), 253–264.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./ChapterAppendixB.html" class="pagination-link" aria-label="General Smoothing\index{smoothing} Kernels">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">General Smoothing Kernels</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./ChapterAppendixD.html" class="pagination-link" aria-label="Mechanistically Motivated Dynamic Spatio-Temporal Models">
        <span class="nav-page-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Mechanistically Motivated Dynamic Spatio-Temporal Models</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>