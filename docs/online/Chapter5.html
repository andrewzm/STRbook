<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.28">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>5&nbsp; Dynamic Spatio-Temporal Models – Spatio-Temporal Statistics with R (1st edition)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Chapter6.html" rel="next">
<link href="./Chapter4.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-b719d3d4935f2b08311a76135e2bf442.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-7d2e1f8220df954187ab24ed36a0da9c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/quarto-contrib/foldbox/foldbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
.Algorithm {
  --color1: #948bde;
  --color2: #584eab;
}
</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Chapter5.html"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Dynamic Spatio-Temporal Models</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Spatio-Temporal Statistics with R (1st edition)</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction to Spatio-Temporal Statistics</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Exploring Spatio-Temporal Data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Spatio-Temporal Statistical Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Descriptive Spatio-Temporal Statistical Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter5.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Dynamic Spatio-Temporal Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Evaluating Spatio-Temporal Statistical Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterPergimus.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Pergimus (Epilogue)</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixA.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Some Useful Matrix-Algebra Definitions and Properties</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixB.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">General Smoothing Kernels</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixC.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Estimation and Prediction for Dynamic Spatio-Temporal Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixD.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Mechanistically Motivated Dynamic Spatio-Temporal Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">Case Study: Physical-Statistical Bayesian Hierarchical Model for Predicting Mediterranean Surface Winds</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixF.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">Case Study: Quadratic Echo State Networks for Sea Surface Temperature Long-Lead Prediction</span></span></a>
  </div>
</li>
      </ul>
  </li>
  <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterRPackages.html" class="sidebar-item-text sidebar-link">
  <span class="menu-text">List of <code>R</code> packages</span></a>
  </div>
  </li>
  <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
  <span class="menu-text">References</span></a>
  </div>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-GDSTM" id="toc-sec-GDSTM" class="nav-link active" data-scroll-target="#sec-GDSTM"><span class="header-section-number">5.1</span> General Dynamic Spatio-Temporal Models</a>
  <ul class="collapse">
  <li><a href="#sec-GDSTMdatamod" id="toc-sec-GDSTMdatamod" class="nav-link" data-scroll-target="#sec-GDSTMdatamod"><span class="header-section-number">5.1.1</span> Data Model</a></li>
  <li><a href="#sec-procmodel" id="toc-sec-procmodel" class="nav-link" data-scroll-target="#sec-procmodel"><span class="header-section-number">5.1.2</span> Process Model</a></li>
  <li><a href="#parameters" id="toc-parameters" class="nav-link" data-scroll-target="#parameters"><span class="header-section-number">5.1.3</span> Parameters</a></li>
  </ul></li>
  <li><a href="#sec-LGDSTM" id="toc-sec-LGDSTM" class="nav-link" data-scroll-target="#sec-LGDSTM"><span class="header-section-number">5.2</span> Latent Linear Gaussian DSTMs</a>
  <ul class="collapse">
  <li><a href="#sec-DataLGDSTM" id="toc-sec-DataLGDSTM" class="nav-link" data-scroll-target="#sec-DataLGDSTM"><span class="header-section-number">5.2.1</span> Linear Data Model with Additive Gaussian Error</a></li>
  <li><a href="#sec-NonGauDataMod" id="toc-sec-NonGauDataMod" class="nav-link" data-scroll-target="#sec-NonGauDataMod"><span class="header-section-number">5.2.2</span> Non-Gaussian and Nonlinear Data Model</a></li>
  <li><a href="#sec-LinGaussProcess" id="toc-sec-LinGaussProcess" class="nav-link" data-scroll-target="#sec-LinGaussProcess"><span class="header-section-number">5.2.3</span> Process Model</a></li>
  </ul></li>
  <li><a href="#sec-ProcParamRed" id="toc-sec-ProcParamRed" class="nav-link" data-scroll-target="#sec-ProcParamRed"><span class="header-section-number">5.3</span> Process and Parameter Dimension Reduction</a>
  <ul class="collapse">
  <li><a href="#sec-ParmReduc" id="toc-sec-ParmReduc" class="nav-link" data-scroll-target="#sec-ParmReduc"><span class="header-section-number">5.3.1</span> Parameter Dimension Reduction</a></li>
  <li><a href="#sec-ProcRed" id="toc-sec-ProcRed" class="nav-link" data-scroll-target="#sec-ProcRed"><span class="header-section-number">5.3.2</span> Dimension Reduction in the Process Model</a></li>
  </ul></li>
  <li><a href="#sec-nonlinearDSTMs" id="toc-sec-nonlinearDSTMs" class="nav-link" data-scroll-target="#sec-nonlinearDSTMs"><span class="header-section-number">5.4</span> Nonlinear DSTMs</a></li>
  <li><a href="#chapter-5-wrap-up" id="toc-chapter-5-wrap-up" class="nav-link" data-scroll-target="#chapter-5-wrap-up"><span class="header-section-number">5.5</span> Chapter 5 Wrap-Up</a></li>
  <li><a href="#lab-5.1-implementing-an-ide-model-in-one-dimensional-space" id="toc-lab-5.1-implementing-an-ide-model-in-one-dimensional-space" class="nav-link" data-scroll-target="#lab-5.1-implementing-an-ide-model-in-one-dimensional-space">Lab 5.1: Implementing an IDE Model in One-Dimensional Space</a>
  <ul class="collapse">
  <li><a href="#constructing-the-process-grid-and-kernel" id="toc-constructing-the-process-grid-and-kernel" class="nav-link" data-scroll-target="#constructing-the-process-grid-and-kernel">Constructing the Process Grid and Kernel</a></li>
  <li><a href="#simulating-from-the-ide" id="toc-simulating-from-the-ide" class="nav-link" data-scroll-target="#simulating-from-the-ide">Simulating from the IDE</a></li>
  <li><a href="#simulating-observations" id="toc-simulating-observations" class="nav-link" data-scroll-target="#simulating-observations">Simulating Observations</a></li>
  </ul></li>
  <li><a href="#lab-5.2-spatio-temporal-inference-using-the-ide-model" id="toc-lab-5.2-spatio-temporal-inference-using-the-ide-model" class="nav-link" data-scroll-target="#lab-5.2-spatio-temporal-inference-using-the-ide-model">Lab 5.2: Spatio-Temporal Inference using the IDE Model</a>
  <ul class="collapse">
  <li><a href="#simulation-example-with-a-spatially-invariant-kernel" id="toc-simulation-example-with-a-spatially-invariant-kernel" class="nav-link" data-scroll-target="#simulation-example-with-a-spatially-invariant-kernel">Simulation Example with a Spatially Invariant Kernel</a></li>
  <li><a href="#simulation-example-with-a-spatially-varying-kernel" id="toc-simulation-example-with-a-spatially-varying-kernel" class="nav-link" data-scroll-target="#simulation-example-with-a-spatially-varying-kernel">Simulation Example with a Spatially Varying Kernel</a></li>
  <li><a href="#the-sydney-radar-data-set" id="toc-the-sydney-radar-data-set" class="nav-link" data-scroll-target="#the-sydney-radar-data-set">The Sydney Radar Data Set</a></li>
  </ul></li>
  <li><a href="#lab-5.3-spatio-temporal-inference-with-unknown-evolution-operator" id="toc-lab-5.3-spatio-temporal-inference-with-unknown-evolution-operator" class="nav-link" data-scroll-target="#lab-5.3-spatio-temporal-inference-with-unknown-evolution-operator">Lab 5.3: Spatio-Temporal Inference with Unknown Evolution Operator</a>
  <ul class="collapse">
  <li><a href="#time-series-framework" id="toc-time-series-framework" class="nav-link" data-scroll-target="#time-series-framework">Time-Series Framework</a></li>
  <li><a href="#state-space-framework" id="toc-state-space-framework" class="nav-link" data-scroll-target="#state-space-framework">State-Space Framework</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Dynamic Spatio-Temporal Models</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Chapter 4 presented the “descriptive” approach to incorporating spatio-temporal statistical dependence into models. This chapter discusses the “dynamic” approach, closer to that holy grail of <em>causation</em> that scientists talk and theorize about and that often drives their experiments. In contrast to descriptive models, which fit means and covariances to spatio-temporal data, dynamic models can more easily use scientific knowledge and probability distributions to capture the evolution of current and future spatial fields from past fields.</p>
<p>To convince yourself that this dynamic approach has merit, just look around. If you have ever been mesmerized by waves breaking on the beach, storm clouds building on the horizon, or huge flocks of birds flying collectively in formation, you have witnessed spatio-temporal dynamics in action. What these processes (and many others) have in common is the spatial arrangement of the objects or fields changing, or evolving, from one moment to the next. This is how nature works at the macro scale - the current state of nature evolves from past states. Why does this matter if you are interested in simply modeling data that are indexed in space and time? Don’t the descriptive models presented in Chapter 4 represent nature as well?</p>
<p>The short answer to the second question is “yes,” but less directly. As we discuss in this chapter, it is difficult to describe all the joint and marginal dependence structures that exist in nature and respect this natural dynamic evolution - which answers the first question. While there are important differences, common to both Chapter 4 and this chapter is a statistical modeling approach where we <em>always</em> attempt to account for uncertainty, both in our understanding of the process of interest and in the data we observe.</p>
<p>The primary focus of this chapter is on linear dynamic spatio-temporal models (DSTMs) in the univariate context. Although it is reasonable, and often quite useful, to consider such processes to be continuous in time, for the sake of brevity we focus here on the more practical case where time has been discretized. However, we note that many science-oriented mechanistic models are specified from a continuous-time perspective (e.g., stochastic differential equations), and these are used to motivate the dynamic portion of the DSTM. It is beyond the scope of this book to take a continuous-time perspective, although it does fit into the DSTM framework.</p>
<p>For readers who have more of a time-series background, the DSTM could be thought of as a <em>time series of spatial processes</em>. We could consider an alternative perspective where the spatio-temporal process is a <em>spatial process of time series</em>, but the former perspective describes more naturally the dynamic evolutional aspect of the type of real-world phenomena discussed above. In particular, such a framework allows one not only to make predictions of spatial processes into the future, but also to make inference on parameters of models that correspond to mechanistic (e.g., physical or biological or economic …) processes. This gives DSTMs a powerful insight into causative mechanisms.</p>
<p>We start the chapter with a general hierarchical DSTM formulation in <a href="#sec-GDSTM" class="quarto-xref"><span>Section 5.1</span></a>, followed by a more complete discussion of the special case of the linear Gaussian DSTM in <a href="#sec-LGDSTM" class="quarto-xref"><span>Section 5.2</span></a>. This includes brief discussion of data models, process models, and parameter models. <a href="#sec-ProcParamRed" class="quarto-xref"><span>Section 5.3</span></a> considers approaches for dealing with the curse of dimensionality in spatial processes and parameter spaces that is often present in DSTM settings. <a href="#sec-nonlinearDSTMs" class="quarto-xref"><span>Section 5.4</span></a> gives a brief discussion of nonlinear DSTMs. More details on the technical aspects are given in a number of appendices: we present some standard estimation and prediction algorithms in <a href="ChapterAppendixC.html" class="quarto-xref"><span>Appendix C</span></a> and examples of parameter reduction and process motivation through mechanistic models in <a href="ChapterAppendixD.html" class="quarto-xref"><span>Appendix D</span></a>. Finally, <a href="ChapterAppendixE.html" class="quarto-xref"><span>Appendix E</span></a> and <a href="ChapterAppendixF.html" class="quarto-xref"><span>Appendix F</span></a> present case studies on mechanistically motivated prediction of Mediterranean winds and a machine-learning-motivated nonlinear DSTM for forecasting tropical Pacific SSTs, respectively.</p>
<section id="sec-GDSTM" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="sec-GDSTM"><span class="header-section-number">5.1</span> General Dynamic Spatio-Temporal Models</h2>
<p>As discussed in Chapter 1, we like to consider statistical models from a hierarchical modeling (HM) perspective. In the context of DSTMs, this means that at a minimum we must specify: a “data model” that gives a model for the data, conditioned on the true process of interest and some parameters; a “process model” that specifies the dynamic evolution of the spatio-temporal process, given some parameters; and either models for the parameters from the previous two stages (<em>Bayesian</em> hierarchical model, BHM), or “plug-in” estimates of the parameters (empirical hierarchical model, EHM). In this section we give a general overview of hierarchical modeling in the context of a DSTM.</p>
<p>Recall from our preamble that we are considering discrete time here with temporal domain <span class="math inline">\(D_t = \{0,1,2,\ldots\}\)</span>, where we assume a constant time increment <span class="math inline">\(\Delta_t = 1\)</span> (without loss of generality). We shall consider spatial locations for our observations and our latent process to be in some spatial domain <span class="math inline">\(D_s\)</span> (which we may consider continuous or discrete and finite, depending on the context). The data can potentially come from anywhere and any time in the spatial and temporal domains; we denote data and potential data by <span class="math inline">\(\{Z_t(\mathbf{s}): \mathbf{s}\in D_s;\ t=0,1,\ldots\}\)</span>, although only a subset is actually observed. The latent process is denoted by <span class="math inline">\(\{Y_t(\mathbf{s}): \mathbf{s}\in D_s;\ t=0,1,\ldots\}\)</span>, and we may make inference on <span class="math inline">\(Y_{t_0}(\mathbf{s}_0)\)</span>, even though there is no datum <span class="math inline">\(Z_{t_0}(\mathbf{s}_0)\)</span>. Note that, unlike the models presented in Chapter 4, we change notation slightly and use a subscript <span class="math inline">\(t\)</span> to represent time here, as is customary for discrete-time processes with <span class="math inline">\(D_t = \{0,1,2,\ldots\}\)</span>.</p>
<section id="sec-GDSTMdatamod" class="level3" data-number="5.1.1">
<h3 data-number="5.1.1" class="anchored" data-anchor-id="sec-GDSTMdatamod"><span class="header-section-number">5.1.1</span> Data Model</h3>
<p>We begin with a data model that describes the relationship between the observations and the latent spatio-temporal process. Generally, we could write the data model in a DSTM as</p>
<p><span class="math display">\[
Z_t(\cdot)  =  {\cal{H}}_t({Y}_t(\cdot), {\boldsymbol{\theta}}_{d,t}, {\epsilon}_t(\cdot)),\quad t=1,\ldots,T,
\]</span></p>
<p>where <span class="math inline">\(Z_t(\cdot)\)</span> corresponds to the data at time <span class="math inline">\(t\)</span> (and we use <span class="math inline">\((\cdot)\)</span> to represent arbitrary spatial locations), <span class="math inline">\({Y}_t(\cdot)\)</span> is the latent spatio-temporal process of interest, with a linear or nonlinear mapping, <span class="math inline">\({\cal{H}}_t\)</span>, that connects the data to the latent process. The data-model error, which is typically measurement error and sometimes small-scale spatio-temporal variability, is given by <span class="math inline">\({ \epsilon}_t(\cdot)\)</span>. Finally, data-model parameters, which themselves may vary spatially and/or temporally, are represented by the vector <span class="math inline">\({\boldsymbol{\theta}}_{d,t}\)</span>. An important assumption here, and in many hierarchical representations of DSTMs, is that the data <span class="math inline">\(Z_t(\cdot)\)</span> are independent (in time) <em>when conditioned</em> on the true process <span class="math inline">\({Y}_t(\cdot)\)</span> and parameters <span class="math inline">\({\boldsymbol{\theta}}_{d,t}\)</span>. Under this conditional-independence assumption, the joint distribution of the data conditioned on the true process and parameters can be represented in product form,</p>
<p><span id="eq-ZgivenYgeneralproduct"><span class="math display">\[
[ \{Z_t(\cdot)\}_{t=1}^T \; | \{Y_t(\cdot)\}_{t=1}^T , \{{\boldsymbol{\theta}}_{d,t}\}_{t=1}^T ]
  \; = \; \prod_{t=1}^T[Z_t(\cdot) \; | \; Y_{t}(\cdot),{\boldsymbol{\theta}}_{d,t}].
\tag{5.1}\]</span></span></p>
<p>This is one of two key independence/dependence assumptions in DSTMs (the other is discussed in <a href="#sec-procmodel" class="quarto-xref"><span>Section 5.1.2</span></a> below). Most applications consider the component distributions on the right-hand side of <a href="#eq-ZgivenYgeneralproduct" class="quarto-xref">Equation&nbsp;<span>5.1</span></a> to be Gaussian, but it is not uncommon to consider other members of the exponential family of distributions (see <a href="#sec-NonGauDataMod" class="quarto-xref"><span>Section 5.2.2</span></a> below). Indeed, a broader class of data models than the familiar Gaussian model is fairly easy to consider so long as the observations are conditionally independent given the true process. We consider specific examples of data models in <a href="#sec-DataLGDSTM" class="quarto-xref"><span>Section 5.2.1</span></a>.</p>
</section>
<section id="sec-procmodel" class="level3" data-number="5.1.2">
<h3 data-number="5.1.2" class="anchored" data-anchor-id="sec-procmodel"><span class="header-section-number">5.1.2</span> Process Model</h3>
<p>Perhaps the most important part of a DSTM is the decomposition of the joint distribution of the process in terms of conditional distributions that respect the time evolution of the spatial process. With <span class="math inline">\(Y_t(\cdot)\)</span> corresponding to the spatial process at time <span class="math inline">\(t\)</span>, we can always factor the joint distribution using the chain rule of conditional probabilities:</p>
<p><span class="math display">\[
\begin{aligned}
\left[Y_0(\cdot),\ldots,Y_T(\cdot)\right] &amp;= [Y_T(\cdot) \mid Y_{T-1}(\cdot),\ldots,Y_0(\cdot)] \\
  &amp;\quad\times [Y_{T-1}(\cdot) \mid Y_{T-2}(\cdot),\ldots,Y_0(\cdot)] \times \dots \\
  &amp;\quad\times [Y_2(\cdot) \mid Y_1(\cdot),Y_0(\cdot)]\\
  &amp;\quad\times [Y_1(\cdot)\mid Y_0(\cdot)] \\
  &amp;\quad\times [Y_0(\cdot)],
\end{aligned}
\]</span></p>
<p>where, for notational simplicity, the dependence of these distributions on parameters has been suppressed. By itself, this decomposition is not all that useful because it requires a separate conditional model for <span class="math inline">\(Y_t(\cdot)\)</span> at each <span class="math inline">\(t\)</span>. However, if we make a modeling <em>assumption</em> that utilizes <em>conditional independence</em>, then such a hierarchical decomposition can be quite useful. For example, we could make a <em>Markov</em> assumption; that is, conditioned on the past, only the recent past is important to explain the present. Under the first-order <em>Markov</em> assumption that the process at time <span class="math inline">\(t\)</span> conditioned on all of the past is only dependent on the <em>most</em> recent past (and an additional modeling assumption that this process only depends on the current parameters), we get a very useful simplification,</p>
<p><span id="eq-YMarkov1general"><span class="math display">\[
[Y_t(\cdot) | Y_{t-1}(\cdot),\ldots,Y_0(\cdot), \{{\boldsymbol{\theta}}_{p,t}\}_{t=0}^{T}] = [Y_t(\cdot) | Y_{t-1}(\cdot),{\boldsymbol{\theta}}_{p,t}],
\tag{5.2}\]</span></span></p>
<p>for <span class="math inline">\(t=1,2,\ldots,\)</span> so that</p>
<p><span id="eq-Markovproduct"><span class="math display">\[
[Y_0(\cdot),Y_1(\cdot),\ldots,Y_T(\cdot) | \{{\boldsymbol{\theta}}_{p,t}\}_{t=0}^T] =  \left( \prod_{t=1}^T[Y_t(\cdot) | Y_{t-1}(\cdot), {\boldsymbol{\theta}}_{p,t}] \right) [Y_0(\cdot) | {\boldsymbol{\theta}}_{p,0}].
\tag{5.3}\]</span></span></p>
<p>This is the second of the key assumptions that is usually made for DSTMs (the first was discussed above in <a href="#sec-GDSTMdatamod" class="quarto-xref"><span>Section 5.1.1</span></a>).</p>
<p>This first-order-Markov assumption, which is simple but powerful in spatio-temporal statistics, holds when <span class="math inline">\(\{Y_t(\cdot)\}\)</span> follows a <em>dynamic model</em> of the form</p>
<p><span id="eq-Yprocess"><span class="math display">\[
{Y}_t(\cdot)  =  {\cal M}({Y}_{t-1}(\cdot), {\boldsymbol{\theta}}_{p,t}, { \eta}_t(\cdot)),\quad t=1,2,\ldots,
\tag{5.4}\]</span></span></p>
<p>where <span class="math inline">\({\boldsymbol{\theta}}_{p,t}\)</span> are parameters (possibly with spatial or temporal dependence) that control the process evolution described by the evolution operator <span class="math inline">\({\cal M}\)</span>, and <span class="math inline">\(\eta_t(\cdot)\)</span> is a spatial noise (error) process that is independent in time (i.e., <span class="math inline">\(\eta_t(\cdot)\)</span> and <span class="math inline">\(\eta_r(\cdot)\)</span> are independent for <span class="math inline">\(r \neq t\)</span>). In general, this model can be linear or nonlinear and the associated conditional distribution, <span class="math inline">\([Y_t(\cdot) \; | Y_{t-1}(\cdot)]\)</span>, can be Gaussian or non-Gaussian. As in autoregressive modeling in time series, one can make higher-order Markov assumptions in this case as well, which requires additional time lags of the spatial process to be included on the right-hand side of the conditioning symbol “<span class="math inline">\(\; | \;\)</span>” in the component distributions of <a href="#eq-Markovproduct" class="quarto-xref">Equation&nbsp;<span>5.3</span></a>. We focus primarily on the first-order-Markov case here, which is usually assumed; however, note that one can always reformulate a higher-order Markov model as a first-order model, albeit increasing the dimensionality of the process, so the first-order representation in terms of probability distributions is actually quite general. One also needs to specify a distribution for the initial state, <span class="math inline">\([{Y}_0(\cdot) | {\boldsymbol{\theta}}_{p,0}]\)</span> or condition on it. We consider specific examples of DSTM process models in <a href="#sec-LinGaussProcess" class="quarto-xref"><span>Section 5.2.3</span></a>.</p>
</section>
<section id="parameters" class="level3" data-number="5.1.3">
<h3 data-number="5.1.3" class="anchored" data-anchor-id="parameters"><span class="header-section-number">5.1.3</span> Parameters</h3>
<p>A BHM requires distributions to be assigned to the parameters defined in the data model and the process model, namely <span class="math inline">\(\{{\boldsymbol{\theta}}_{d,t}, {\boldsymbol{\theta}}_{p,t}\}.\)</span> Specific distributional forms for the parameters (e.g., spatially or temporally varying dependence on auxiliary covariate information) depend strongly on the problem of interest. Indeed, as mentioned in Chapter 1, one of the most important aspects of “deep” hierarchical modeling is the specification of these distributions, especially when one must deal with the curse of dimensionality. In that case, the primary modeling challenge in DSTMs is to come up with ways to effectively reduce the parameter space. This is illustrated in <a href="#sec-ParmReduc" class="quarto-xref"><span>Section 5.3.1</span></a> with regard to linear DSTMs.</p>
<p>Despite the power of the BHM, in many cases it is possible and sufficient to simply estimate the parameters in an EHM context. This is commonly done in state-space models in time series and often utilizes the expectation-maximization (EM) algorithm or, as is done in the engineering literature, “state augmentation,” where the process “vector” is augmented by the parameters. Again, the choice of the estimation approach is very problem-specific. We give a general EM algorithm for linear DSTMs in <a href="ChapterAppendixC.html#sec-estimationLDSTM" class="quarto-xref"><span>Section C.2</span></a>.</p>
</section>
</section>
<section id="sec-LGDSTM" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="sec-LGDSTM"><span class="header-section-number">5.2</span> Latent Linear Gaussian DSTMs</h2>
<p>For illustration, we consider in this section the simplest (yet, most widely used) DSTM – where the process models in <a href="#eq-YMarkov1general" class="quarto-xref">Equation&nbsp;<span>5.2</span></a> are assumed to have additive Gaussian error distributions, and the evolution operator <span class="math inline">\({\cal M}\)</span> in <a href="#eq-Yprocess" class="quarto-xref">Equation&nbsp;<span>5.4</span></a> is assumed to be linear. Let us suppose that we are interested in a latent process <span class="math inline">\(\{Y_t(\mathbf{s}_i)\}\)</span> at a set of locations given by <span class="math inline">\(\{\mathbf{s}_i: i=1,\ldots,n\}\)</span>, and that we have data at locations <span class="math inline">\(\{\mathbf{r}_{j}: j=1,\ldots,m_t; \ t=0,1,\ldots,T\}\)</span> (i.e., there could be a different number of data locations for each observation time, but we assume there is a finite set of <span class="math inline">\(m\)</span> possible data locations to be considered; so <span class="math inline">\(m_t \leq m\)</span>).</p>
<p>For simplicity, unless noted otherwise, we assume that the “locations” of interest can have either point or areal support (and, possibly different supports for the prediction locations and data locations).</p>
<section id="sec-DataLGDSTM" class="level3" data-number="5.2.1">
<h3 data-number="5.2.1" class="anchored" data-anchor-id="sec-DataLGDSTM"><span class="header-section-number">5.2.1</span> Linear Data Model with Additive Gaussian Error</h3>
<p>Consider the <span class="math inline">\(m_t\)</span>-dimensional data vector, <span class="math inline">\(\mathbf{Z}_t \equiv (Z_t(\mathbf{r}_{1}),\ldots,Z_t(\mathbf{r}_{m_t}))'\)</span>, and the <span class="math inline">\(n\)</span>-dimensional latent-process vector, <span class="math inline">\(\mathbf{Y}_t \equiv (Y_t(\mathbf{s}_1),\ldots,Y_t(\mathbf{s}_n))'\)</span>, that we wish to infer. For the <span class="math inline">\(j\)</span>th observation at time <span class="math inline">\(t\)</span>, the linear data model with additive Gaussian error is written as</p>
<p><span id="eq-Zscalar"><span class="math display">\[
Z_t(\mathbf{r}_{j}) = b_t(\mathbf{r}_{j}) + \sum_{i=1}^n h_{t,ji} Y_t(\mathbf{s}_i) + \epsilon_t(\mathbf{r}_{j}),
\tag{5.5}\]</span></span></p>
<p>for <span class="math inline">\(t=1,\ldots,T\)</span>, where <span class="math inline">\(b_t(\mathbf{r}_{j})\)</span> is an additive offset term for the <span class="math inline">\(j\)</span>th observation at time <span class="math inline">\(t\)</span>, <span class="math inline">\(\{h_{t,ji}\}_{i=1}^n \equiv \mathbf{h}_{t,j}'\)</span> are coefficients that map the latent process to the <span class="math inline">\(j\)</span>th observation at time <span class="math inline">\(t\)</span>, and the error term <span class="math inline">\(\epsilon_t(\cdot)\)</span> is independent of <span class="math inline">\(Y_t(\cdot)\)</span>. Since <span class="math inline">\(j=1,\ldots,m_t\)</span>, the data model can be written in vector–matrix form as</p>
<p><span id="eq-ZlinearGau"><span class="math display">\[
\mathbf{Z}_t = \mathbf{b}_t + \mathbf{H}_t \mathbf{Y}_t + \boldsymbol{\varepsilon}_t, \quad \boldsymbol{\varepsilon}_t \sim \; Gau(\mathbf{0},\mathbf{C}_{\epsilon,t}),
\tag{5.6}\]</span></span></p>
<p>where <span class="math inline">\(\mathbf{b}_t\)</span> is the <span class="math inline">\(m_t\)</span>-dimensional offset term, <span class="math inline">\(\mathbf{H}_t\)</span> is the <span class="math inline">\(m_t \times n\)</span> mapping matrix (note that <span class="math inline">\(\mathbf{h}'_{t,j}\)</span> corresponds to the <span class="math inline">\(j\)</span>th row of <span class="math inline">\(\mathbf{H}_t\)</span>), and <span class="math inline">\(\mathbf{C}_{\epsilon,t}\)</span> is an <span class="math inline">\(m_t \times m_t\)</span> error covariance matrix, typically taken to be diagonal. Each of the data-model components is described briefly below.</p>
<section id="latent-spatio-temporal-dynamic-process" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="latent-spatio-temporal-dynamic-process">Latent Spatio-Temporal Dynamic Process</h4>
<p>The latent dynamic spatio-temporal process is represented by <span class="math inline">\(\mathbf{Y}_t\)</span>. This is where most of the modeling effort is focused in the latent linear DSTM framework. It is convenient in many situations to assume that <span class="math inline">\(\mathbf{Y}_t\)</span> has mean zero; however, we present an alternative perspective in <a href="#sec-ProcParamRed" class="quarto-xref"><span>Section 5.3</span></a> below. As mentioned previously, we shall focus on first-order Markov models to describe the evolution of <span class="math inline">\(\mathbf{Y}_t\)</span>.</p>
</section>
<section id="additive-offset-term" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="additive-offset-term">Additive Offset Term</h4>
<p>There are instances where there are potential biases between the observations and the process of interest, or where one would like to be able to model <span class="math inline">\(\{Y_t(\cdot)\}\)</span> as a mean-zero process. That is, the additive offset term, <span class="math inline">\(\mathbf{b}_t\)</span>, accounts for non-dynamic spatio-temporal structure in the data vector, <span class="math inline">\(\mathbf{Z}_t\)</span>, that allows us to consider <span class="math inline">\(\mathbf{Y}_t\)</span> to have mean zero. One might still be interested scientifically in predicting the sum <span class="math inline">\(\mathbf{b}_t + \mathbf{H}_t \mathbf{Y}_t\)</span> in <a href="#eq-ZlinearGau" class="quarto-xref">Equation&nbsp;<span>5.6</span></a>. We may assume that the additive offset term <span class="math inline">\(b_t(\mathbf{r}_{j})\)</span> is fixed through time, space, or constant across space and time (e.g., <span class="math inline">\(b_t(\mathbf{r}_{j}) \equiv b(\mathbf{r}_{j})\)</span>, <span class="math inline">\(b_t(\mathbf{r}_{j}) \equiv b_t\)</span>, or <span class="math inline">\(b_t(\mathbf{r}_{j}) \equiv b\)</span>, respectively), or we may define it in terms of covariates (e.g., <span class="math inline">\(b_t(\mathbf{r}_{j}) \equiv \mathbf{x}'_{t,j} \boldsymbol{\beta}\)</span>, or <span class="math inline">\(b_t(\mathbf{r}_{j}) \equiv \mathbf{x}'_{t} \boldsymbol{\beta}_j\)</span>, where <span class="math inline">\(\mathbf{x}_{t,j}\)</span> and <span class="math inline">\(\mathbf{x}_{t}\)</span> are <span class="math inline">\(q\)</span>-dimensional vectors of covariates and <span class="math inline">\(\boldsymbol{\beta}\)</span> and <span class="math inline">\(\boldsymbol{\beta}_j\)</span> are <span class="math inline">\(q\)</span>-dimensional parameter vectors). Alternatively, we may consider the offset parameters to be either spatial or temporal random processes with distributions assigned at the next level of the model hierarchy (e.g., <span class="math inline">\(\mathbf{b}_t \sim \; Gau(\mathbf{X}_t \boldsymbol{\beta},\mathbf{C}_b)\)</span>, where <span class="math inline">\(\mathbf{C}_b\)</span> is a positive-definite matrix constructed using the methods described in Chapter 4).</p>
</section>
<section id="observation-mapping-function-or-matrix" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="observation-mapping-function-or-matrix">Observation Mapping Function (or Matrix)</h4>
<p>The observation mapping matrix <span class="math inline">\(\mathbf{H}_t\)</span> has elements <span class="math inline">\(\{h_{t,ji}\}\)</span> that are typically assumed known. They can be any linear basis that relates the process at the prediction locations to the observations. For example, it is often quite useful to let <span class="math inline">\(\mathbf{h}_{t,j}\)</span> correspond to a simple incidence vector (i.e., a vector of ones and zeros), so that each data location is associated with one or more of the process locations. The incidence vector can easily accommodate missing data or can serve as an “interpolator” such that each observation is related to some weighted combination of the process values.</p>
<p>In this simple illustration, consider the single observation in <a href="#eq-Zscalar" class="quarto-xref">Equation&nbsp;<span>5.5</span></a> where <span class="math inline">\(n = 3\)</span>. If <span class="math inline">\(\mathbf{h}_{t,j}' = (0,0,1)\)</span>, it indicates that the observation <span class="math inline">\(Z_t(\mathbf{r}_{j})\)</span> corresponds to the process value, <span class="math inline">\(Y_t(\mathbf{s}_3)\)</span>, at time <span class="math inline">\(t\)</span>. This is especially useful if the locations of the prediction grid are very close to (or a subset of) the observation locations and consequently are considered coincident. If <span class="math inline">\(\mathbf{h}_{t,j}' = (0.1,0.4,0)\)</span>, then the observation at location <span class="math inline">\(\mathbf{r}_{j}\)</span> corresponds to a weighted sum of the process at locations <span class="math inline">\(\mathbf{s}_1\)</span> and <span class="math inline">\(\mathbf{s}_2\)</span>, with more weight being given to location <span class="math inline">\(\mathbf{s}_2\)</span>. More generally, these weights can provide a simple way to deal with different spatial supports and orientations of the observations and the process. For example, the weights can correspond to the area of overlap between observation supports and process supports <span class="citation" data-cites="cressie2011statistics">(see Chapter 7 of <a href="references.html#ref-cressie2011statistics" role="doc-biblioref">Cressie &amp; Wikle, 2011</a> for details)</span>.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Recall from <a href="Chapter2.html#sec-STdatainR" class="quarto-xref"><span>Section 2.2</span></a> that finding the intersections (areas or points of overlap) across spatial or spatio-temporal polygons, points, and grids can be done in a straightforward manner using the function <code>over</code> from the packages <strong>sp</strong> and <strong>spacetime</strong>. This function can hence be used to construct the mapping matrices <span class="math inline">\(\{\mathbf{H}_t\}\)</span> in <a href="#eq-ZlinearGau" class="quarto-xref">Equation&nbsp;<span>5.6</span></a>.</p>
</div>
</div>
<p>Finally, in the situation where the observation locations are a subset of the process locations and <span class="math inline">\(m_t &lt; n\)</span>, one has missing data, and this is easily accommodated via the mapping matrix. For example, if <span class="math inline">\(m_t = 2\)</span> and <span class="math inline">\(n=3\)</span>, then <span class="math inline">\(\mathbf{Z}_t \equiv (Z_t(\mathbf{r}_{t}), Z_t(\mathbf{r}_{t}))'\)</span>, <span class="math inline">\(\mathbf{Y}_t \equiv (Y_t(\mathbf{s}_1), Y_t(\mathbf{s}_2), Y_t(\mathbf{s}_3))'\)</span>, and <span class="math inline">\(\boldsymbol{\varepsilon}_t \equiv (\epsilon_t(\mathbf{r}_{t}), \epsilon_t(\mathbf{r}_{t}))'\)</span>. If <span class="math inline">\(\mathbf{r}_{t} = \mathbf{s}_2\)</span> and <span class="math inline">\(\mathbf{r}_{t} = \mathbf{s}_3\)</span>, the mapping matrix in <a href="#eq-ZlinearGau" class="quarto-xref">Equation&nbsp;<span>5.6</span></a> is given by the incidence matrix</p>
<p><span id="eq-Ht"><span class="math display">\[
\mathbf{H}_t = \left( \begin{array}{ccc}
0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 1 \end{array}\right),
\tag{5.7}\]</span></span></p>
<p>which indicates that observation <span class="math inline">\(Z_t(\mathbf{r}_{1})\)</span> corresponds to process value <span class="math inline">\(Y_t(\mathbf{s}_2)\)</span>, observation <span class="math inline">\(Z_t(\mathbf{r}_{2})\)</span> corresponds to process value <span class="math inline">\(Y_t(\mathbf{s}_3)\)</span>, and process value <span class="math inline">\(Y_t(\mathbf{s}_1)\)</span> does not have a corresponding observation at time <span class="math inline">\(t\)</span>. This way to accommodate missing information is very useful for HMs, because it allows one to focus the modeling effort on the latent process <span class="math inline">\(\{Y_t(\cdot)\}\)</span>, and the process is oblivious to which data are missing. Some would argue that a downside of this is the need to pre-specify the locations at which one is interested in modeling the process, but, with a sufficiently fine grid, this could effectively be everywhere in the spatial domain, <span class="math inline">\(D_s\)</span>.</p>
<p>Although it is possible in principle to parameterize the mapping matrix and/or estimate it directly in some cases, we shall typically assume that it is known. Otherwise, one would have to be careful when specifying and estimating the process-model parameters to mitigate identifiability problems.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Recall from <a href="Chapter4.html#sec-Randeffects_STbasis" class="quarto-xref"><span>Section 4.4.1</span></a> that matrices such as that given in <a href="#eq-Ht" class="quarto-xref">Equation&nbsp;<span>5.7</span></a> tend to have many zeros and hence are <em>sparse</em>. Two <code>R</code> packages that cater to sparse matrices are <strong>Matrix</strong> and <strong>spam</strong>. Sparse matrices are stored and operated on differently than the standard dense <code>R</code> matrices, and they have favorable memory and computational properties. However, sparse matrix objects should only be used when the number of non-zero entries is small, generally on the order of 5% or less of the total number of matrix elements.</p>
</div>
</div>
</section>
<section id="error-covariance-matrix" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="error-covariance-matrix">Error Covariance Matrix</h4>
<p>In the linear Gaussian DSTM, the additive error process <span class="math inline">\(\{\epsilon_t(\mathbf{r}_{j})\}\)</span> is assumed to have mean zero, is Gaussian, and can generally include dependence in space or time (although we will typically assume that the errors are independent in time, as is customary). So, when considering <span class="math inline">\(\epsilon_t(\cdot)\)</span> at a finite set of <span class="math inline">\(m_t\)</span> observation locations, namely <span class="math inline">\(\boldsymbol{\varepsilon}_t \equiv (\epsilon_t(\mathbf{r}_{1}), \ldots, \epsilon_t(\mathbf{r}_{m_t}))'\)</span>, we need to specify time-varying covariance matrices <span class="math inline">\(\{\mathbf{C}_{\epsilon,t}\}\)</span>. In practice, given that most of the interesting dependence structure in the observations is contained in the process, and recalling that in the data model we are conditioning on that process, the structure of <span class="math inline">\(\mathbf{C}_{\epsilon,t}\)</span> should be pretty simple. Indeed, there is often an assumption that these data-model errors are independent with constant (in time and space) variance, so that <span class="math inline">\(\mathbf{C}_{\epsilon,t} = \sigma^2_\epsilon \mathbf{I}_{m_t}\)</span>, where <span class="math inline">\(\sigma^2_\epsilon\)</span> represents the measurement-error variance. If this assumption is not reasonable, then in situations where the data-model error covariance matrix is assumed constant over time (e.g., <span class="math inline">\(\mathbf{C}_{\epsilon,t} = \mathbf{C}_{\epsilon}\)</span>) and <span class="math inline">\(m_t = m\)</span>, one might estimate the <span class="math inline">\(m \times m\)</span> covariance matrix <span class="math inline">\(\mathbf{C}_{\epsilon}\)</span> directly if <span class="math inline">\(m\)</span> is not too large (see <a href="ChapterAppendixC.html#sec-estimationLDSTM" class="quarto-xref"><span>Section C.2</span></a>), or one might parameterize <span class="math inline">\(\mathbf{C}_{\epsilon}\)</span>. For example, in the case where the data-model error variances are heteroskedastic in space, one might model <span class="math inline">\(\mathbf{C}_{\epsilon} = \textrm{diag}(\mathbf{v}_{\epsilon})\)</span>, and estimate the elements of <span class="math inline">\(\mathbf{v}_{\epsilon}\)</span>. Alternatively, if there is spatial dependence one might parameterize <span class="math inline">\(\mathbf{C}_{\epsilon}\)</span> in terms of some valid spatial covariance functions (e.g., the Matérn class). The specific choice is very problem-dependent. It is important to recall the central principle of hierarchical modeling discussed in Chapter 1, in <a href="Chapter3.html#sec-HSTmods" class="quarto-xref"><span>Section 3.5</span></a>, and in greater detail in <a href="Chapter4.html#sec-randomeffects" class="quarto-xref"><span>Section 4.3</span></a>, which is that we attempt to place as much of the dependence structure as possible in the conditional mean, which simplifies the conditional-covariance specification dramatically.</p>
</section>
</section>
<section id="sec-NonGauDataMod" class="level3" data-number="5.2.2">
<h3 data-number="5.2.2" class="anchored" data-anchor-id="sec-NonGauDataMod"><span class="header-section-number">5.2.2</span> Non-Gaussian and Nonlinear Data Model</h3>
<p>Recall the general data model from <a href="Chapter4.html#sec-nonGaussian" class="quarto-xref"><span>Section 4.5</span></a>, rewritten here to correspond to the discrete-time case. For <span class="math inline">\(t=1,2,\ldots,\)</span> let</p>
<p><span class="math display">\[
Z_t(\mathbf{s}) | Y_t(\mathbf{s}), \gamma \; \sim \; EF(Y_t(\mathbf{s}), \gamma),
\]</span></p>
<p>where <span class="math inline">\(EF\)</span> corresponds to a distribution from the with scale parameter <span class="math inline">\(\gamma\)</span> and mean <span class="math inline">\(Y_t(\mathbf{s})\)</span>. Now, consider a transformation of the mean response <span class="math inline">\(g(Y_t(\mathbf{s})) \equiv \tilde{Y}_t(\mathbf{s})\)</span> using a specified monotonic link function <span class="math inline">\(g(\cdot)\)</span>. Using a standard GLMM framework, we can model the transformed process <span class="math inline">\(\tilde{Y}_t(\mathbf{s})\)</span> as a latent Gaussian DSTM (<a href="#sec-LinGaussProcess" class="quarto-xref"><span>Section 5.2.3</span></a>) with or without the use of process/parameter reduction methods (<a href="#sec-ProcParamRed" class="quarto-xref"><span>Section 5.3</span></a>). Note that we can also include a “mapping matrix” to this non-Gaussian data model as we did with the Gaussian data model in <a href="#sec-DataLGDSTM" class="quarto-xref"><span>Section 5.2.1</span></a>. That is, in a matrix formulation we could consider</p>
<p><span class="math display">\[
\mathbf{Z}_t | \mathbf{Y}_t, \gamma \; \sim \; EF(\mathbf{H}_t \mathbf{Y}_t, \gamma),
\]</span></p>
<p>where the distribution <span class="math inline">\(EF\)</span> is taken elementwise, and <span class="math inline">\(\mathbf{H}_t\)</span> is an incidence matrix or change-of-support matrix as described in <a href="#sec-DataLGDSTM" class="quarto-xref"><span>Section 5.2.1</span></a>.</p>
<p>It is sometimes useful to consider a nonlinear transformation of the latent process <span class="math inline">\(\{Y_t(\cdot)\}\)</span> in a data model even if the error term is Gaussian. For example, analogous to equation (7.39) in <span class="citation" data-cites="cressie2011statistics">Cressie &amp; Wikle (<a href="references.html#ref-cressie2011statistics" role="doc-biblioref">2011</a>)</span>, one can modify <a href="#eq-ZlinearGau" class="quarto-xref">Equation&nbsp;<span>5.6</span></a> above to accommodate a transformation of the elements of the process vector:</p>
<p><span id="eq-ZlinearGau_trans"><span class="math display">\[
\mathbf{Z}_t = \mathbf{b}_t + \mathbf{H}_t \mathbf{Y}_t^{a} + \boldsymbol{\varepsilon}_t, \quad \boldsymbol{\varepsilon}_t \sim \; Gau(\mathbf{0},\mathbf{C}_{\epsilon,t}),
\tag{5.8}\]</span></span></p>
<p>where the coefficient <span class="math inline">\(\{-\infty &lt; a &lt; \infty\}\)</span> corresponds to a (applied to each element of <span class="math inline">\(\mathbf{Y}_t\)</span>), which is one of the simplest ways to accommodate nonlinear or non-Gaussian processes in the data model. In general, <span class="math inline">\(\{\mathbf{Y}_t^a\}\)</span> may not generate a linear Gaussian model, but the additivity of the errors <span class="math inline">\(\{\boldsymbol{\varepsilon}_t\}\)</span> is an important part of <a href="#eq-ZlinearGau_trans" class="quarto-xref">Equation&nbsp;<span>5.8</span></a>. As an example, if <span class="math inline">\(\{Y_t(\cdot)\}\)</span> is positive valued, then this is analogous to the famed Box–Cox transformation. In some applications it is reasonable to assume that the transformation power <span class="math inline">\(a\)</span> in <a href="#eq-ZlinearGau_trans" class="quarto-xref">Equation&nbsp;<span>5.8</span></a> may vary with space or time, and may depend on covariates.</p>
<p>As with non-dynamic spatio-temporal models with non-Gaussian errors (Chapter 4), computation for estimation and prediction is more problematic when one considers non-Gaussian or nonlinear data models.</p>
</section>
<section id="sec-LinGaussProcess" class="level3" data-number="5.2.3">
<h3 data-number="5.2.3" class="anchored" data-anchor-id="sec-LinGaussProcess"><span class="header-section-number">5.2.3</span> Process Model</h3>
<p>Linear Markovian spatio-temporal process models generally assume that the value of the process at a given location at the present time is made up of a weighted combination (or is a “smoothed version”) of the process throughout the spatial domain at previous times, plus an additive, Gaussian, spatially coherent “innovation” (see the schematic in <a href="#fig-DSTMcartoon" class="quarto-xref">Figure&nbsp;<span>5.1</span></a>). This is perhaps best represented in a continuous-spatial context through an <em>integro-difference equation</em> (IDE). Specifically, a first-order spatio-temporal IDE process model is given by</p>
<p><span id="eq-linearIDE"><span class="math display">\[
Y_t(\mathbf{s}) = \int_{D_s} m(\mathbf{s},\mathbf{x};\boldsymbol{\theta}_p) Y_{t-1}(\mathbf{x}) \, \textrm{d}\mathbf{x}+ \eta_t(\mathbf{s}), \quad \mathbf{s},\mathbf{x}\in D_s,
\tag{5.9}\]</span></span></p>
<p>for <span class="math inline">\(t=1,2,\ldots,\)</span> where <span class="math inline">\(m(\mathbf{s},\mathbf{x};\boldsymbol{\theta}_p)\)</span> is a <em>transition kernel</em>, depending on parameters <span class="math inline">\(\boldsymbol{\theta}_p\)</span> that specify “redistribution weights” for the process at the previous time over the spatial domain, <span class="math inline">\(D_s\)</span>, and <span class="math inline">\(\eta_t(\cdot)\)</span> is a time-varying (but statistically independent in time) continuous mean-zero Gaussian spatial process independent of <span class="math inline">\(Y_{t-1}(\cdot)\)</span>. Generally, one of the parameters of <span class="math inline">\(\boldsymbol{\theta}_p\)</span> is just a multiplicative scalar that controls the temporal stability; see <a href="#eq-linearIDEm_kernel" class="quarto-xref">Equation&nbsp;<span>5.23</span></a> in Lab 5.2. Note that we assume here, as one often does, that the parameter vector <span class="math inline">\(\boldsymbol{\theta}_p\)</span> does not vary with time, but it could do so in general. So, from <a href="#eq-linearIDE" class="quarto-xref">Equation&nbsp;<span>5.9</span></a>, the process at location <span class="math inline">\(\mathbf{s}\)</span> and time <span class="math inline">\(t\)</span> is given by the weighted average (integral) of the process throughout the domain at the past time, where the weights are given by the transition kernel, <span class="math inline">\(m(\cdot,\cdot)\)</span>. The innovation given by <span class="math inline">\(\eta_t(\cdot)\)</span>, which is independent of <span class="math inline">\(Y_{t-1}(\cdot)\)</span>, has spatial dependence, is typically Gaussian, and accounts for spatial dependencies in <span class="math inline">\(Y_t(\cdot)\)</span> that are not captured by this weighted average. Another way to think about <span class="math inline">\(\eta_t(\cdot)\)</span> is that it adds back smaller-scale dependence that is removed in the inherent smoothing that occurs when <span class="math inline">\(\{Y_{t-1}(\cdot)\}\)</span> is averaged over space. In general, <span class="math inline">\(\int_{D_s} m(\mathbf{s},\mathbf{x};\boldsymbol{\theta}_p) \,\textrm{d}\mathbf{x}&lt; 1\)</span> is needed for the process to be stable (non-explosive) in time. Note that the model in <a href="#eq-linearIDE" class="quarto-xref">Equation&nbsp;<span>5.9</span></a> implicitly assumes that the process <span class="math inline">\(Y_t(\cdot)\)</span> has mean zero. In some cases it may be appropriate to model a non-zero mean directly in the process, as is shown generally in <a href="#eq-Ydecomp" class="quarto-xref">Equation&nbsp;<span>5.16</span></a> below and specifically for the IDE in Lab 5.2.</p>
<div id="fig-DSTMcartoon" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-DSTMcartoon-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_5/Dyn_cartoon_new.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-DSTMcartoon-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.1: Cartoon illustration of a linear DSTM. The process at spatial location <span class="math inline">\(\mathbf{s}\)</span> and time <span class="math inline">\(t\)</span>, <span class="math inline">\(Y_t(\mathbf{s})\)</span>, is constructed from a linear combination of the process values at the previous time, <span class="math inline">\(Y_{t-1}(\cdot)\)</span>, plus an “instantaneous” random spatial error process, <span class="math inline">\(\eta_t(\cdot)\)</span>. The thick arrows indicate the passage from past to present to future.
</figcaption>
</figure>
</div>
<p>In the case where one has a finite set of prediction spatial locations (or regions) <span class="math inline">\(D_s = \{\mathbf{s}_1,\mathbf{s}_2,\ldots,\mathbf{s}_n\}\)</span> of interest (e.g., an irregular lattice or a regular grid), the first-order IDE evolution process model <a href="#eq-linearIDE" class="quarto-xref">Equation&nbsp;<span>5.9</span></a> can be discretized and written as a stochastic difference equation,</p>
<p><span id="eq-linearDSTMdiff"><span class="math display">\[
Y_t(\mathbf{s}_i) = \sum_{j=1}^n m_{ij}(\boldsymbol{\theta}_p) \;Y_{t-1}(\mathbf{s}_j) + \eta_t(\mathbf{s}_i),
\tag{5.10}\]</span></span></p>
<p>for <span class="math inline">\(t=1,2,\ldots,\)</span> with transition (redistribution) weights <span class="math inline">\(m_{ij}(\boldsymbol{\theta}_p)\)</span> that depend on parameters <span class="math inline">\(\boldsymbol{\theta}_p\)</span>. In this case, the process at <span class="math inline">\(Y_t(\mathbf{s}_i)\)</span> considers a weighted combination of the values of the process at time <span class="math inline">\(t-1\)</span> and at a discrete set of spatial locations.</p>
<p>Now, denoting the process vector <span class="math inline">\(\mathbf{Y}_t \equiv (Y_t(\mathbf{s}_1),\ldots,Y_t(\mathbf{s}_n))'\)</span>, <a href="#eq-linearDSTMdiff" class="quarto-xref">Equation&nbsp;<span>5.10</span></a> can be written in vector–matrix form as a linear first-order vector autoregression DSTM,</p>
<p><span id="eq-linearDSTMVAR"><span class="math display">\[
\mathbf{Y}_t = \mathbf{M}\mathbf{Y}_{t-1} + \boldsymbol{\eta}_t,
\tag{5.11}\]</span></span></p>
<p>where the <span class="math inline">\(n \times n\)</span> transition matrix is given by <span class="math inline">\(\mathbf{M}\)</span> with elements <span class="math inline">\(\{m_{ij}\}\)</span>, and the additive spatial error process <span class="math inline">\(\boldsymbol{\eta}_t \equiv (\eta_t(\mathbf{s}_1),\ldots,\eta_t(\mathbf{s}_n))'\)</span> is independent of <span class="math inline">\(\mathbf{Y}_{t-1}\)</span> and is specified to be mean-zero and Gaussian with spatial covariance matrix <span class="math inline">\(\mathbf{C}_{\eta}\)</span>. The stability (non-explosive) condition in this case requires that the maximum modulus of the eigenvalues of <span class="math inline">\(\mathbf{M}\)</span> (which may be complex-valued) be less than 1 (see <a href="#nte-technote-MatrixDecomp" class="quarto-xref">Note&nbsp;<span>5.1</span></a>).</p>
<p>We have assumed in our discussion of the process model that the <span class="math inline">\(\{Y_t(\mathbf{s}_i)\}\)</span> have mean zero. Although it is possible to include an offset term in the Markovian process model at this stage, in this section we consider such an offset only in the data model as described above for <a href="#eq-ZlinearGau" class="quarto-xref">Equation&nbsp;<span>5.6</span></a>. However, as we discuss below in <a href="#sec-ProcParamRed" class="quarto-xref"><span>Section 5.3</span></a>, it is reasonable to consider the offset as part of this “process” decomposition, typically including covariate effects and/or seasonality.</p>
<p>Usually, <span class="math inline">\(\mathbf{M}\)</span> and <span class="math inline">\(\mathbf{C}_{\eta}\)</span> are assumed to depend on parameters <span class="math inline">\(\boldsymbol{\theta}_p\)</span> and <span class="math inline">\(\boldsymbol{\theta}_\eta\)</span>, respectively, to mitigate the curse of dimensionality (here, the exponential increase in the number of parameters) that often occurs in spatio-temporal modeling. As discussed below in <a href="#sec-ProcParamRed" class="quarto-xref"><span>Section 5.3</span></a>, the parameterization of these matrices (particularly <span class="math inline">\(\mathbf{M}\)</span>) is one of the greatest challenges in DSTMs, and it is facilitated by using parameter models in a BHM. However, in relatively simple applications of fairly low dimensionality and large sample sizes (e.g., when <span class="math inline">\(n\)</span> is small and <span class="math inline">\(T \gg n\)</span>), one can estimate <span class="math inline">\(n \times n\)</span> matrices <span class="math inline">\(\mathbf{M}\)</span> and <span class="math inline">\(\mathbf{C}_{\eta}\)</span> directly in an EHM, as is commonly done in state-space models of time series (see <a href="ChapterAppendixC.html#sec-estimationLDSTM" class="quarto-xref"><span>Section C.2</span></a>).</p>
<div id="nte-technote-MatrixDecomp" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;5.1: Eigenvalues of the Transition Matrix
</div>
</div>
<div class="callout-body-container callout-body">
<p>Consider the first-order vector autoregressive model,</p>
<p><span class="math display">\[
\mathbf{Y}_t = \mathbf{M}\mathbf{Y}_{t-1} + \boldsymbol{\eta}_t,
\]</span></p>
<p>where <span class="math inline">\(\mathbf{Y}_t\)</span> is an <span class="math inline">\(n\)</span>-dimensional vector, and <span class="math inline">\(\mathbf{M}\)</span> is an <span class="math inline">\(n \times n\)</span> real-valued transition matrix. The characteristic equation obtained from the determinant,</p>
<p><span class="math display">\[
\text{det}(\mathbf{M}- \lambda \mathbf{I}) = 0,
\]</span></p>
<p>has <span class="math inline">\(n\)</span> eigenvalues (latent roots), <span class="math inline">\(\{\lambda_i: i=1,\ldots,n\}\)</span>, some of which may be complex numbers. Each eigenvalue has a modulus and is associated with an eigenvector (taken together, an eigenvalue–eigenvector pair is sometimes referred to as an <em>eigenmode</em>) that describes the behavior associated with that eigenvalue. As discussed in Cressie and Wikle (2011, Section 3.2.1), the eigenvalues and eigenvectors can tell us quite a bit about the dynamical properties of the model. First, assume in general that <span class="math inline">\(\lambda_i = a_i + b_i \sqrt{-1}\)</span> (where <span class="math inline">\(b_i = 0\)</span> if <span class="math inline">\(\lambda_i\)</span> is real-valued), and define the complex magnitude (or “modulus”) to be <span class="math inline">\(|\lambda_i| = \sqrt{a_i^2 + b_i^2}\)</span>. We note that if <span class="math inline">\(\text{max}\{|\lambda_i|: i=1,\ldots,n\} \ge 1\)</span>, then the <em>eigenmode</em>, and hence the model, is unstable, and <span class="math inline">\(\mathbf{Y}_t\)</span> will grow without bound as <span class="math inline">\(t\)</span> increases. Conversely, if the maximum modulus of all the eigenvalues is less than 1, then the model is stable. Since <span class="math inline">\(\mathbf{M}\)</span> is real-valued, complex eigenvalues come in complex conjugate pairs, and their <em>eigenmodes</em> are associated with oscillatory behavior in the dynamics (either damped or exponentially growing sinusoids, depending on whether the modulus of the corresponding eigenvalue is less than 1 or greater than or equal to 1, respectively). In contrast, real-valued eigenvalues correspond to non-oscillatory dynamics.</p>
</div>
</div>
<section id="intuition-for-linear-dynamics" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="intuition-for-linear-dynamics">Intuition for Linear Dynamics</h4>
<p>Parameterizations of realistic dynamics should respect the fact that spatio-temporal interactions are crucial for dynamic propagation. For example, in the linear IDE model (<a href="#eq-linearIDE" class="quarto-xref">Equation&nbsp;<span>5.9</span></a>), the <em>asymmetry</em> and <em>rate of decay</em> of the transition kernel <span class="math inline">\(m(\mathbf{s},\mathbf{x};\boldsymbol{\theta}_p)\)</span>, relative to a location (here, <span class="math inline">\(\mathbf{s}\)</span>), control <em>propagation</em> (linear advection) and <em>spread</em> (diffusion), respectively. <a href="#fig-DSTMdynamics" class="quarto-xref">Figure&nbsp;<span>5.2</span></a> shows Hovmöller plots of four one-dimensional (in space) simulations of a spatio-temporal IDE process and their respective transition kernels evaluated at <span class="math inline">\(s_0 = 0.5\)</span>. Panels (a) and (b) show the inherent diffusive nature of the process depending on kernel width; that is, spatially coherent disturbances tend to spread across space (diffuse) at a greater rate when the kernel is wider (i.e., has a larger aperture), which leads to more averaging from one time to the next. However, note that there is no “slanting” in the plot through time, indicating that there is no propagation through time (see <a href="Chapter2.html#sec-Hovplot" class="quarto-xref"><span>Section 2.3.3</span></a> for an interpretation of Hovmöller plots). In contrast, panels (c) and (d) show clear evidence of propagation, to the left when the kernel is offset to the right, and to the right when the kernel is offset to the left. The intuition here is that the offset kernel pulls information from one particular direction, and redistributes it in the opposite direction, leading to propagation. More complex kernels (e.g., multimodal, or spatially varying) can lead to even more complex behavior. As we discuss in <a href="#sec-ProcParamRed" class="quarto-xref"><span>Section 5.3</span></a>, these basic properties of the transition (redistribution) kernel can suggest efficient parameterizations of linear DTSM process models.</p>
<div id="fig-DSTMdynamics" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-DSTMdynamics-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_5/IDEkernels.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-DSTMdynamics-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.2: Transition kernels <span class="math inline">\(m(0.5, x; \boldsymbol{\theta}_p)\)</span> for different <span class="math inline">\(\boldsymbol{\theta}_p\)</span> and associated Hovmöller plots of spatio-temporal IDE process simulation (one-dimensional in space) with <span class="math inline">\(iid\)</span> noise forcing. (a) Relatively narrow symmetric kernel. (b) Wider symmetric kernel. (c) Asymmetric kernel produced by shifting a symmetric kernel to the right. (d) Same as (c), but to the left. Note that the wider the kernel the greater the diffusion, and a shift implies propagation in the direction away from the shift.
</figcaption>
</figure>
</div>
<p>As mentioned above, there are conditions on the transition kernel (or matrix in the discrete-space case) that correspond to unstable (explosive in time) behavior. From a dynamic perspective, a stable process implies that small perturbations to the spatial field will eventually decay to the equilibrium (mean) state. Because many real-world spatio-temporal processes are nonlinear, it can be the case that if one fits an unconstrained <em>linear</em> DSTM to data that come from such a <em>nonlinear</em> process, then the fitted model is unstable (explosive, with exponential “growth”). This is not necessarily a bad thing, as it provides immediate feedback that the wrong model is being fitted or that the finite-time window for the observations suggests a transient period of growth (see <a href="#nte-technote-transgrowth" class="quarto-xref">Note&nbsp;<span>5.2</span></a>). In some cases, it can actually be helpful if the confidence (or credible) intervals of the transition-matrix parameters include the explosive boundary because the mean of the predictive distribution may show growth (a nonlinear feature) since it effectively averages over realizations that are both explosive and non-explosive. Of course, long-lead-time forecasts from such a model are problematic as exponential-growth models are only useful for very short-term predictions unless there is some nonlinear control mechanism (e.g., density-dependent carrying capacities in ecological applications).</p>
<div id="nte-technote-transgrowth" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;5.2: Transient Growth
</div>
</div>
<div class="callout-body-container callout-body">
<p>An interesting and less appreciated aspect of linear DSTMs is the fact that they can be stable yet still accommodate so-called “transient growth.” That is, there are periods in time when the process does have brief excursions from its stable state. Essentially, if the transition operator is “non-normal” (i.e., in the discrete-space case, if <span class="math inline">\(\mathbf{M}\mathbf{M}' \neq \mathbf{M}' \mathbf{M}\)</span>, in which case, the eigenvectors of <span class="math inline">\(\mathbf{M}\)</span> are non-orthogonal), but still stable (e.g., the maximum modulus of the eigenvalues of <span class="math inline">\(\mathbf{M}\)</span> is less than 1; see <a href="#nte-technote-MatrixDecomp" class="quarto-xref">Note&nbsp;<span>5.1</span></a>), then the linear dynamic process can exhibit transient growth. This means that even though each eigenvector of the stable <span class="math inline">\(\mathbf{M}\)</span> is decaying asymptotically in time, there can be local-in-time (transient) periods where there is significant (even orders of magnitude) growth. This is due to the constructive interference of the non-orthogonal eigenvectors of the transition operator, <span class="math inline">\(\mathbf{M}\)</span>. Since almost all real-world linear processes correspond to non-normal transition operators, this has important implications concerning how one might parameterize <span class="math inline">\(\mathbf{M}\)</span>, as discussed in <a href="#sec-ProcParamRed" class="quarto-xref"><span>Section 5.3</span></a> below.</p>
</div>
</div>
</section>
</section>
</section>
<section id="sec-ProcParamRed" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="sec-ProcParamRed"><span class="header-section-number">5.3</span> Process and Parameter Dimension Reduction</h2>
<p>The latent linear Gaussian DSTM described in <a href="#sec-LGDSTM" class="quarto-xref"><span>Section 5.2</span></a> above has unknown parameters associated with the process model <span class="math inline">\(\mathbf{C}_\eta\)</span>, the transition operator <span class="math inline">\(m(\mathbf{s},\mathbf{x};\boldsymbol{\theta}_p)\)</span> or matrix <span class="math inline">\(\mathbf{M}\)</span>, and the initial-condition distribution (e.g., <span class="math inline">\(\boldsymbol{\mu}_0\)</span> and <span class="math inline">\(\mathbf{C}_0\)</span>). With the linear Gaussian data model, one typically considers a fairly simple parameterization of <span class="math inline">\(\mathbf{C}_\epsilon\)</span> (e.g., <span class="math inline">\(\mathbf{C}_\epsilon = \sigma^2_\epsilon \mathbf{I}\)</span>) or perhaps the covariance matrix implied by a simple spatial random process that has just a few parameters (e.g., a Matérn spatial covariance function or a spatial conditional autoregressive process). One of the greatest challenges when considering DSTMs in hierarchical statistical settings is the curse of dimensionality associated with the process-model level of the DSTM. For the fairly common situation where the number of spatial locations (<span class="math inline">\(n\)</span>) is much larger than the number of time replicates (<span class="math inline">\(T\)</span>), even the fairly simple linear DSTM process model <a href="#eq-linearDSTMVAR" class="quarto-xref">Equation&nbsp;<span>5.11</span></a> is problematic, as there are on the order of <span class="math inline">\(n^2\)</span> parameters to estimate. To proceed, one must reduce the number of free parameters to be inferred in the model and/or reduce the dimension of the spatio-temporal dynamic process. These two approaches are discussed briefly below.</p>
<section id="sec-ParmReduc" class="level3" data-number="5.3.1">
<h3 data-number="5.3.1" class="anchored" data-anchor-id="sec-ParmReduc"><span class="header-section-number">5.3.1</span> Parameter Dimension Reduction</h3>
<p>Consider the process-error spatial variance-covariance matrix, <span class="math inline">\(\mathbf{C}_\eta\)</span>. In complex modeling situations, it is seldom the case that one would estimate this as a full positive-definite matrix in the DSTM. Rather, given that these are spatial covariance matrices, we would either use one of the common spatial covariance-function representations or a basis-function random-effects representation (as in Chapter 4 or in <a href="#sec-ProcRed" class="quarto-xref"><span>Section 5.3.2</span></a> below).</p>
<p>Generally, the transition-matrix parameters in the DSTM process model require the most care, as there could be as many as <span class="math inline">\(n^2\)</span> of them and, as discussed above, the linear dynamics of the process are largely controlled by these parameters. In the case of the simple linear DSTM model <a href="#eq-linearDSTMVAR" class="quarto-xref">Equation&nbsp;<span>5.11</span></a>, one could parameterize the transition matrix <span class="math inline">\(\mathbf{M}\)</span> simply as a random walk (i.e., <span class="math inline">\(\mathbf{M}= \mathbf{I}\)</span>), a spatially homogeneous autoregressive process (i.e., <span class="math inline">\(\mathbf{M}= \theta_p \mathbf{I}\)</span>), or a spatially varying autoregressive process (<span class="math inline">\(\mathbf{M}= \mbox{diag}(\boldsymbol{\theta}_p)\)</span>). The first two parameterizations are somewhat unrealistic for most real-world dynamic processes and are not recommended, but the last parameterization is more useful for real-world processes.</p>
<p>As an example of the last parameterization described above, consider the process model where <span class="math inline">\(\mathbf{C}_\eta = \sigma_\eta^2 \mathbf{I}\)</span>, and <span class="math inline">\(\mathbf{M}= \mbox{diag}(\boldsymbol{\theta}_p)\)</span>. We can decompose the first-order conditional distributions in this case as</p>
<p><span class="math display">\[
[\mathbf{Y}_t | \mathbf{Y}_{t-1}, \boldsymbol{\theta}_p, \sigma^2_\eta] = \prod_{i=1}^n [Y_t(\mathbf{s}_i) | Y_{t-1}(\mathbf{s}_i), \theta_{p}(i), \sigma^2_\eta],\quad t=1,2,\ldots.
\]</span></p>
<p>Thus, conditional on the parameters <span class="math inline">\(\boldsymbol{\theta}_p = (\theta_p(1),\ldots,\theta_p(n))'\)</span>, we have spatially independent univariate AR(1) processes at each spatial location (i.e., only the <span class="math inline">\(Y\)</span>-value at the previous time at the same spatial location influences the transition). However, if <span class="math inline">\(\boldsymbol{\theta}_p\)</span> is <em>random</em> and has spatial dependence, then if we integrate it out, the marginal conditional distribution, <span class="math inline">\([\mathbf{Y}_t | \mathbf{Y}_{t-1}, \sigma^2_\eta]\)</span>, can imply that all of the elements of <span class="math inline">\(\mathbf{Y}_{t-1}\)</span> influence the transition to time <span class="math inline">\(t\)</span> at all spatial locations (i.e., this is a spatio-temporal process). Recall from <a href="Chapter4.html#sec-randomeffects" class="quarto-xref"><span>Section 4.3</span></a> that this building of dependence through marginalization is a fundamental principle of deep hierarchical modeling, and it provides a simple and often effective way to construct complex spatio-temporal models (see also <a href="Chapter4.html#nte-technote-MargCond" class="quarto-xref">Note&nbsp;<span>4.3</span></a>). But, although we can accommodate fairly complex spatio-temporal dependence in this marginalization, it is important to note that the conditional model does not account <em>directly</em> for interactions across space and time. This limits its utility in applications, where more realistic conditional dynamic specifications are required. Thus, we often seek parameterizations that directly include such interactions in the conditional model.</p>
<p>Recall from our discussion of the intuition behind linear dynamics in <a href="#sec-LinGaussProcess" class="quarto-xref"><span>Section 5.2.3</span></a> that the transition kernel is very important. This suggests that we can model realistic linear behavior by parameterizing the kernel shape (particularly its decay in the spatial domain and its asymmetry) in terms of a relatively small number of parameters (e.g., in the transition kernel case, the kernel width, or variance, and shift, or mean, parameters). More importantly, if we allow these relatively few parameters to vary with space in a principled fashion, then we can accommodate a variety of quite complex dynamic behaviors. The strength of the HM approach is that one can fairly easily do this by endowing these kernel parameters with spatial structure at the parameter-model level of the hierarchy (e.g., allowing them to be a function of covariates and/or specifying them as spatial random processes).</p>
<p>As an example, consider the IDE process model given in <a href="#eq-linearIDE" class="quarto-xref">Equation&nbsp;<span>5.9</span></a>, where we specify a Gaussian-shape transition kernel as a function of <span class="math inline">\(x\)</span> relative to the location <span class="math inline">\(s\)</span> (for simplicity, in a one-dimensional spatial domain):</p>
<p><span id="eq-Gausskern"><span class="math display">\[
m(s,x;\boldsymbol{\theta}_p) = {\theta_{p,1}} \exp\left(-\frac{1}{\theta_{p,2}}(x - \theta_{p,3} - s)^2 \right) ,
\tag{5.12}\]</span></span></p>
<p>where the kernel amplitude is given by <span class="math inline">\(\theta_{p,1}\)</span>, the length-scale (variance) parameter <span class="math inline">\(\theta_{p,2}\)</span> corresponds to a kernel scale (aperture) parameter (i.e., the kernel width increases as <span class="math inline">\(\theta_{p,2}\)</span> increases), and the mean (shift) parameter <span class="math inline">\(\theta_{p,3}\)</span> corresponds to a shift of the kernel relative to location <span class="math inline">\(s\)</span>. Notice that <a href="#eq-Gausskern" class="quarto-xref">Equation&nbsp;<span>5.12</span></a> is positive but need not integrate to 1 over <span class="math inline">\(x\)</span>. Recall from <a href="#fig-DSTMdynamics" class="quarto-xref">Figure&nbsp;<span>5.2</span></a> the dynamical implication of changing the shift parameter. Specifically, if <span class="math inline">\(\theta_{p,3}\)</span> is positive (negative) it leads to leftward (rightward) movement because it induces asymmetry relative to location <span class="math inline">\(s\)</span>. In addition, <a href="#fig-DSTMdynamics" class="quarto-xref">Figure&nbsp;<span>5.2</span></a> shows the dynamic implications when changing the kernel width/scale (e.g., wider kernels suggest faster decay). So, to obtain more complex dynamical behavior, we can allow these parameters to change with space. For example, suppose the mean (shift) parameter satisfies <span class="math inline">\(\theta_{p,3}(s) = \mathbf{x}(s)' \boldsymbol{\beta}+ \omega(s)\)</span>, where <span class="math inline">\(\mathbf{x}(s)\)</span> corresponds to covariates at spatial location <span class="math inline">\(s\)</span>, <span class="math inline">\(\boldsymbol{\beta}\)</span> are the associated regression parameters, and <span class="math inline">\(\omega(s)\)</span> could correspond to a spatial (although, in some cases, it may be sufficient to omit the error term <span class="math inline">\(\omega(s)\)</span>; see Lab 5.2 for an example). We can also allow the parameter <span class="math inline">\(\theta_{p,2}\)</span> to vary with space, but it is typically the case that <span class="math inline">\(\theta_{p,3}\)</span> is the more important of the two parameters. <a href="#fig-spat_kernel" class="quarto-xref">Figure&nbsp;<span>5.3</span></a> shows an example of a spatially varying kernel in two dimensions, and the kernel evaluated at one specific spatial location. Lab 5.1 implements the simple one-dimensional IDE process model and explores its simulation. Lab 5.2 shows how one can do spatio-temporal modeling and inference in <span class="math inline">\(\texttt{R}\)</span> using the package <strong>IDE</strong>.</p>
<div id="fig-spat_kernel" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-spat_kernel-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_5/spat_kernel.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spat_kernel-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.3: An example of a spatially varying kernel in an IDE spatio-temporal model. The left panel shows the direction (arrow orientation and color) and magnitude (arrow length) of flow induced by the kernel as a function of <span class="math inline">\(\mathbf{x}= (x_1,x_2)'\)</span> in two-dimensional space. The red cross indicates a specific location in space <span class="math inline">\((s_1^o, s_2^o)\)</span> around which the kernel is evaluated and plotted in the right panel. Note that the kernel, which is shifted to the right, induces a flow to the left.
</figcaption>
</figure>
</div>
<p>Although the IDE kernel representation suggests efficient parameterizations for linear dynamics in continuous space, there are many occasions where we seek efficient parameterizations in a discrete-space setting or in the context of random effects in basis-function expansions. In the case of the former, one of the most useful such parameterizations corresponds to transition operators that only consider local spatial neighborhoods. We describe these below and provide a mechanistically motivated example. We defer the discussion of dynamics for random effects in basis-function expansions to <a href="#sec-ProcRed" class="quarto-xref"><span>Section 5.3.2</span></a>.</p>
<section id="lagged-nearest-neighbor-representations" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="lagged-nearest-neighbor-representations">Lagged-Nearest-Neighbor Representations</h4>
<p>The importance of the rate of decay and asymmetry in IDE transition-kernel representations suggests that for discrete space a very parsimonious, yet realistic, dynamic model can be specified in terms of a simple <em>lagged-nearest-neighbor</em> (LNN) parameterization, for example,</p>
<p><span id="eq-LNN"><span class="math display">\[
Y_t(\mathbf{s}_i) = \sum_{\mathbf{s}_j \in {\cal N}_i} m_{ij} Y_{t-1}(\mathbf{s}_j) + \eta_t(\mathbf{s}_i),
\tag{5.13}\]</span></span></p>
<p>where <span class="math inline">\({\cal N}_i\)</span> corresponds to a pre-specified neighborhood of the location <span class="math inline">\(\mathbf{s}_i\)</span> (including <span class="math inline">\(\mathbf{s}_i\)</span>), for <span class="math inline">\(i=1,\ldots,n\)</span>, and where we specify <span class="math inline">\(m_{ij} = 0, \mbox{ for all }  \;\mathbf{s}_j \not\in {\cal N}_i\)</span>. Such a parameterization reduces the number of free parameters from the order of <span class="math inline">\(n^2\)</span> to the order of <span class="math inline">\(n\)</span>. It is often reasonable to further parameterize the transition coefficients in <a href="#eq-LNN" class="quarto-xref">Equation&nbsp;<span>5.13</span></a> to account for decay (spread or diffusion) rate and asymmetry (propagation direction). In some cases, homogeneities of the transitions would result in a single parameter to control a particular type of neighbor (e.g., a parameter for the west neighbor and east neighbor transition coefficients), or, in other cases, it would be more appropriate to let these parameters vary in space as well (as with the IDE transition-kernel example above).</p>
</section>
<section id="motivation-of-an-lnn-with-a-mechanistic-model" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="motivation-of-an-lnn-with-a-mechanistic-model">Motivation of an LNN with a Mechanistic Model</h4>
<p>The LNN parameterization can be motivated by many mechanistic models, such as those suggested by standard discretization of integro-differential or partial differential equations (PDEs). In the latter case, the parameters <span class="math inline">\(m_{ij}\)</span> in <a href="#eq-LNN" class="quarto-xref">Equation&nbsp;<span>5.13</span></a> can be parameterized in terms of other mechanistically motivated knowledge, such as spatially varying diffusion or advection coefficients. Again, in this framework the <span class="math inline">\(\{m_{ij}\}\)</span> are either estimated directly in an EHM or modeled at the next level of a BHM (typically, with some sort of spatial structure). As an example, consider the basic linear, non-random, advection–diffusion PDE,</p>
<p><span id="eq-Fickdiffadv"><span class="math display">\[
\frac{\partial Y}{\partial t} =  a \frac{\partial^2 Y}{\partial x^2}+ b \frac{\partial^2 Y}{\partial y^2} + u \frac{\partial Y}{\partial x} + v \frac{\partial Y}{\partial y},
\tag{5.14}\]</span></span></p>
<p>conditional on <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(u\)</span>, and <span class="math inline">\(v\)</span>, where <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are diffusion coefficients that control the rate of spread, and <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> are advection parameters that account for the process “flow” (i.e., advection). Simple finite-difference discretization of such PDEs on a two-dimensional equally spaced finite grid (see <a href="ChapterAppendixD.html#sec-PDEdecomp1" class="quarto-xref"><span>Section D.1</span></a>) can lead to LNN specifications of the form</p>
<p><span class="math display">\[
\mathbf{Y}_t = \mathbf{M}(\boldsymbol{\theta}_p) \mathbf{Y}_{t-1} + \mathbf{M}_b(\boldsymbol{\theta}_p) \mathbf{Y}_{b,t} + \boldsymbol{\eta}_t,
\]</span></p>
<p>where <span class="math inline">\(\mathbf{Y}_t\)</span> corresponds to a vectorization of the non-boundary grid points, with <span class="math inline">\(\mathbf{M}(\boldsymbol{\theta}_p)\)</span> a five-diagonal transition matrix with diagonals corresponding to functions of <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(u\)</span>, <span class="math inline">\(v\)</span> and the discretization parameters (e.g., these five diagonals correspond to <span class="math inline">\(\{\theta_{p,1}, \ldots,\theta_{p,5}\}\)</span> in <a href="ChapterAppendixD.html#sec-PDEdecomp1" class="quarto-xref"><span>Section D.1</span></a>). Such discretizations should account for boundary affects, and so we specify <span class="math inline">\(\mathbf{Y}_{b,t}\)</span> to be a boundary process (either fixed or assumed to be random) with <span class="math inline">\(\mathbf{M}_b(\boldsymbol{\theta}_p)\)</span> the associated transition operator based on the finite-difference discretization of the differential operator. The additive error process <span class="math inline">\(\{\boldsymbol{\eta}_t\}\)</span> is assumed to be Gaussian, mean-zero, and independent in time. In the more realistic case where the parameters <span class="math inline">\(a, b\)</span> and/or <span class="math inline">\(u, v\)</span> vary with space, the vector <span class="math inline">\(\boldsymbol{\theta}_p\)</span> varies with space as well, and we model it either in terms of covariates or as a spatial random process. The point is that we allow these mechanistic models to suggest or motivate LNN parameterizations rather than our specifying the structure directly. <a href="ChapterAppendixD.html" class="quarto-xref"><span>Appendix D</span></a> presents detailed examples of DSTMs motivated by mechanistic models, and the case study in <a href="ChapterAppendixE.html" class="quarto-xref"><span>Appendix E</span></a> presents an implementation of such a model for the Mediterranean winds data set described in Chapter 2.</p>
</section>
</section>
<section id="sec-ProcRed" class="level3" data-number="5.3.2">
<h3 data-number="5.3.2" class="anchored" data-anchor-id="sec-ProcRed"><span class="header-section-number">5.3.2</span> Dimension Reduction in the Process Model</h3>
<p>As discussed in <a href="Chapter4.html#sec-basisfunctions" class="quarto-xref"><span>Section 4.4</span></a>, it is often the case that to reduce process dimensionality we could consider the spatio-temporal process of interest as a decomposition in terms of “fixed” effects and random effects in a basis-function expansion. This is particularly helpful for DSTM process models, as it is often the case that the important dynamics exist on a fairly low-dimensional space (i.e., manifold). Consider an extension to the spatial basis-function mixed-effects model (<a href="Chapter4.html#eq-Yprocess_spbasis" class="quarto-xref">Equation&nbsp;<span>4.29</span></a>) from <a href="Chapter4.html#sec-randeffspat" class="quarto-xref"><span>Section 4.4.2</span></a>,</p>
<p><span id="eq-DSTMmixedeffects"><span class="math display">\[
Y_t(\mathbf{s}) = \mathbf{x}_t(\mathbf{s})' \boldsymbol{\beta}+ \sum_{i=1}^{n_\alpha} \phi_i(\mathbf{s}) \alpha_{i,t} + \sum_{j=1}^{n_\xi} \psi_j(\mathbf{s}) \xi_{j,t} + \nu_t(\mathbf{s}),
\tag{5.15}\]</span></span></p>
<p>where the term with covariates, <span class="math inline">\(\mathbf{x}_t(\mathbf{s})' \boldsymbol{\beta}\)</span>, might be interpreted as a “fixed” or “deterministic” component with fixed effects <span class="math inline">\(\boldsymbol{\beta}\)</span>; the first basis-expansion term, <span class="math inline">\(\sum_{i=1}^{n_\alpha} \phi_i(\mathbf{s}) \alpha_{i,t}\)</span>, contains known spatial <span class="math inline">\(\{\phi_i(\cdot)\}\)</span> and associated dynamically evolving random coefficients (i.e., random effects), <span class="math inline">\(\{\alpha_{i,t}\}\)</span>; the residual basis-expansion term, <span class="math inline">\(\sum_{j=1}^{n_\xi} \psi_j(\mathbf{s}) \xi_{j,t}\)</span>, can account for non-dynamic spatio-temporal structure, where the , <span class="math inline">\(\{\psi_j(\cdot)\}\)</span>, are again assumed known, and the random effects <span class="math inline">\(\{\xi_{j,t}\}\)</span> are typically non-dynamic or at least contain simple temporal behavior. The micro-scale term, <span class="math inline">\(\nu_t(\cdot)\)</span>, is assumed to be a with mean zero and independent in time. The focus here is on the dynamically evolving random effects, <span class="math inline">\(\{\alpha_{i,t}\}\)</span>.</p>
<p>As mentioned above, useful reductions in process dimension can be formulated with the understanding that the essential dynamics for spatio-temporal processes typically exist in a fairly low-dimensional space. This is helpful because, instead of having to model the evolution of, say, the <span class="math inline">\(n\)</span>-dimensional vector <span class="math inline">\(\mathbf{Y}_t\)</span>, one can model the evolution of a much lower-dimensional (of dimension <span class="math inline">\(n_\alpha\)</span>) process <span class="math inline">\(\{\boldsymbol{\alpha}_t\}\)</span>, where <span class="math inline">\(n_\alpha \ll n\)</span>. It is helpful to consider the vector form of <a href="#eq-DSTMmixedeffects" class="quarto-xref">Equation&nbsp;<span>5.15</span></a>:</p>
<p><span id="eq-Ydecomp"><span class="math display">\[
\mathbf{Y}_t = \mathbf{X}_t \boldsymbol{\beta}+  \boldsymbol{\Phi}\boldsymbol{\alpha}_t + \boldsymbol{\Psi}\boldsymbol{\xi}_t + \boldsymbol{\nu}_t,
\tag{5.16}\]</span></span></p>
<p>where <span class="math inline">\(\mathbf{X}_t\)</span> is an <span class="math inline">\(n \times p\)</span> matrix that could be time-varying and can be interpreted as a spatial offset corresponding to large-scale non-dynamical features and/or covariate effects, <span class="math inline">\({\boldsymbol{\Phi}}\)</span> is an <span class="math inline">\(n \times n_\alpha\)</span> matrix of basis vectors corresponding to the latent dynamic coefficient process, <span class="math inline">\(\{\boldsymbol{\alpha}_t\}\)</span>, and <span class="math inline">\(\boldsymbol{\Psi}\)</span> is an <span class="math inline">\(n \times n_\xi\)</span> matrix of basis vectors corresponding to the latent coefficient process, <span class="math inline">\(\{\boldsymbol{\xi}_t\}\)</span>. Typically, <span class="math inline">\(\{\boldsymbol{\xi}_t\}\)</span> is assumed to have different dynamic characteristics than <span class="math inline">\(\{\boldsymbol{\alpha}_t\}\)</span>, or this component might account for non-dynamic spatial variability. The error process <span class="math inline">\(\{\boldsymbol{\nu}_t\}\)</span> is Gaussian and assumed to have mean zero with relatively simple temporal dependence structure (usually independence).</p>
<p>The evolution of the latent process <span class="math inline">\(\{\boldsymbol{\alpha}_t\}\)</span> can proceed according to the linear equations involving a transition matrix, discussed earlier. For example, one could specify a first-order vector autoregressive model (VAR(1)),</p>
<p><span id="eq-VARalpha"><span class="math display">\[
\boldsymbol{\alpha}_t = \mathbf{M}_\alpha \boldsymbol{\alpha}_{t-1} + \boldsymbol{\eta}_t,
\tag{5.17}\]</span></span></p>
<p>where <span class="math inline">\(\mathbf{M}_\alpha\)</span> is the <span class="math inline">\(n_\alpha \times n_\alpha\)</span> transition matrix, and <span class="math inline">\(\boldsymbol{\eta}_t \sim Gau(\mathbf{0},\mathbf{C}_\eta)\)</span> (which are assumed to be independent of <span class="math inline">\(\boldsymbol{\alpha}_{t-1}\)</span> and independent in time). The matrices <span class="math inline">\(\mathbf{M}_\alpha\)</span> and <span class="math inline">\(\mathbf{C}_\eta\)</span> in <a href="#eq-VARalpha" class="quarto-xref">Equation&nbsp;<span>5.17</span></a> are often relatively simple in structure, depending on the nature of the real-world process and the type of basis functions considered. However, even in this low-dimensional context (<span class="math inline">\(n_\alpha \ll n\)</span>), in many cases parameter-space reduction may still be necessary. One could consider the simple structures that were discussed in the context of linear DSTM process models (e.g., random walks, independent AR models, nearest-neighbor models). Typically, it is important, for the reasons discussed in <a href="#sec-LinGaussProcess" class="quarto-xref"><span>Section 5.2.3</span></a> and <a href="#nte-technote-transgrowth" class="quarto-xref">Note&nbsp;<span>5.2</span></a>, that the transition operator be non-normal (i.e., <span class="math inline">\(\mathbf{M}_\alpha' \mathbf{M}_\alpha \neq \mathbf{M}_\alpha \mathbf{M}_\alpha'\)</span>), so one should consider non-diagonal transition matrices in most cases. Also, the notion of “neighbors” is not always well defined in these formulations. If the basis functions given in <span class="math inline">\(\boldsymbol{\Phi}\)</span> are such that the elements of <span class="math inline">\(\boldsymbol{\alpha}_t\)</span> are not spatially indexed (e.g., in the case of global basis functions such as some types of splines, Fourier, EOFs, etc.), then a neighbor cannot be based on physical space (but perhaps it can be based on other characteristics, such as spatial scale). It is important to note that mechanistic knowledge can also be used in this case to motivate parameterizations for <span class="math inline">\(\mathbf{M}_\alpha\)</span>. We illustrate a couple of such cases, one for a “spectral” representation of a PDE in <a href="ChapterAppendixD.html#sec-PDEdecomp" class="quarto-xref"><span>Section D.2</span></a>, and one for an IDE process in <a href="ChapterAppendixD.html#sec-IDEdecomp" class="quarto-xref"><span>Section D.3</span></a>. Lab 5.3 provides an example in which <span class="math inline">\(\mathbf{M}_\alpha\)</span> and <span class="math inline">\(\mathbf{C}_\eta\)</span> are estimated by the method of moments and by an EM algorithm (see <a href="ChapterAppendixC.html" class="quarto-xref"><span>Appendix C</span></a> for more details about these algorithms).</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>If one is able to write down the data model as <span class="math inline">\(\mathbf{Z}_t =  \mathbf{H}_t \mathbf{Y}_t + \boldsymbol{\varepsilon}_t,\ \boldsymbol{\varepsilon}_t \sim Gau(\mathbf{0},\mathbf{C}_{\epsilon,t}),\)</span> and the process model as <span class="math inline">\(\mathbf{Y}_t = \mathbf{M}\mathbf{Y}_{t-1} + \boldsymbol{\eta}_t,\ \boldsymbol{\eta}_t \sim Gau(\mathbf{0},\mathbf{C}_{\eta})\)</span>, where the <span class="math inline">\(\{\mathbf{H}_t\}\)</span> are known, then the problem of predicting <span class="math inline">\(\{\boldsymbol{\alpha}_t\}\)</span> and the estimation of all the other parameters is the well-known dual state-parameter estimation problem for state-space models (see <a href="ChapterAppendixC.html" class="quarto-xref"><span>Appendix C</span></a>). Several <strong>R</strong> packages are available for this, such as <strong>KFAS</strong>, <strong>MARSS</strong>, and <strong>Stem</strong>. Software for DSTMs is, however, less developed than that for descriptive models, and estimation/prediction with complex linear DSTMs and nonlinear DSTMs is likely to require customized <strong>R</strong> code.</p>
</div>
</div>
<section id="basis-functions" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="basis-functions">Basis Functions</h4>
<p>In the mechanistically motivated PDE and IDE cases presented in Appendices <a href="ChapterAppendixD.html#sec-PDEdecomp" class="quarto-xref"><span>Section D.2</span></a> and <a href="ChapterAppendixD.html#sec-IDEdecomp" class="quarto-xref"><span>Section D.3</span></a>, the natural choice for basis functions are the Fourier modes (i.e., sines and cosines). This is typically not the case for DSTM process models. Indeed, there are many choices for the basis functions that could be used to define <span class="math inline">\(\boldsymbol{\Phi}\)</span> and <span class="math inline">\(\boldsymbol{\Psi}\)</span> in <a href="#eq-Ydecomp" class="quarto-xref">Equation&nbsp;<span>5.16</span></a> (see, for example, <a href="Chapter4.html#fig-spat_basis_fn" class="quarto-xref">Figure&nbsp;<span>4.7</span></a>). In the context of DSTMs, it is usually important to specify basis functions such that interactions across spatial scales are allowed to accommodate transient growth. This can be more difficult to do in “knot-based” representations (e.g., splines, kernel convolutions, predictive processes), where the coefficients <span class="math inline">\(\boldsymbol{\alpha}_t\)</span> of <span class="math inline">\(\boldsymbol{\Phi}\)</span> are spatially referenced but not necessarily multi-resolutional. Most other basis-function representations are in some sense multi-scale, and the associated expansion coefficients <span class="math inline">\(\{\boldsymbol{\alpha}_t\}\)</span> are not indexed in space. In this case, the dynamical evolution in the DSTM can easily accommodate scale interactions. The example in Lab 5.3 uses EOFs as the basis functions in such a decomposition of SSTs. Recall that the coefficients <span class="math inline">\(\{\boldsymbol{\xi}_t\}\)</span> associated with the matrix <span class="math inline">\(\boldsymbol{\Psi}\)</span> are typically specified to have much simpler dynamic structure (if at all), since the controlling dynamics are assumed to be associated principally with <span class="math inline">\(\{\boldsymbol{\alpha}_t\}\)</span>. Thus, one has more freedom in the choice of basis functions that define <span class="math inline">\(\boldsymbol{\Psi}\)</span>.</p>
</section>
</section>
</section>
<section id="sec-nonlinearDSTMs" class="level2" data-number="5.4">
<h2 data-number="5.4" class="anchored" data-anchor-id="sec-nonlinearDSTMs"><span class="header-section-number">5.4</span> Nonlinear DSTMs</h2>
<p>The linear Gaussian DSTMs described in <a href="#sec-LGDSTM" class="quarto-xref"><span>Section 5.2</span></a> and <a href="#sec-ProcParamRed" class="quarto-xref"><span>Section 5.3</span></a> are widely used, but the state of the art for more complicated models is rapidly advancing. The purpose of this section is not to give a complete overview of these more advanced models but just a brief perspective on nonlinear DSTMs <em>without</em> the implementation details.</p>
<p>Many mechanistic processes are best modeled nonlinearly, at least at some spatial and temporal scales of variability. We might write this as a nonlinear spatio-temporal AR(1) process (of course, higher-order lags could be considered as well):</p>
<p><span id="eq-gennonlin"><span class="math display">\[
Y_t(\cdot) = {\cal M}(Y_{t-1}(\cdot), \eta_t(\cdot);\boldsymbol{\theta}_p), \quad t=1,2,\ldots,
\tag{5.18}\]</span></span></p>
<p>where <span class="math inline">\({\cal M}\)</span> is a nonlinear function that models the process transition from time <span class="math inline">\(t-1\)</span> to <span class="math inline">\(t\)</span>, <span class="math inline">\(\eta_t(\cdot)\)</span> is an error process, and <span class="math inline">\(\boldsymbol{\theta}_p\)</span> are parameters. Unfortunately, although there is one basic linear model, there are an infinite number of nonlinear statistical models that could be considered. One could either take a nonparametric view of the problem and essentially learn the dynamics from the data, or one could propose specific model classes that can accommodate the type of behavior desired. In this section we briefly describe examples of these approaches to accommodate nonlinear spatio-temporal dynamics.</p>
<section id="state-dependent-models" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="state-dependent-models">State-Dependent Models</h4>
<p>The general nonlinear model (<a href="#eq-gennonlin" class="quarto-xref">Equation&nbsp;<span>5.18</span></a>) can be simplified by considering a <em>state-dependent model</em> (the terminology comes from the time-series literature, where these models were first developed), in which the transition matrix depends on the process (state) value at each time. For example, in the discrete spatial case, we can write</p>
<p><span id="eq-statedep"><span class="math display">\[
\mathbf{Y}_t = \mathbf{M}(\mathbf{Y}_{t-1};\boldsymbol{\theta}_p) \; \mathbf{Y}_{t-1} + \boldsymbol{\eta}_t,
\tag{5.19}\]</span></span></p>
<p>where the transition operator depends on <span class="math inline">\(\mathbf{Y}_{t-1}\)</span> and parameters <span class="math inline">\(\boldsymbol{\theta}_p\)</span> (which, more generally, may also vary with time and/or space). Models such as <a href="#eq-statedep" class="quarto-xref">Equation&nbsp;<span>5.19</span></a> are still too general for spatio-temporal applications and must be further specified. One type of state-dependent model is the <em>threshold vector autoregressive model</em>, given by</p>
<p><span id="eq-thresholdAR"><span class="math display">\[
\mathbf{Y}_t =  \left\{
\begin{array}{ll}
\mathbf{M}_1 \mathbf{Y}_{t-1} + \boldsymbol{\eta}_{1,t}\,, &amp; \;\; \mbox{ if } f(\omega_t) \in d_1, \\
\;\;\; \vdots &amp; \;\;\;\;\; \vdots \\
\mathbf{M}_K \mathbf{Y}_{t-1} + \boldsymbol{\eta}_{K,t}\,, &amp; \;\; \mbox{ if } f(\omega_t) \in d_K, \\
\end{array}
\right.
\tag{5.20}\]</span></span></p>
<p>where <span class="math inline">\(f(\omega_t)\)</span> is a function of a time-varying parameter <span class="math inline">\(\omega_t\)</span> that can itself be a function of the process, <span class="math inline">\(\mathbf{Y}_{t-1}\)</span>, in which case it is a state-dependent model. We implicitly assume that conditions on the right-hand side of <a href="#eq-thresholdAR" class="quarto-xref">Equation&nbsp;<span>5.20</span></a> are mutually exclusive; that is, <span class="math inline">\(d_1, \ldots, d_K\)</span> are disjoint. A simpler threshold model results if the parameters <span class="math inline">\(\{\omega_t\}\)</span> do not depend on the process. Of course, the transition matrices <span class="math inline">\(\{\mathbf{M}_1,\ldots, \mathbf{M}_K\}\)</span> and error covariance matrices <span class="math inline">\(\{\mathbf{C}_{\eta_1},\ldots,\mathbf{C}_{\eta_K} \}\)</span> depend on unknown parameters, and the big challenge in DSTM modeling is to reduce the dimensionality of this parameter space to facilitate estimation. Some of the approaches discussed above for the linear DSTM process model can also be applied in this setting.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Threshold vector autoregressive time-series models can be implemented with the <code>TVAR</code> command in the package <strong>tsDyn</strong>.</p>
</div>
</div>
</section>
<section id="general-quadratic-nonlinearity" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="general-quadratic-nonlinearity">General Quadratic Nonlinearity</h4>
<p>A very large number of real-world processes in the physical and biological sciences exhibit quadratic interactions. For example, consider the following one-dimensional reaction–diffusion PDE:</p>
<p><span id="eq-reacdiffeq"><span class="math display">\[
\frac{\partial Y}{\partial t} = \frac{\partial}{\partial x}\left(\delta \frac{\partial Y}{\partial x}\right) +  Y \exp\left(\gamma_0 \left(1 - \frac{Y}{\gamma_1}\right)\right),
\tag{5.21}\]</span></span></p>
<p>where the first term corresponds to a diffusion (spread) term that depends on a parameter <span class="math inline">\(\delta\)</span>, and the second term corresponds to a density-dependent (Ricker) growth term with growth parameter <span class="math inline">\(\gamma_0\)</span> and carrying capacity parameter <span class="math inline">\(\gamma_1\)</span>. More generally, each of these parameters could vary with space and/or time. Notice that the diffusion term is linear in <span class="math inline">\(Y\)</span> but the density-dependent growth term is nonlinear in that it is a function of <span class="math inline">\(Y\)</span> multiplied by a nonlinear transformation of <span class="math inline">\(Y\)</span>. This can be considered a general case of a quadratic interaction.</p>
<p>A fairly general class of nonlinear statistical DSTM process models can be specified to accommodate such behavior. In discrete space and time, such a <em>general quadratic nonlinear</em> (GQN) DSTM can be written, for <span class="math inline">\(i=1,\ldots,n\)</span>, as</p>
<p><span id="eq-GQN"><span class="math display">\[
Y_t(\mathbf{s}_i) = \sum_{j=1}^n m_{ij} Y_{t-1}(\mathbf{s}_j) + \sum_{k=1}^n \sum_{\ell=1}^n b_{i,k \ell} \; g(Y_{t-1}(\mathbf{s}_{\ell});\boldsymbol{\theta}_g) \; Y_{t-1}(\mathbf{s}_k)  + \eta_t(\mathbf{s}_i),
\tag{5.22}\]</span></span></p>
<p>where <span class="math inline">\(m_{ij}\)</span> are the linear-transition coefficients seen previously, and the quadratic-interaction transition coefficients are denoted by <span class="math inline">\(b_{i,k \ell}\)</span>. Importantly, a transformation of one of the components of the quadratic interaction is included through the function <span class="math inline">\(g(\cdot)\)</span>, which can depend on parameters <span class="math inline">\(\boldsymbol{\theta}_g\)</span>. This function <span class="math inline">\(g(\cdot)\)</span> is responsible for the term “general” in GQN, and such transformations are important for many processes such as density-dependent growth that one may see in an epidemic or invasive-species population processes (see, for example, <a href="#eq-reacdiffeq" class="quarto-xref">Equation&nbsp;<span>5.21</span></a> above), and they can keep forecasts from “blowing up” in time. The spatio-temporal error process <span class="math inline">\(\{\eta_t(\cdot)\}\)</span> is again typically assumed to be independent in time and Gaussian with mean zero and a spatial covariance matrix. Note that the conditional GQN model for <span class="math inline">\(Y_{t}(\cdot)\)</span> conditioned on <span class="math inline">\(Y_{t-1}(\cdot)\)</span> is Gaussian, but the marginal model for <span class="math inline">\(Y_t(\cdot)\)</span> will not in general be Gaussian because of the nonlinear interactions. The GQN model <a href="#eq-GQN" class="quarto-xref">Equation&nbsp;<span>5.22</span></a> can be shown to be a special case of the state-dependent model in <a href="#eq-statedep" class="quarto-xref">Equation&nbsp;<span>5.19</span></a>.</p>
<p>There are multiple challenges when implementing models such as <a href="#eq-GQN" class="quarto-xref">Equation&nbsp;<span>5.22</span></a>. Chief among these is the curse of dimensionality. There are <span class="math inline">\(O(n^3)\)</span> parameters and, unless one has an enormous number of time replicates (<span class="math inline">\(T \gg n\)</span>), inference on them is problematic without some sort of regularization (shrinkage) and/or the incorporation of prior information. In addition to parameter estimation, depending on the specification of <span class="math inline">\(g(\cdot)\)</span> (which can act to control the growth of the process), these models can be explosive when used to forecast multiple time steps into the future. GQN models have been implemented on an application-specific basis in BHMs <span class="citation" data-cites="cressie2011statistics">(see Chapter 7 of <a href="references.html#ref-cressie2011statistics" role="doc-biblioref">Cressie &amp; Wikle, 2011</a> for more discussion)</span>.</p>
</section>
<section id="some-other-nonlinear-models" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="some-other-nonlinear-models">Some Other Nonlinear Models</h4>
<p>There are currently several promising approaches for nonlinear spatio-temporal modeling in addition to those mentioned above. For example, there are a wide variety of methods being developed in machine learning to predict and/or classify high volumes of dependent data, including spatio-temporal data (e.g., sequences of images). These methods often relate to variants of neural networks (e.g., convolutional and recurrent neural networks (RNNs)), and they have revolutionized many application areas such as image classification and natural-language processing. In their original formulations, these methods do not typically address uncertainty quantification. However, there is increasing interest in considering such models within broader uncertainty-based paradigms. As mentioned in Chapter 1, there is a connection between deep hierarchical statistical models (BHMs) and many of these so-called “deep learning” algorithms.</p>
<p>For example, the GQN model described above is flexible, interpretable, and can accommodate many different types of dynamic processes and uncertainty quantification strategies. Similarly, the typical RNN model is also flexible and can accommodate a wide variety of spatio-temporal dependence structures. However, both the GQN and RNN models can be difficult to implement computationally due to the high dimensionality of the hidden states and parameters, and it typically requires sophisticated regularization (and/or a large amount of data or prior information) to make them work. A computationally efficient alternative is the so-called <em>echo state network</em> (ESN) methodology that was developed as an alternative to RNNs in the engineering literature <span class="citation" data-cites="lukovsevivcius2009reservoir lukovsevivcius2012practical">(<a href="references.html#ref-lukovsevivcius2012practical" role="doc-biblioref">Lukoševičius, 2012</a>; for overviews, see <a href="references.html#ref-lukovsevivcius2009reservoir" role="doc-biblioref">Lukoševičius &amp; Jaeger, 2009</a>)</span>. Importantly, ESNs consider sparsely connected hidden layers that allow for sequential interactions yet assume most of the parameters (“weights”) are randomly generated and then fixed, with the only parameters estimated being those that connect the hidden layer to the response. This induces a substantially more parsimonious structure in the model. Yet, these models traditionally do not explicitly include quadratic interactions or formal uncertainty quantification. <span class="citation" data-cites="mcdermott2017ensemble">McDermott &amp; Wikle (<a href="references.html#ref-mcdermott2017ensemble" role="doc-biblioref">2017</a>)</span> consider a quadratic spatio-temporal ESN model they call a quadratic ESN (QESN) and implement it in a bootstrap context to account for parameter uncertainty. Details concerning the QESN are given in <a href="ChapterAppendixF.html" class="quarto-xref"><span>Appendix F</span></a>, and the associated case study provides an example of how to use an ensemble of QESNs to generate a long-lead forecast of the SST data.</p>
<p>Another type of nonlinear spatio-temporal model that is increasingly being considered in statistical applications is the <em>agent-based model</em> (or, in some literatures, the <em>individual-based model</em>). In this case, the process is built from local individual-scale interactions by means of fairly simple rules that lead to complex nonlinear behavior. Although these models are parsimonious in that they have relatively few parameters, they can be quite computationally expensive, and parameter inference can be challenging (although approximate likelihood methods and BHMs have shown recent promise). For examples, see <span class="citation" data-cites="cressie2011statistics">Cressie &amp; Wikle (<a href="references.html#ref-cressie2011statistics" role="doc-biblioref">2011, Section 7.3.4</a>)</span> and <span class="citation" data-cites="wikle2016hierarchical">Wikle &amp; Hooten (<a href="references.html#ref-wikle2016hierarchical" role="doc-biblioref">2016</a>)</span>.</p>
<p>There is yet another parsimonious approach to nonlinear spatio-temporal modeling that is somewhat science-based and relies on so-called “analogs.” Sometimes referred to as a “mechanism-free” approach, in its most basic form, analog seeks to find historical sequences of maps (analogs) that match a similar sequence culminating at the current time. Then it assumes that the forecast made at the current time will be what actually occurred with the best analog matches. (This is somewhat like the so-called “hot-deck imputation” in statistics.) Analog forecasting can be shown to be a type of spatio-temporal nearest-neighbor-regression methodology. There are many modifications to this procedure related to various conditions as to what “best” means when comparing analogs to the current state, distance metrics, how many analogs to use, and so forth. Traditionally, these methods have not been part of statistical methodology, and so uncertainty quantification and parameter estimation are not generally considered from a formal probabilistic perspective. Recent implementations have sought to consider uncertainty quantification and formal inference, including prediction, within a Bayesian inferential framework <span class="citation" data-cites="mcdermott2016model">McDermott &amp; Wikle (<a href="references.html#ref-mcdermott2016model" role="doc-biblioref">2016</a>)</span>; <span class="citation" data-cites="mcdermott2018hierarchical">McDermott et al. (<a href="references.html#ref-mcdermott2018hierarchical" role="doc-biblioref">2018</a>)</span>.</p>
</section>
</section>
<section id="chapter-5-wrap-up" class="level2" data-number="5.5">
<h2 data-number="5.5" class="anchored" data-anchor-id="chapter-5-wrap-up"><span class="header-section-number">5.5</span> Chapter 5 Wrap-Up</h2>
<p>Recall that one of the big challenges with the descriptive spatio-temporal models described in Chapter 4 was the specification of realistic covariance structures. We showed that building such structures through conditioning on random effects could be quite useful. The present chapter considered spatio-temporal models from a conditional-in-time (dynamic) perspective that respected the belief that most real-world spatio-temporal processes are best described as spatial processes that evolve through time. Like the random-effects models of Chapter 4, this perspective relied very much on conditional-probability models. First, there was a strong assumption (which is also present in the descriptive models of Chapter 4) that the data, when conditioned on the true spatio-temporal process of interest, could be considered independent in time (and, typically, have fairly simple error structure as well). Second, a Markov assumption in time was made, so that the joint distribution of the process could be decomposed as the product of low-order Markov (in time) conditional-probability distributions. These conditional distributions corresponded to dynamic models that describe the transition of the spatial process from the previous time(s) to the current time. This dynamic model was further conditioned on parameters that control the transition and the innovation-error structure. We showed that the models can often benefit from these parameters being random processes (and/or dependent on covariates) as well.</p>
<p>We presented the most commonly used DSTMs with data models that have additive Gaussian error and process models that have linear transition structure with additive Gaussian error. In the simplest case, where time is discrete and interest is in a finite set of spatial locations, we showed that these models are essentially multivariate state-space time series models , and many of the sequential prediction and estimation algorithms from that literature (e.g., filters, smoothers plus estimation through EM, and Bayesian algorithms) can then be used. We also discussed that non-Gaussian data models are fairly easily accommodated if one can obtain conditional independence when conditioning on a latent Gaussian process model (e.g., a data model obtained from a generalized linear model). Additional details on such estimation methods can be found in <span class="citation" data-cites="shumway1982approach">Shumway &amp; Stoffer (<a href="references.html#ref-shumway1982approach" role="doc-biblioref">1982</a>)</span>, <span class="citation" data-cites="shumway2006time">Shumway &amp; Stoffer (<a href="references.html#ref-shumway2006time" role="doc-biblioref">2006</a>)</span>, <span class="citation" data-cites="gamerman2006markov">Gamerman &amp; Lopes (<a href="references.html#ref-gamerman2006markov" role="doc-biblioref">2006</a>)</span>, <span class="citation" data-cites="prado2010time">Prado &amp; West (<a href="references.html#ref-prado2010time" role="doc-biblioref">2010</a>)</span>, <span class="citation" data-cites="cressie2011statistics">Cressie &amp; Wikle (<a href="references.html#ref-cressie2011statistics" role="doc-biblioref">2011</a>)</span>, and <span class="citation" data-cites="douc2014nonlinear">Douc et al. (<a href="references.html#ref-douc2014nonlinear" role="doc-biblioref">2014</a>)</span>.</p>
<p>We emphasized that the biggest challenge with these models is accommodating high dimensionality (either in data volume, number of prediction locations, or number of parameters to be estimated). Thus, one of the fundamental differences between DSTMs and multivariate time series models is that DSTMs require scalable parameterization of the evolution model. We showed that this modeling can be facilitated greatly by understanding some of the fundamental properties of linear dynamical systems and using this mechanistic knowledge to parameterize transition functions/matrices. Additional details on the mechanistic motivation for DSTMs can be found in <span class="citation" data-cites="cressie2011statistics">Cressie &amp; Wikle (<a href="references.html#ref-cressie2011statistics" role="doc-biblioref">2011</a>)</span>.</p>
<p>We discussed that nonlinear DSTMs are an increasingly important area of spatio-temporal modeling. It is important that statistical models for such processes include realistic structural components (e.g., quadratic interactions) and account formally for uncertainty quantification. We mentioned that a significant challenge with these models in both the statistics and machine learning literature is to mitigate the curse of dimensionality in the parameter space <span class="citation" data-cites="cressie2011statistics">Cressie &amp; Wikle (<a href="references.html#ref-cressie2011statistics" role="doc-biblioref">2011</a>)</span>, <span class="citation" data-cites="goodfellow2016deep">Goodfellow et al. (<a href="references.html#ref-goodfellow2016deep" role="doc-biblioref">2016</a>)</span>. This often requires mechanistic-based parameterizations, informative prior distributions s, and/or regularization approaches. This has led to increased interest in very parsimonious representations for nonlinear DSTMs, such as echo state networks, agent-based models , and analog models .</p>
<p>In general, DSTMs require many assumptions in order to build conditional models at each level of the hierarchy. They can also be difficult to implement in some cases due to complex dependence and deep levels, often requiring fully Bayesian implementations. This also makes it necessary to validate these assumptions carefully through model diagnostics and evaluation of their predictions. Some approaches to spatio-temporal model evaluation are discussed in Chapter 6.</p>
</section>
<section id="lab-5.1-implementing-an-ide-model-in-one-dimensional-space" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="lab-5.1-implementing-an-ide-model-in-one-dimensional-space">Lab 5.1: Implementing an IDE Model in One-Dimensional Space</h2>
<p>In this Lab we take a look at how one can implement a stochastic integro-difference equation (IDE) in one-dimensional space and time, from first principles. Specifically, we shall consider the dynamic model,</p>
<p><span class="math display">\[Y_{t}(s) = \int_{D_s}m(s,x;\boldsymbol{\theta}_p)Y_{t-1}(x) \textrm{d}x + \eta_t(s),\quad s,x \in D_s,\]</span></p>
<p>where <span class="math inline">\(Y_t(\cdot)\)</span> is the spatio-temporal process at time <span class="math inline">\(t\)</span>; <span class="math inline">\(\boldsymbol{\theta}_p\)</span> are parameters that we fix (in practice, these will be estimated from data; see Lab 5.2); and <span class="math inline">\(\eta_t(\cdot)\)</span> is a spatial process, independent of <span class="math inline">\(Y_t(\cdot)\)</span>, with covariance function that we shall assume is known.</p>
<p>We only need the packages <strong>dplyr</strong>, <strong>ggplot2</strong>, and <strong>STRbook</strong> for this lab and, for reproducibility purposes, we fix the seed.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"dplyr"</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggplot2"</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"STRbook"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="constructing-the-process-grid-and-kernel" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="constructing-the-process-grid-and-kernel">Constructing the Process Grid and Kernel</h3>
<p>We start off by constructing a discretization of the one-dimensional spatial domain <span class="math inline">\(D_s = [0,1]\)</span>. We shall use this discretization, containing cells of width <span class="math inline">\(\Delta_s\)</span>, for both approximate integrations as well as visualizations. We call this our spatial grid.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>ds <span class="ot">&lt;-</span> <span class="fl">0.01</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>s_grid <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="at">by =</span> ds)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="fu">length</span>(s_grid)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Our space-time grid is formed by calling <code>expand.grid</code> with <code>s_grid</code> and our temporal domain, which we define as the set of integers spanning 0 up to <span class="math inline">\(T = 200\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>nT <span class="ot">&lt;-</span> <span class="dv">201</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>t_grid <span class="ot">&lt;-</span> <span class="dv">0</span><span class="sc">:</span>(nT<span class="dv">-1</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>st_grid <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(<span class="at">s =</span> s_grid, <span class="at">t =</span> t_grid)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The transition kernel <span class="math inline">\(m(s,x; \boldsymbol{\theta}_p)\)</span> is a bivariate function on our spatial grid. It is defined below to be a Gaussian kernel, where the entries of <span class="math inline">\(\boldsymbol{\theta}_p = (\theta_{p,1},\theta_{p,2},\theta_{p,3})'\)</span> are the amplitude, the scale (aperture, twice the variance), and the shift (offset) of the kernel, respectively. Specifically,</p>
<p><span class="math display">\[
m(s,x; \boldsymbol{\theta}_p) \equiv \theta_{p,1}\exp\left(-\frac{1}{\theta_{p,2}}(x - \theta_{p,3} - s)^2\right),
\]</span></p>
<p>which can be implemented as an R function as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>m <span class="ot">&lt;-</span> <span class="cf">function</span>(s, x, thetap) {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  gamma <span class="ot">&lt;-</span> thetap[<span class="dv">1</span>]                 <span class="co"># amplitude</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  l <span class="ot">&lt;-</span> thetap[<span class="dv">2</span>]                     <span class="co"># length scale</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  offset <span class="ot">&lt;-</span> thetap[<span class="dv">3</span>]                <span class="co"># offset</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  D <span class="ot">&lt;-</span> <span class="fu">outer</span>(s <span class="sc">+</span> offset, x, <span class="st">'-'</span>)     <span class="co"># displacements</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  gamma <span class="sc">*</span> <span class="fu">exp</span>(<span class="sc">-</span>D<span class="sc">^</span><span class="dv">2</span><span class="sc">/</span>l)                <span class="co"># kernel eval.</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note the use of the function <code>outer</code> with the subtraction operator. This function performs an “outer operation” (a generalization of the outer product) by computing an operation between every two elements of the first two arguments, in this case a subtraction.</p>
<p>We can now visualize some kernels by seeing how the process at <span class="math inline">\(s = 0.5\)</span> depends on <span class="math inline">\(x\)</span>. Four such kernels are constructed below: the first is narrow and centered on 0.5; the second is slightly wider; the third is shifted to the right; and the fourth is shifted to the left. We store the parameters of the four different kernels in a list <code>thetap</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>thetap <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>thetap[[<span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">40</span>, <span class="fl">0.0002</span>, <span class="dv">0</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>thetap[[<span class="dv">2</span>]] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">5.75</span>, <span class="fl">0.01</span>, <span class="dv">0</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>thetap[[<span class="dv">3</span>]] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">8</span>, <span class="fl">0.005</span>, <span class="fl">0.1</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>thetap[[<span class="dv">4</span>]] <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">8</span>, <span class="fl">0.005</span>, <span class="sc">-</span><span class="fl">0.1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Plotting proceeds by first evaluating the kernel for all <span class="math inline">\(x\)</span> at <span class="math inline">\(s = 0.5\)</span>, and then plotting these evaluations against <span class="math inline">\(x\)</span>. The first kernel is plotted below; plotting the other three is left as an exercise for the reader. The kernels are shown in the top panels of <a href="#fig-DSTMdynamics" class="quarto-xref">Figure&nbsp;<span>5.2</span></a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>m_x_0<span class="fl">.5</span> <span class="ot">&lt;-</span> <span class="fu">m</span>(<span class="at">s =</span> <span class="fl">0.5</span>, <span class="at">x =</span> s_grid,            <span class="co"># construct kernel</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>             <span class="at">thetap =</span> thetap[[<span class="dv">1</span>]]) <span class="sc">%&gt;%</span>       <span class="co"># at s = 0.5</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>           <span class="fu">as.numeric</span>()                      <span class="co"># convert to numeric</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">x =</span> s_grid, <span class="at">m =</span> m_x_0<span class="fl">.5</span>)      <span class="co"># allocate to df</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(df) <span class="sc">+</span> <span class="fu">geom_line</span>(<span class="fu">aes</span>(x, m)) <span class="sc">+</span> <span class="fu">theme_bw</span>() <span class="co"># plot</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The last term we need to define is <span class="math inline">\(\eta_t(\cdot)\)</span>. Here, we define it as a spatial process with an exponential covariance function with range parameter 0.1 and variance 0.1. The covariance matrix at each time point is then</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>Sigma_eta <span class="ot">&lt;-</span> <span class="fl">0.1</span> <span class="sc">*</span> <span class="fu">exp</span>( <span class="sc">-</span><span class="fu">abs</span>(<span class="fu">outer</span>(s_grid, s_grid, <span class="st">'-'</span>) <span class="sc">/</span> <span class="fl">0.1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Simulating <span class="math inline">\(\eta_t(s)\)</span> over <code>s_grid</code> proceeds by generating a multivariate Gaussian vector with mean zero and covariance matrix <code>Sigma_eta</code>. To do this, one can use the function <code>mvrnorm</code> from the package <strong>MASS</strong>. Alternatively, one may use the lower Cholesky factor of <code>Sigma_eta</code> and multiply this by a vector of numbers generated from a mean-zero, variance-one, independent-elements Gaussian random vector <span class="citation" data-cites="rue2005gaussian">(see <a href="references.html#ref-rue2005gaussian" role="doc-biblioref">Rue &amp; Held, 2005</a>, Algorithm 2.3)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>L <span class="ot">&lt;-</span> <span class="fu">t</span>(<span class="fu">chol</span>(Sigma_eta))  <span class="co"># chol() returns upper Cholesky factor</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>sim <span class="ot">&lt;-</span> L <span class="sc">%*%</span> <span class="fu">rnorm</span>(<span class="fu">nrow</span>(Sigma_eta))  <span class="co"># simulate</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Type <code>plot(s_grid, sim, 'l')</code> to plot this realization of <span class="math inline">\(\eta_t(s)\)</span> over <code>s_grid</code>.</p>
</section>
<section id="simulating-from-the-ide" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="simulating-from-the-ide">Simulating from the IDE</h3>
<p>Now we have everything in place to simulate from the IDE. Simulation is most easily carried out using a <code>for</code> loop as shown below. We shall carry out four simulations, one for each kernel constructed above, and store the simulations in a list of four data frames, one for each simulation. The following command initializes this list.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>Y <span class="ot">&lt;-</span> <span class="fu">list</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For each simulation setting (which we iterate using the index <code>i</code>), we simulate the time points (which we iterate using <code>j</code>) to obtain the process. The “nested <code>for</code> loop” below accomplishes this. In the outer loop, the kernel is constructed and the process is initialized to zero. In the inner loop, the integration is approximated using a Riemann sum,</p>
<p><span class="math display">\[
\int_{D_s}m(s,x;\boldsymbol{\theta}_p)Y_{t-1}(x) \textrm{d}x \approx \sum_i m(s,x_i;\boldsymbol{\theta}_p)Y_{t-1}(x_i)\Delta_s ,
\]</span></p>
<p>where we recall that we have set <span class="math inline">\(\Delta_s = 0.01\)</span>. Next, at every time point <span class="math inline">\(\eta_t(s)\)</span> is simulated on the grid and added to the sum (an approximation of the integral) above.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>) {                         <span class="co"># for each kernel</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  M <span class="ot">&lt;-</span> <span class="fu">m</span>(s_grid, s_grid, thetap[[i]])   <span class="co"># construct kernel</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  Y[[i]] <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">s =</span> s_grid,      <span class="co"># init. data frame with s</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                       <span class="at">t =</span> <span class="dv">0</span>,           <span class="co"># init. time point 0, and</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>                       <span class="at">Y =</span> <span class="dv">0</span>)           <span class="co"># init. proc. value = 0</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(j <span class="cf">in</span> t_grid[<span class="sc">-</span><span class="dv">1</span>]) {                <span class="co"># for each time point</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    prev_Y <span class="ot">&lt;-</span> <span class="fu">filter</span>(Y[[i]],            <span class="co"># get Y at t - 1</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>                     t <span class="sc">==</span> j <span class="sc">-</span> <span class="dv">1</span>)<span class="sc">$</span>Y</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    eta <span class="ot">&lt;-</span> L <span class="sc">%*%</span> <span class="fu">rnorm</span>(N)               <span class="co"># simulate eta</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    new_Y <span class="ot">&lt;-</span> (M <span class="sc">%*%</span> prev_Y <span class="sc">*</span> ds <span class="sc">+</span> eta) <span class="sc">%&gt;%</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>             <span class="fu">as.numeric</span>()               <span class="co"># Euler approximation</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    Y[[i]] <span class="ot">&lt;-</span> <span class="fu">rbind</span>(Y[[i]],             <span class="co"># update data frame</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">data.frame</span>(<span class="at">s =</span> s_grid,</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>                               <span class="at">t =</span> j,</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>                               <span class="at">Y =</span>  new_Y))</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Repeatedly appending data frames, as is done above, is computationally inefficient. For large systems it would be quicker to save a data frame for each time point in another list and then concatenate using <code>rbindlist</code> from the package <strong>data.table</strong>.</p>
<p>Since now <code>Y[[i]]</code>, for <code>i</code><span class="math inline">\(\,=1,\ldots,4\)</span>, contains a data frame in long format, it is straightforward to visualize. The code given below constructs the Hovmöller plot for the IDE process for <code>i</code><span class="math inline">\(\,=1\)</span>. Plotting for <code>i</code><span class="math inline">\(\,=2,3,4\)</span> is left as an exercise for the reader. The resulting plots are shown in the bottom panels of <a href="#fig-DSTMdynamics" class="quarto-xref">Figure&nbsp;<span>5.2</span></a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(Y[[<span class="dv">1</span>]]) <span class="sc">+</span> <span class="fu">geom_tile</span>(<span class="fu">aes</span>(s, t, <span class="at">fill =</span> Y)) <span class="sc">+</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">scale_y_reverse</span>() <span class="sc">+</span> <span class="fu">theme_bw</span>() <span class="sc">+</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fill_scale</span>(<span class="at">name =</span> <span class="st">"Y"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="simulating-observations" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="simulating-observations">Simulating Observations</h3>
<p>Now assume that we want to simulate noisy observations from one of the process models that we have just simulated from. Why would we want to do this? Frequently, the only way to test whether algorithms for inference are working as they should is to mimic both the underlying true process <em>and</em> the measurement process. Working with simulated data is the first step in developing reliable algorithms that are then ready to be applied to real data.</p>
<p>To map the observations to the data, we need an incidence matrix that picks out the process value that has been observed. This incidence matrix is simply composed of several rows, one for each observation, with zeros everywhere except for the entry corresponding to the process value that has been observed (recall <a href="#sec-DataLGDSTM" class="quarto-xref"><span>Section 5.2.1</span></a>). When the locations we are observing change over time, the incidence matrix correspondingly changes over time.</p>
<p>Suppose that at each time point we observe the process at 50 locations which, for convenience, are a subset of <code>s_grid</code>. (If this is not the case, some nearest-neighbor mapping or deterministic interpolation method can be used.)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>nobs <span class="ot">&lt;-</span> <span class="dv">50</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>sobs <span class="ot">&lt;-</span> <span class="fu">sample</span>(s_grid, nobs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then the incidence matrix at time <span class="math inline">\(t\)</span>, <span class="math inline">\(\mathbf{H}_t\)</span>, can be constructed by matching the observation locations on the space-time grid using the function <code>which</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>Ht <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, nobs, N)           <span class="co"># construct empty matrix</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nobs) {                 <span class="co"># for each obs</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  idx <span class="ot">&lt;-</span> <span class="fu">which</span>(sobs[i] <span class="sc">==</span> s_grid)  <span class="co"># find the element to set to 1</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  Ht[i, idx] <span class="ot">&lt;-</span> <span class="dv">1</span>                  <span class="co"># set to 1</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note that <code>Ht</code> is sparse (contains many zeros), so sparse-matrix representations can be used to improve computational and memory efficiency; look up the packages <strong>Matrix</strong> or <strong>spam</strong> for more information on these representations.</p>
<p>We can repeat this procedure for every time point to simulate our data. At time <span class="math inline">\(t\)</span>, the data are given by <span class="math inline">\(\mathbf{Z}_t = \mathbf{H}_t\mathbf{Y}_t + \boldsymbol{\varepsilon}_t\)</span>, where <span class="math inline">\(\mathbf{Y}_t\)</span> is the latent process on the grid at time <span class="math inline">\(t\)</span>, and <span class="math inline">\(\boldsymbol{\varepsilon}_t\)</span> is independent of <span class="math inline">\(\mathbf{Y}_t\)</span> and represents a Gaussian random vector whose entries are <span class="math inline">\(iid\)</span> with mean zero and variance <span class="math inline">\(\sigma^2_\epsilon\)</span>. Assume <span class="math inline">\(\sigma^2_\epsilon = 1\)</span> and that <span class="math inline">\(\mathbf{H}_t\)</span> is the same for each <span class="math inline">\(t\)</span>. Then observations are simulated using the following <code>for</code> loop.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>z_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>()               <span class="co"># init data frame</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">0</span><span class="sc">:</span>(nT<span class="dv">-1</span>)) {               <span class="co"># for each time point</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  Yt <span class="ot">&lt;-</span> <span class="fu">filter</span>(Y[[<span class="dv">1</span>]], t <span class="sc">==</span> j)<span class="sc">$</span>Y   <span class="co"># get the simulated process</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  zt <span class="ot">&lt;-</span> Ht <span class="sc">%*%</span> Yt <span class="sc">+</span> <span class="fu">rnorm</span>(nobs)    <span class="co"># map to obs and add noise</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  z_df <span class="ot">&lt;-</span> <span class="fu">rbind</span>(z_df,              <span class="co"># update data frame</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>                <span class="fu">data.frame</span>(<span class="at">s =</span> sobs, <span class="at">t =</span> j, <span class="at">z =</span> zt))</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Plotting of the simulated observations proceeds using <strong>ggplot2</strong> as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(z_df) <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="fu">aes</span>(s, t, <span class="at">colour =</span> z))  <span class="sc">+</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">col_scale</span>(<span class="at">name =</span> <span class="st">"z"</span>) <span class="sc">+</span> <span class="fu">scale_y_reverse</span>() <span class="sc">+</span> <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note that the observations are noisy and reveal sizeable gaps. Filling in these gaps by first estimating all the parameters in the IDE from the data and then predicting at unobserved locations is the subject of Lab 5.2.</p>
</section>
</section>
<section id="lab-5.2-spatio-temporal-inference-using-the-ide-model" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="lab-5.2-spatio-temporal-inference-using-the-ide-model">Lab 5.2: Spatio-Temporal Inference using the IDE Model</h2>
<p>In this Lab we use the package <strong>IDE</strong> to fit spatio-temporal IDE models as well as predict and forecast from spatio-temporal data. We explore three cases. The first two cases consider simulated data where the true model is known, and the third considers the Sydney radar data set described in Chapter 2.</p>
<p>For this Lab, we need the package <strong>IDE</strong> and also the package <strong>FRK</strong>, which will be used to construct basis functions to model the spatially varying parameters of the kernel. In addition, we shall use the package <strong>plyr</strong> for binding data frames with unequal column number later on in the Lab.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"plyr"</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"dplyr"</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"IDE"</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"FRK"</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggplot2"</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"sp"</span>)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"spacetime"</span>)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"STRbook"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The kernel <span class="math inline">\(m(\mathbf{s},\mathbf{x};\boldsymbol{\theta}_p)\)</span> used by the package <strong>IDE</strong> is given by</p>
<p><span id="eq-linearIDEm_kernel"><span class="math display">\[
m(\mathbf{s},\mathbf{x};\boldsymbol{\theta}_p) = {\theta_{p,1}(\mathbf{s})} \exp\left(-\frac{1}{\theta_{p,2}(\mathbf{s})}\left[(x_1 - \theta_{p,3}(\mathbf{s}) - s_1)^2 + (x_2 - \theta_{p,4}(\mathbf{s}) - s_2)^2 \right] \right),
\tag{5.23}\]</span></span></p>
<p>where <span class="math inline">\(\theta_{p,1}(\mathbf{s})\)</span> is the spatially varying amplitude, <span class="math inline">\(\theta_{p,2}(\mathbf{s})\)</span> is the spatially varying kernel aperture (or width), and the mean (shift) parameters <span class="math inline">\(\theta_{p,3}(\mathbf{s})\)</span> and <span class="math inline">\(\theta_{p,4}(\mathbf{s})\)</span> correspond to a spatially varying shift of the kernel relative to location <span class="math inline">\(\mathbf{s}\)</span>. Spatially invariant kernels (i.e., where the elements of <span class="math inline">\(\boldsymbol{\theta}_p\)</span> are not functions of space) are also allowed.</p>
<p>The package <strong>IDE</strong> uses a bisquare spatial-basis-function decomposition for both the process <span class="math inline">\(Y_t(\cdot)\)</span> and the spatial process <span class="math inline">\(\eta_t(\cdot)\)</span>, <span class="math inline">\(t = 1,2,\dots.\)</span> The covariance matrix of the basis-function coefficients associated with <span class="math inline">\(\eta_t(\cdot)\)</span> is assumed to be proportional to the identity matrix, where the constant of proportionality is estimated. In <strong>IDE</strong>, the latent process <span class="math inline">\(\widetilde{Y}_t(\mathbf{s})\)</span> is the IDE dynamical process superimposed on some fixed effects, which can be expressed as a linear combination of known covariates <span class="math inline">\(\mathbf{x}_t(\mathbf{s})\)</span>,</p>
<p><span id="eq-YtildeLab"><span class="math display">\[
\widetilde{Y_t}(\mathbf{s}) = \mathbf{x}_t(\mathbf{s})'\boldsymbol{\beta}+ Y_t(\mathbf{s});\quad \mathbf{s}\in D_s,
\tag{5.24}\]</span></span></p>
<p>for <span class="math inline">\(t = 1,2,\dots\)</span>, where <span class="math inline">\(\boldsymbol{\beta}\)</span> are regression coefficients. The data vector <span class="math inline">\(\mathbf{Z}_t \equiv (Z_t(\mathbf{r}_{1}),\dots,Z_t(\mathbf{r}_{m_t}))'\)</span> is then the latent process observed with noise,</p>
<p><span class="math display">\[
Z_t(\mathbf{r}_{j}) = \widetilde{Y}_t(\mathbf{r}_{j}) + \epsilon_t(\mathbf{r}_{j}),\quad j = 1,\dots,m_t,
\]</span></p>
<p>for <span class="math inline">\(t = 1,2,\dots\)</span>, where <span class="math inline">\(\epsilon_t(\mathbf{r}_{j}) \sim iid\,Gau(0, \sigma^2_\epsilon)\)</span>.</p>
<section id="simulation-example-with-a-spatially-invariant-kernel" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="simulation-example-with-a-spatially-invariant-kernel">Simulation Example with a Spatially Invariant Kernel</h3>
<p>The package <strong>IDE</strong> contains a function <code>simIDE</code> that simulates the behavior of a typical dynamic system governed by linear transport. The function can simulate from a user-defined IDE model, or from a pre-defined one. In the latter case, the number of time points to simulate (<code>T</code>), the number of (spatially fixed) observations to use (<code>nobs</code>), and a flag indicating whether to use a spatially invariant kernel (<code>k_spat_invariant = 1</code>) or not (<code>k_spat_invariant = 0</code>), need to be provided. The pre-defined model includes a linear trend in <span class="math inline">\(s_1\)</span> and <span class="math inline">\(s_2\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>SIM1 <span class="ot">&lt;-</span> <span class="fu">simIDE</span>(<span class="at">T =</span> <span class="dv">10</span>, <span class="at">nobs =</span> <span class="dv">100</span>, <span class="at">k_spat_invariant =</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The returned list <code>SIM1</code> contains the simulated process in the data frame <code>s_df</code>, the observed data in the data frame <code>z_df</code>, and the observed data as an <code>STIDF</code> object <code>z_STIDF</code>. It also contains two <strong>ggplot2</strong> plots, <code>g_truth</code> and <code>g_obs</code>, which can be readily plotted as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(SIM1<span class="sc">$</span>g_truth)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(SIM1<span class="sc">$</span>g_obs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>While the action of the transport is clearly noticeable in the evolution of the process, there is also a clear spatial trend. Covariates are included through the use of a standard <code>R</code> formula when calling the function <code>IDE</code>. Additional arguments to <code>IDE</code> include the data set, which needs to be of class <code>STIDF</code>, the temporal discretization to use (we will use 1 day) of class <code>difftime</code>, and the resolution of the grid upon which the integrations (as well as predictions) will be carried out. Other arguments include user-specified basis functions for the process and what transition kernel will be used, which for now we do not specify. By default, the IDE model will decompose the process using two resolutions of bisquare basis functions and will assume a spatially invariant Gaussian transition kernel.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>IDEmodel <span class="ot">&lt;-</span> <span class="fu">IDE</span>(<span class="at">f =</span> z <span class="sc">~</span> s1 <span class="sc">+</span> s2,</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">data =</span> SIM1<span class="sc">$</span>z_STIDF,</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">dt =</span> <span class="fu">as.difftime</span>(<span class="dv">1</span>, <span class="at">units =</span> <span class="st">"days"</span>),</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">grid_size =</span> <span class="dv">41</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The returned object <code>IDEmodel</code> is of class <code>IDE</code> and contains initial parameter estimates, as well as predictions of <span class="math inline">\(\boldsymbol{\alpha}_t,\)</span> for <span class="math inline">\(t = 1,\dots,T\)</span>, at these initial parameter estimates. The parameters in this case are the measurement-error variance, the variance of the random disturbance <span class="math inline">\(\eta_t(\cdot)\)</span> (whose covariance structure is fixed), the kernel parameters, and the regression coefficients <span class="math inline">\(\boldsymbol{\beta}\)</span>.</p>
<p>Estimating the parameters in the IDE model using maximum likelihood is a computationally intensive procedure. The default method currently implemented uses a differential evolution optimization algorithm from the package <strong>DEoptim</strong>, which is a global optimization algorithm that can be easily parallelized. Fitting takes only a few minutes on a 60-core high-performance computer, but can take an hour or two on a standard desktop computer. Fitting can be done by running the following code.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>fit_results_sim1 <span class="ot">&lt;-</span> <span class="fu">fit.IDE</span>(IDEmodel,</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>                           <span class="at">parallelType =</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here <code>parallelType = 1</code> ensures that all available cores on the computer are used for fitting. Alternatively, the results can be loaded from cache using the following command.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"IDE_Sim1_results"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The list <code>fit_results_sim1</code> contains two fields: <code>optim_results</code> that contains the output of the optimization algorithm, and <code>IDEmodel</code> that contains the fitted IDE model. The fitted kernel can be visualized by using the function <code>show_kernel</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">show_kernel</span>(fit_results_sim1<span class="sc">$</span>IDEmodel)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note how the fitted kernel is shifted to the left and upwards, correctly representing the southeasterly transport evident in the data. The estimated kernel parameters <span class="math inline">\(\boldsymbol{\theta}_p\)</span> are given below.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>fit_results_sim1<span class="sc">$</span>IDEmodel<span class="sc">$</span><span class="fu">get</span>(<span class="st">"k"</span>) <span class="sc">%&gt;%</span> <span class="fu">unlist</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>         par1          par2          par3          par4 
152.836345912   0.001977115  -0.101601099   0.100368743 </code></pre>
</div>
</div>
<p>These estimates compare well to the true values <code>c(150, 0.002, -0.1, 0.1)</code> (see the help file for <code>simIDE</code>). The estimated regression coefficients are given below.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">coef</span>(fit_results_sim1<span class="sc">$</span>IDEmodel)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Intercept        s1        s2 
0.2073442 0.1966224 0.1907062 </code></pre>
</div>
</div>
<p>These also compare well to the true values <code>c(0.2, 0.2, 0.2)</code>. Also of interest are the moduli of the possibly complex eigenvalues of the evolution matrix <span class="math inline">\(\mathbf{M}\)</span>. These can be extracted as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>abs_ev <span class="ot">&lt;-</span> <span class="fu">eigen</span>(fit_results_sim1<span class="sc">$</span>IDEmodel<span class="sc">$</span><span class="fu">get</span>(<span class="st">"M"</span>))<span class="sc">$</span>values <span class="sc">%&gt;%</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>          <span class="fu">abs</span>()</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(abs_ev)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
0.00285 0.28953 0.36604 0.33107 0.39853 0.46409 </code></pre>
</div>
</div>
<p>Since the largest of these is less than 1, the IDE exhibits stable behavior.</p>
<p>For prediction, one may either specify a prediction grid or use the default one used for approximating the integrations set up by <code>IDE</code>. The latter is usually sufficient, so we use this without exception for the examples we consider. When a prediction grid is not supplied, the function <code>predict</code> returns a data frame with predictions spanning the temporal extent of the data (forecasts and hindcasts are explored later).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>ST_grid_df <span class="ot">&lt;-</span> <span class="fu">predict</span>(fit_results_sim1<span class="sc">$</span>IDEmodel)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The prediction map and prediction-standard-error map can now be plotted using standard <strong>ggplot2</strong> commands as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>gpred <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(ST_grid_df) <span class="sc">+</span>       <span class="co"># Plot the predictions</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_tile</span>(<span class="fu">aes</span>(s1, s2, <span class="at">fill=</span>Ypred)) <span class="sc">+</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span>t) <span class="sc">+</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fill_scale</span>(<span class="at">name =</span> <span class="st">"Ypred"</span>, <span class="at">limits =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.1</span>, <span class="fl">1.4</span>)) <span class="sc">+</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_fixed</span>(<span class="at">xlim=</span><span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>), <span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>))</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>gpredse <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(ST_grid_df) <span class="sc">+</span>     <span class="co"># Plot the prediction s.es</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_tile</span>(<span class="fu">aes</span>(s1, s2, <span class="at">fill =</span> Ypredse)) <span class="sc">+</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span>t) <span class="sc">+</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fill_scale</span>(<span class="at">name =</span> <span class="st">"Ypredse"</span>) <span class="sc">+</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_fixed</span>(<span class="at">xlim=</span><span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>), <span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In <a href="#fig-IDEsimresults" class="quarto-xref">Figure&nbsp;<span>5.4</span></a>, we show the observations, the true process, the predictions, and the prediction standard errors from the fitted model. Notice that the prediction standard errors are large in regions of sparse observations, as expected.</p>
<div id="fig-IDEsimresults" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-IDEsimresults-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_5/IDEsimresults.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-IDEsimresults-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.4: Simulated process (top left), simulated data (top right), predictions following the fitting of the IDE model (bottom left) and the respective prediction standard errors (bottom right).
</figcaption>
</figure>
</div>
</section>
<section id="simulation-example-with-a-spatially-varying-kernel" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="simulation-example-with-a-spatially-varying-kernel">Simulation Example with a Spatially Varying Kernel</h3>
<p>In the previous example we considered the case of a spatially invariant kernel, that is, the case when the kernel <span class="math inline">\(m(\mathbf{s},\mathbf{x};\boldsymbol{\theta}_p)\)</span> is just a function of <span class="math inline">\(\mathbf{x}- \mathbf{s}\)</span>. In this example, we consider the case when one or more of the <span class="math inline">\(\boldsymbol{\theta}_p\)</span> are allowed to be spatially referenced. Such models are needed when the spatio-temporal process exhibits, for example, considerable spatially varying drift (i.e., advection). Such a process can be simulated using the function <code>simIDE</code> by specifying <code>k_spat_invariant = 0</code>. To model data from a process of this sort, we need to have a large <code>nobs</code> and many time points; we set <code>T = 15</code>. This is important, as it is difficult to obtain reasonable estimates of spatially distributed parameters unless the data cover a large part of the spatial domain for a sustained amount of time.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>SIM2 <span class="ot">&lt;-</span> <span class="fu">simIDE</span>(<span class="at">T =</span> <span class="dv">15</span>, <span class="at">nobs =</span> <span class="dv">1000</span>, <span class="at">k_spat_invariant =</span> <span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As above, the process and the observed data can be plotted as two <strong>ggplot2</strong> plots.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(SIM2<span class="sc">$</span>g_truth)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(SIM2<span class="sc">$</span>g_obs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note how the process appears to rotate quickly counter-clockwise and come to a nearly complete standstill towards the lower part of the domain. The spatially varying advection that generated this field can be visualized using the following command.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">show_kernel</span>(SIM2<span class="sc">$</span>IDEmodel, <span class="at">scale =</span> <span class="fl">0.2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In this command, the argument <code>scale</code> is used to scale the arrow sizes by 0.2; that is, the shift per time point is five times the displacement indicated by the arrow.</p>
<p>Spatially varying kernels can be introduced by specifying the argument <code>kernel_basis</code> inside the call to <strong>IDE</strong>. The basis functions that <strong>IDE</strong> uses are of the same class as those used by <strong>FRK</strong>. We construct nine bisquare basis functions below that are equally spaced in the domain.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>mbasis_1 <span class="ot">&lt;-</span> <span class="fu">auto_basis</span>(<span class="at">manifold =</span> <span class="fu">plane</span>(),   <span class="co"># fns on the plane</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>                       <span class="at">data =</span> SIM2<span class="sc">$</span>z_STIDF,  <span class="co"># data</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>                       <span class="at">nres =</span> <span class="dv">1</span>,             <span class="co"># 1 resolution</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>                       <span class="at">type =</span> <span class="st">'bisquare'</span>)    <span class="co"># type of functions</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To plot these basis functions, type <code>show_basis(mbasis_1)</code>.</p>
<p>Now, recall that <span class="math inline">\(\theta_{p,1}\)</span> (identified as <code>thetam1</code> in <strong>IDE</strong>) corresponds to the amplitude of the kernel, <span class="math inline">\(\theta_{p,2}\)</span> (<code>thetam2</code>) to the scale (width) or aperture, <span class="math inline">\(\theta_{p,3}\)</span> (<code>thetam3</code>) to the horizontal drift, and <span class="math inline">\(\theta_{p,4}\)</span> (<code>thetam4</code>) to the vertical drift. In what follows, suppose that <span class="math inline">\(\theta_{p,1}\)</span> and <span class="math inline">\(\theta_{p,2}\)</span> are spatially invariant (usually a reasonable assumption), and decompose <span class="math inline">\(\theta_{p,3}\)</span> and <span class="math inline">\(\theta_{p,4}\)</span> as sums of basis functions given in <code>mbasis_1</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>kernel_basis <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">thetam1 =</span> <span class="fu">constant_basis</span>(),</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>                     <span class="at">thetam2 =</span> <span class="fu">constant_basis</span>(),</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>                     <span class="at">thetam3 =</span> mbasis_1,</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>                     <span class="at">thetam4 =</span> mbasis_1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Modeling proceeds as before, except that now we specify the argument <code>kernel_basis</code> when calling <code>IDE</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>IDEmodel <span class="ot">&lt;-</span> <span class="fu">IDE</span>(<span class="at">f =</span> z <span class="sc">~</span> s1 <span class="sc">+</span> s2 <span class="sc">+</span> <span class="dv">1</span>,</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">data =</span> SIM2<span class="sc">$</span>z_STIDF,</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">dt =</span> <span class="fu">as.difftime</span>(<span class="dv">1</span>, <span class="at">units =</span> <span class="st">"days"</span>),</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">grid_size =</span> <span class="dv">41</span>,</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>                <span class="at">kernel_basis =</span> kernel_basis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Fitting also proceeds by calling the function <code>fit.IDE</code>. We use the argument <code>itermax = 400</code> below to specify the maximum number of iterations for the optimization routine to use.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>fit_results_sim2 <span class="ot">&lt;-</span> <span class="fu">fit.IDE</span>(IDEmodel,</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>                           <span class="at">parallelType =</span> <span class="dv">1</span>,</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>                           <span class="at">itermax =</span> <span class="dv">400</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As above, since this is computationally intensive, we provide cached results that can be loaded using the following command.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"IDE_Sim2_results"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The fitted spatially varying kernel can be visualized using the following command.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">show_kernel</span>(fit_results_sim2<span class="sc">$</span>IDEmodel)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The true and fitted spatially varying drift parameters are shown side by side in <a href="#fig-Sim2kernels" class="quarto-xref">Figure&nbsp;<span>5.5</span></a>. Note how the fitted drifts capture the broad directions and magnitudes of the true underlying process. Predictions and prediction standard errors can be obtained and mapped using <code>predict</code> as above. This is left as an exercise for the reader.</p>
<div id="fig-Sim2kernels" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-Sim2kernels-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_5/kernels_sim2.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-Sim2kernels-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.5: True drifts (left) and estimated drifts (right).
</figcaption>
</figure>
</div>
</section>
<section id="the-sydney-radar-data-set" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="the-sydney-radar-data-set">The Sydney Radar Data Set</h3>
<p>Analysis of the Sydney radar data set proceeds in much the same way as in the simulation examples. In this case, we choose to have a spatially invariant kernel, since the data are not suggestive of spatially varying dynamics. We first load the Sydney radar data set as an <code>STIDF</code> object.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"radar_STIDF"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As was seen in Chapter 2, the Sydney radar data set exhibits clear movement (drift), making the IDE a good modeling choice for these data. We now call the function <code>IDE</code> as before, with the added arguments <code>hindcast</code> and <code>forecast</code>, which indicate how many time intervals into the past, and how many into the future, we wish to predict for periods preceding the training period (hindcast) and periods following the training period (forecast), respectively (see <a href="Chapter6.html#sec-ValCrosVal" class="quarto-xref"><span>Section 6.1.3</span></a> for more information on hindcasts and forecasts). In this case the data are at 10-minute intervals (one period), and we forecast and hindcast for two periods each (i.e., 20 minutes).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>IDEmodel <span class="ot">&lt;-</span> <span class="fu">IDE</span>(<span class="at">f =</span> z <span class="sc">~</span> <span class="dv">1</span>,</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">data =</span> radar_STIDF,</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">dt =</span> <span class="fu">as.difftime</span>(<span class="dv">10</span>, <span class="at">units =</span> <span class="st">"mins"</span>),</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">grid_size =</span> <span class="dv">41</span>,</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>                <span class="at">forecast =</span> <span class="dv">2</span>,</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>                <span class="at">hindcast =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Fitting proceeds by calling <code>fit.IDE</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>fit_results_radar <span class="ot">&lt;-</span> <span class="fu">fit.IDE</span>(IDEmodel,</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>                             <span class="at">parallelType =</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Since this command will take a considerable amount of time on a standard machine, we load the results directly from cache.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"IDE_Radar_results"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The fitted kernel can be visualized as it was above.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="fu">show_kernel</span>(fit_results_radar<span class="sc">$</span>IDEmodel)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The kernel is again clearly shifted off-center and suggestive of transport in a predominantly easterly (and slightly northerly) direction. This is corroborated by visual inspection of the data. The estimated shift parameters are as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>shift_pars <span class="ot">&lt;-</span> (fit_results_radar<span class="sc">$</span>IDEmodel<span class="sc">$</span><span class="fu">get</span>(<span class="st">"k"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>                   <span class="fu">unlist</span>())[<span class="dv">3</span><span class="sc">:</span><span class="dv">4</span>]</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(shift_pars)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>par3 par4 
-5.5 -1.9 </code></pre>
</div>
</div>
<p>The magnitude of the estimated shift vector is hence indicative of a transport of <span class="math inline">\(\sqrt{(5.5)^2 + (1.9)^2} = 5.82\)</span> km per 10-minute period, or 34.91 km per hour.</p>
<p>The modulus of the possibly complex eigenvalues of the evolution matrix <span class="math inline">\(\mathbf{M}\)</span> can be extracted as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>abs_ev <span class="ot">&lt;-</span> <span class="fu">eigen</span>(fit_results_radar<span class="sc">$</span>IDEmodel<span class="sc">$</span><span class="fu">get</span>(<span class="st">"M"</span>))<span class="sc">$</span>values <span class="sc">%&gt;%</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>          <span class="fu">abs</span>()</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(abs_ev)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.01    0.58    0.67    0.62    0.72    0.79 </code></pre>
</div>
</div>
<p>The largest absolute eigenvalue is considerably larger than that in the simulation study, suggesting more field persistence (although, since it is less than 1, the process is still stable). This persistence is expected, since the data clearly show patches of precipitation that are sustained and transported, rather than decaying, over time.</p>
<p>When calling the function <code>IDE</code>, we set up the object to be able to forecast 20 minutes into the future and hindcast 20 minutes into the past. These forecasts and hindcasts will be in the object returned from <code>predict</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>ST_grid_df <span class="ot">&lt;-</span> <span class="fu">predict</span>(fit_results_radar<span class="sc">$</span>IDEmodel)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The data frame <code>ST_grid_df</code> contains the predictions in the field <code>Ypred</code> and the prediction standard errors in the field <code>Ypredse</code>. The field <code>t</code>, in both our data and predictions, contains the date as well as the time; we now create another field <code>time</code> that contains just the time of day.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>radar_df<span class="sc">$</span>time <span class="ot">&lt;-</span> <span class="fu">format</span>(radar_df<span class="sc">$</span>t, <span class="st">"%H:%M"</span>)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>ST_grid_df<span class="sc">$</span>time <span class="ot">&lt;-</span> <span class="fu">format</span>(ST_grid_df<span class="sc">$</span>t, <span class="st">"%H:%M"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The code given below plots the data as well as the smoothed fields containing the hindcasts, the predictions, and the forecasts. So that we match the data plots with the prediction plots, timewise, we create empty fields corresponding to hindcast and forecast periods in the data frame containing the observations. This can be achieved easily using <code>rbind.fill</code> from the package <strong>plyr</strong>.</p>
<div id="fig-IDEradarresults" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-IDEradarresults-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_5/IDEradarresults.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-IDEradarresults-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.6: Observed data (left), and hindcasts, predictions, and forecasts using the IDE model (right).
</figcaption>
</figure>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Add time records with missing data</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>radar_df <span class="ot">&lt;-</span> <span class="fu">rbind.fill</span>(radar_df,</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>                       <span class="fu">data.frame</span>(<span class="at">time =</span> <span class="fu">c</span>(<span class="st">"08:05"</span>, <span class="st">"08:15"</span>,</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>                                           <span class="st">"10:25"</span>, <span class="st">"10:35"</span>)))</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a><span class="do">## Plot of data, with color scale capped to (-20, 60)</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>gobs <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(radar_df) <span class="sc">+</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_tile</span>(<span class="fu">aes</span>(s1, s2, <span class="at">fill =</span> <span class="fu">pmin</span>(<span class="fu">pmax</span>(z, <span class="sc">-</span><span class="dv">20</span>), <span class="dv">60</span>))) <span class="sc">+</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fill_scale</span>(<span class="at">limits =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">20</span>, <span class="dv">60</span>), <span class="at">name =</span> <span class="st">"Z"</span>) <span class="sc">+</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span>time) <span class="sc">+</span> <span class="fu">coord_fixed</span>() <span class="sc">+</span> <span class="fu">theme_bw</span>()</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a><span class="do">## Plot of predictions with color scale forced to (-20, 60)</span></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>gpred <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(ST_grid_df) <span class="sc">+</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_tile</span>(<span class="fu">aes</span>(s1, s2, <span class="at">fill =</span> Ypred)) <span class="sc">+</span></span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span>time) <span class="sc">+</span> <span class="fu">coord_fixed</span>() <span class="sc">+</span> <span class="fu">theme_bw</span>() <span class="sc">+</span></span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fill_scale</span>(<span class="at">limits =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">20</span>, <span class="dv">60</span>), <span class="at">name =</span> <span class="st">"Ypred"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The plots are shown in <a href="#fig-IDEradarresults" class="quarto-xref">Figure&nbsp;<span>5.6</span></a>. Notice how both the forecasts and the hindcasts incorporate the information on transport that is evident in the data. We did not plot prediction standard errors in this case, which is left as an exercise for the reader.</p>
</section>
</section>
<section id="lab-5.3-spatio-temporal-inference-with-unknown-evolution-operator" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="lab-5.3-spatio-temporal-inference-with-unknown-evolution-operator">Lab 5.3: Spatio-Temporal Inference with Unknown Evolution Operator</h2>
<p>If we have no prior knowledge to guide us on how to parameterize <span class="math inline">\(\mathbf{M}\)</span>, then <span class="math inline">\(\mathbf{M}\)</span> can be estimated in full in the context of a standard state-space modeling framework. When taking this approach, it is important that a very low-dimensional representation of the spatio-temporal process is adopted – the dimension of the parameter space increases quadratically with the dimension of the process, and thus the model can easily become over-parameterized.</p>
<p>Empirical orthogonal functions (EOFs) are ideal basis functions to use in this case, since they capture most of the variability in the observed signal, by design. In this Lab we look at the SST data set, take the EOFs that we generated in Lab 2.3, and estimate all unknown parameters, first within a classical time-series framework based on a vector autoregression and using the method of moments (see <a href="ChapterAppendixC.html#sec-estimationMoM" class="quarto-xref"><span>Section C.1</span></a>), and then in a state-space framework using the EM algorithm (see <a href="ChapterAppendixC.html#sec-estimationLDSTM" class="quarto-xref"><span>Section C.2</span></a>).</p>
<section id="time-series-framework" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="time-series-framework">Time-Series Framework</h3>
<p>The aim of this first part of the Lab is to show how even simple methods can be used in a dynamical setting to provide prediction and prediction standard errors on a variable of interest. These methods work particularly well when we have complete spatial coverage and a high signal-to-noise ratio; this is the case with the SST data.</p>
<p>First, we load the usual packages.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggplot2"</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"dplyr"</span>)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"STRbook"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then we load <strong>expm</strong> for raising matrices to a specified power and <strong>Matrix</strong>, which here we only use for plotting purposes.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"expm"</span>)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"Matrix"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We now load the SST data, but this time we truncate it at April 1997 in order to forecast the SSTs 6 months ahead, in October 1997.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"SSTlandmask"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"SSTlonlat"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"SSTdata"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>delete_rows <span class="ot">&lt;-</span> <span class="fu">which</span>(SSTlandmask <span class="sc">==</span> <span class="dv">1</span>)   <span class="co"># remove land values</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>SST_Oct97 <span class="ot">&lt;-</span> SSTdata[<span class="sc">-</span>delete_rows, <span class="dv">334</span>]  <span class="co"># save Oct 1997 SSTs</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>SSTdata <span class="ot">&lt;-</span> SSTdata[<span class="sc">-</span>delete_rows, <span class="dv">1</span><span class="sc">:</span><span class="dv">328</span>]  <span class="co"># until April 1997</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>SSTlonlat<span class="sc">$</span>mask <span class="ot">&lt;-</span> SSTlandmask            <span class="co"># assign mask to df</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, we construct the EOFs using only data up to April 1997. The following code follows closely what was done in Lab 2.3, where the entire data set was used.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>Z <span class="ot">&lt;-</span> <span class="fu">t</span>(SSTdata)                         <span class="co"># data matrix</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>spat_mean <span class="ot">&lt;-</span> <span class="fu">apply</span>(SSTdata, <span class="dv">1</span>, mean)    <span class="co"># spatial mean</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>nT <span class="ot">&lt;-</span> <span class="fu">ncol</span>(SSTdata)                     <span class="co"># no. of time points</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>Zspat_detrend <span class="ot">&lt;-</span> Z <span class="sc">-</span> <span class="fu">outer</span>(<span class="fu">rep</span>(<span class="dv">1</span>, nT),  <span class="co"># detrend data</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>                           spat_mean)</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>Zt <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span><span class="fu">sqrt</span>(nT<span class="dv">-1</span>)<span class="sc">*</span>Zspat_detrend        <span class="co"># normalize</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>E <span class="ot">&lt;-</span> <span class="fu">svd</span>(Zt)                            <span class="co"># SVD</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The number of EOFs we use here to model the SST data is <span class="math inline">\(n = 10\)</span>. These 10 leading EOFs capture 74% of the variability in the data.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">10</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Recall that the object <code>E</code> contains the SVD, that is, the matrices <span class="math inline">\(\mathbf{U}\)</span> and <span class="math inline">\(\mathbf{V}\)</span> and the singular values. The dimension-reduced time series of coefficients are given by the EOFs multiplied by the spatially detrended data, that is, <span class="math inline">\(\boldsymbol{\alpha}_t = \boldsymbol{\Phi}'(\mathbf{Z}_t - \hat{\boldsymbol{\mu}})\)</span>, <span class="math inline">\(t = 1,\dots,T\)</span>, where <span class="math inline">\(\hat{\boldsymbol{\mu}} = (1/T)\sum_{t=1}^T\mathbf{Z}_t\)</span> is the estimated spatial mean.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>TS <span class="ot">&lt;-</span> Zspat_detrend <span class="sc">%*%</span> E<span class="sc">$</span>v[, <span class="dv">1</span><span class="sc">:</span>n]</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(<span class="fu">colMeans</span>(TS))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
-4.33e-16 -5.80e-17  3.17e-16  2.99e-16  5.01e-16  1.53e-15 </code></pre>
</div>
</div>
<p>In the last line above, we have verified that the time series have mean zero, which is needed to compute covariances by taking outer products. Next, we estimate the matrices <span class="math inline">\(\mathbf{M}\)</span> and <span class="math inline">\(\mathbf{C}_\eta\)</span> using the method of moments. First we create two sets of time series that are shifted by <span class="math inline">\(\tau\)</span> time points with respect to each other; in this case we let <span class="math inline">\(\tau = 6,\)</span> so that we analyze dynamics on a six-month scale. The <span class="math inline">\(i\)</span>th column in <code>TStplustau</code> below corresponds to the time series at the <span class="math inline">\((i+6)\)</span>th time point, while that in <code>TSt</code> corresponds to the time series at <span class="math inline">\(i\)</span>th time point.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>tau <span class="ot">&lt;-</span> <span class="dv">6</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>nT <span class="ot">&lt;-</span> <span class="fu">nrow</span>(TS)</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>TStplustau <span class="ot">&lt;-</span> TS[<span class="sc">-</span>(<span class="dv">1</span><span class="sc">:</span>tau), ] <span class="co"># TS with first tau time pts removed</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>TSt <span class="ot">&lt;-</span> TS[<span class="sc">-</span>((nT<span class="dv">-5</span>)<span class="sc">:</span>nT), ]    <span class="co"># TS with last tau time pts removed</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The lag-0 empirical covariance matrix and the lag-<span class="math inline">\(\tau\)</span> empirical cross-covariance matrices are now computed by taking their matrix cross-product and dividing by the appropriate number of time points; see <a href="Chapter2.html#eq-emp_cov" class="quarto-xref">Equation&nbsp;<span>2.4</span></a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>Cov0 <span class="ot">&lt;-</span> <span class="fu">crossprod</span>(TS)<span class="sc">/</span>nT</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>Covtau <span class="ot">&lt;-</span> <span class="fu">crossprod</span>(TStplustau,TSt)<span class="sc">/</span>(nT <span class="sc">-</span> tau)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The estimates for <span class="math inline">\(\mathbf{M}\)</span> and <span class="math inline">\(\mathbf{C}_\eta\)</span> can now be estimated from these empirical covariance matrices. As discussed in <a href="ChapterAppendixC.html#sec-estimationMoM" class="quarto-xref"><span>Section C.1</span></a>, this can be done using the following code.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>C0inv <span class="ot">&lt;-</span> <span class="fu">solve</span>(Cov0)</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>Mest <span class="ot">&lt;-</span> Covtau <span class="sc">%*%</span> C0inv</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>Ceta <span class="ot">&lt;-</span> Cov0 <span class="sc">-</span> Covtau <span class="sc">%*%</span> C0inv <span class="sc">%*%</span> <span class="fu">t</span>(Covtau)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>There are more efficient ways to compute the quantities above that ensure symmetry and positive-definiteness of the results. In particular, the inverse rarely needs to be found explicitly. For further information, the interested reader is referred to standard books on linear algebra <span class="citation" data-cites="schott2016matrix">(see, for example, <a href="references.html#ref-schott2016matrix" role="doc-biblioref">Schott, 2017</a>)</span>.</p>
<p>The matrices can be visualized using the function <code>image</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="fu">image</span>(Mest)</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="fu">image</span>(Ceta)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>From visual inspection, the estimate of the propagator matrix, <code>Mest</code>, is by no means diagonally dominant, implying that there is benefit in assuming interactions between the EOFs across time steps (see <a href="#sec-ProcRed" class="quarto-xref"><span>Section 5.3.2</span></a>). Further, the estimated variances along the diagonal of the covariance matrix of the additive disturbance in the IDE model, <span class="math inline">\(\mathbf{C}_\eta\)</span>, decrease with the EOF index; this is expected as EOFs with higher indices tend to have higher-frequency components.</p>
<p>Forecasting using this EOF-reduced model is straightforward as we take the coefficients at the final time point, <span class="math inline">\(\boldsymbol{\alpha}_t\)</span>, propagate those forward, and re-project onto the original space. For example, <span class="math inline">\(\hat{\boldsymbol{\mu}} + \boldsymbol{\Phi}\mathbf{M}^2\boldsymbol{\alpha}_t\)</span> gives a one-year forecast. Matrix powers (which represent multiple matrix multiplications and do not come from elementwise multiplications) can be implemented using the operator <code>%^%</code> from the package <strong>expm</strong>; this will be used when we implement the state-space model below. Here we consider six-month-ahead forecasts; in the code below we project ahead the EOF coefficients of the time series at the 328th time point (which corresponds to April 1997) six months into the future.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>SSTlonlat<span class="sc">$</span>pred <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>alpha_forecast <span class="ot">&lt;-</span> Mest <span class="sc">%*%</span> TS[<span class="dv">328</span>, ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The projection onto the original space is done by pre-multiplying by the EOFs and adding back the estimated spatial mean (see <a href="ChapterAppendixC.html#sec-estimationMoM" class="quarto-xref"><span>Section C.1</span></a>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>idx <span class="ot">&lt;-</span> <span class="fu">which</span>(SSTlonlat<span class="sc">$</span>mask <span class="sc">==</span> <span class="dv">0</span>)</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>SSTlonlat<span class="sc">$</span>curr[idx]  <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(E<span class="sc">$</span>v[, <span class="dv">1</span><span class="sc">:</span>n] <span class="sc">%*%</span> TS[<span class="dv">328</span>, ] <span class="sc">+</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>                                       spat_mean)</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>SSTlonlat<span class="sc">$</span>pred[idx]  <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(E<span class="sc">$</span>v[, <span class="dv">1</span><span class="sc">:</span>n] <span class="sc">%*%</span> alpha_forecast <span class="sc">+</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>                                       spat_mean)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we add the data to the data frame for plotting purposes.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>SSTlonlat<span class="sc">$</span>obs1[idx]  <span class="ot">&lt;-</span> SSTdata[, <span class="dv">328</span>]</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>SSTlonlat<span class="sc">$</span>obs2[idx]  <span class="ot">&lt;-</span> SST_Oct97</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The six-month-ahead prediction variances can also be computed (see <a href="ChapterAppendixC.html#sec-estimationMoM" class="quarto-xref"><span>Section C.1</span></a>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>C <span class="ot">&lt;-</span> Mest <span class="sc">%*%</span> Cov0 <span class="sc">%*%</span> <span class="fu">t</span>(Mest) <span class="sc">+</span> Ceta</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The prediction variances are found by projecting the covariance matrix <code>C</code> onto the original space and extracting the diagonal elements. The prediction standard errors are the square root of the prediction variances and hence obtained as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>SSTlonlat<span class="sc">$</span>predse[idx] <span class="ot">&lt;-</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">sqrt</span>(<span class="fu">diag</span>(E<span class="sc">$</span>v[, <span class="dv">1</span><span class="sc">:</span>n] <span class="sc">%*%</span> C <span class="sc">%*%</span> <span class="fu">t</span>(E<span class="sc">$</span>v[, <span class="dv">1</span><span class="sc">:</span>n])))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Plotting proceeds in a straightforward fashion using <strong>ggplot2</strong>. In <a href="#fig-SST_MoM" class="quarto-xref">Figure&nbsp;<span>5.7</span></a> we show the April 1997 data and the EOF projection for that month, as well as the October 1997 data and the forecast for that month. From visual inspection, the El Niño pattern of high SSTs is captured but the predicted anomaly is too low. This result is qualitatively similar to what we obtained in Lab 3.3 using linear regression models.</p>
<div id="fig-SST_MoM" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-SST_MoM-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_5/SST_obs_curr.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-SST_MoM-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.7: Top: SST data for April 1997 (left) and October 1997 (right). Middle: the EOF projection for April 1997 (left), and the forecast for October 1997 (right). Note the different color scales for the predictions (up to 1<span class="math inline">\(^\circ\)</span>C) and for the observations (up to 5<span class="math inline">\(^\circ\)</span>C). Bottom: Prediction standard errors for the forecast.
</figcaption>
</figure>
</div>
</section>
<section id="state-space-framework" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="state-space-framework">State-Space Framework</h3>
<p>The function <code>DSTM_EM</code>, provided with the package <strong>STRbook</strong>, runs the EM algorithm that carries out maximum likelihood estimation in a state-space model. The function takes the data <code>Z</code>, the initial covariance <span class="math inline">\(\mathbf{C}_0\)</span> in <code>Cov0</code>, the initial state <span class="math inline">\(\boldsymbol{\mu}_0\)</span> in <code>muinit</code>, the evolution operator <span class="math inline">\(\mathbf{M}\)</span> in <code>M</code>, the covariance matrix <span class="math inline">\(\mathbf{C}_\eta\)</span> in <code>Ceta</code>, the measurement-error variance <span class="math inline">\(\sigma^2_\epsilon\)</span> in <code>sigma2_eps</code>, the matrix <span class="math inline">\(\mathbf{H}\)</span> in <code>H</code>, the maximum number of EM iterations in <code>itermax</code>, and the tolerance in <code>tol</code> (the tolerance is the smallest change in the log-likelihood, multiplied by <span class="math inline">\(2\)</span>, required across two consecutive iterations of the EM algorithm, before terminating). All parameters supplied to the function need to be initial guesses (usually those from the method of moments suffice); these will be updated using the EM algorithm.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>DSTM_Results <span class="ot">&lt;-</span> <span class="fu">DSTM_EM</span>(<span class="at">Z =</span> SSTdata,</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>                        <span class="at">Cov0 =</span> Cov0,</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>                        <span class="at">muinit =</span> <span class="fu">matrix</span>(<span class="dv">0</span>, n, <span class="dv">1</span>),</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>                        <span class="at">M =</span> Mest,</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>                        <span class="at">Ceta =</span> Ceta,</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>                        <span class="at">sigma2_eps =</span> <span class="fl">0.1</span>,</span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>                        <span class="at">H =</span> H <span class="ot">&lt;-</span> E<span class="sc">$</span>v[, <span class="dv">1</span><span class="sc">:</span>n],</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>                        <span class="at">itermax =</span> <span class="dv">10</span>,</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>                        <span class="at">tol =</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The returned object <code>DSTM_Results</code> contains the estimated parameters, the smoothed states and their covariances, and the complete-data negative log-likelihood. In this case, estimates of <span class="math inline">\(\{\boldsymbol{\alpha}_t\}\)</span> using the state-space framework are practically identical to those obtained using the time-series framework presented in the first part of the Lab. We plot estimates of <span class="math inline">\(\alpha_{1,t}\)</span>, <span class="math inline">\(\alpha_{2,t}\)</span>, and <span class="math inline">\(\alpha_{3,t}\)</span> below for the two methods; see <a href="#fig-alpha_compare" class="quarto-xref">Figure&nbsp;<span>5.8</span></a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>))</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>) {</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">plot</span>(DSTM_Results<span class="sc">$</span>alpha_smooth[i, ], <span class="at">type =</span> <span class="st">'l'</span>,</span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>       <span class="at">xlab =</span> <span class="st">"t"</span>, <span class="at">ylab =</span> <span class="fu">bquote</span>(alpha[.(i)]))</span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lines</span>(TS[, i], <span class="at">lty =</span> <span class="st">'dashed'</span>, <span class="at">col =</span> <span class="st">'red'</span>)</span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-alpha_compare" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-alpha_compare-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_5/alpha_compare.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-alpha_compare-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.8: Estimates of <span class="math inline">\(\alpha_{1,t}\)</span> (left), <span class="math inline">\(\alpha_{2,t}\)</span> (center), and <span class="math inline">\(\alpha_{3,t}\)</span> (right) using the method of moments (red dashed line) and the EM algorithm (black solid line).
</figcaption>
</figure>
</div>
<p>Let us turn now to inference on the parameters. From <a href="ChapterAppendixC.html#sec-estimationLDSTM" class="quarto-xref"><span>Section C.2</span></a> note that the EM algorithm utilizes a Kalman filter that processes the data one time period (e.g., month) at a time. (Recall that with the method of moments we let <span class="math inline">\(\tau = 6\)</span> months, so we estimated directly the state transitions over six months.) Therefore, inferences on the parameters and their interpretations differ considerably. For example, the left and right panels of <a href="#fig-M_compare" class="quarto-xref">Figure&nbsp;<span>5.9</span></a> show the estimates of the evolution matrix for the two methods. At first sight, it appears that the matrix estimated using the EM algorithm is indicating a random-walk behavior. However, if we multiply the matrix <span class="math inline">\(\mathbf{M}\)</span> by itself six times (which then describes the evolution over six months), we obtain something that is relatively similar to what was estimated using the method of moments using a time lag of <span class="math inline">\(\tau = 6\)</span> months.</p>
<p>To make the plots in <a href="#fig-M_compare" class="quarto-xref">Figure&nbsp;<span>5.9</span></a>, we first cast the matrices into objects of class <code>Matrix</code>. Note that using the function <code>image</code> on objects of class <code>matrix</code> generates similar plots that are, however, less informative. On the other hand, plots of <strong>Matrix</strong> objects are done using the function <code>levelplot</code> in the <strong>lattice</strong> package.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="fu">image</span>(<span class="fu">as</span>(DSTM_Results<span class="sc">$</span>Mest, <span class="st">"Matrix"</span>))</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="fu">image</span>(<span class="fu">as</span>(DSTM_Results<span class="sc">$</span>Mest <span class="sc">%^%</span> <span class="dv">6</span>, <span class="st">"Matrix"</span>))</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="fu">image</span>(<span class="fu">as</span>(Mest, <span class="st">"Matrix"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-M_compare" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-M_compare-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_5/M_EM_MoM_All.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-M_compare-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.9: Estimate of a one-step-ahead evolution operator using the EM algorithm (left); EM estimate raised to the sixth power (center); and estimate of the six-steps-ahead evolution operator using the method of moments (right).
</figcaption>
</figure>
</div>
<div id="fig-EM_Mom_Forecasts" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-EM_Mom_Forecasts-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_5/EM_Mom_Forecasts.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-EM_Mom_Forecasts-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5.10: Forecasts (left) and prediction standard errors (right) for the EOF coefficients in October 1997 using a lag-6 time-series model estimated using the method of moments (black) and a lag-1 state-space model estimated using the EM algorithm (red).
</figcaption>
</figure>
</div>
<p>Forecasting proceeds the same way as in the method of moments. Specifically, we take the last smoothed time point (which corresponds to April 1997) and use the EM-estimated one-month propagator matrix to forecast the SSTs six months ahead. This is implemented easily using a <code>for</code> loop.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>alpha <span class="ot">&lt;-</span> DSTM_Results<span class="sc">$</span>alpha_smooth[, nT]</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>P <span class="ot">&lt;-</span> DSTM_Results<span class="sc">$</span>Cov0</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(t <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>) {</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>   alpha <span class="ot">&lt;-</span> DSTM_Results<span class="sc">$</span>Mest <span class="sc">%*%</span> alpha</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>   P <span class="ot">&lt;-</span> DSTM_Results<span class="sc">$</span>Mest <span class="sc">%*%</span> P <span class="sc">%*%</span> <span class="fu">t</span>(DSTM_Results<span class="sc">$</span>Mest) <span class="sc">+</span></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>       DSTM_Results<span class="sc">$</span>Ceta</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>It is instructive to compare the predictions and the prediction standard errors of the forecasted EOF coefficients using the two models; see <a href="#fig-EM_Mom_Forecasts" class="quarto-xref">Figure&nbsp;<span>5.10</span></a>. While the prediction standard errors for the state-space model are slightly lower (which is expected since a measurement-error component of variability has been filtered out), it is remarkable that forecasts from the lag-6 time-series model are quite similar to those of the lag-1 state-space model. These two models and their respective inferences can be expected to differ when there is more nonlinearity in the process and/or the data are less complete in space and time.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(alpha_forecast, <span class="at">xlab =</span> <span class="st">"i"</span>,</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab =</span> <span class="fu">expression</span>(<span class="fu">hat</span>(alpha[i])), <span class="at">type =</span> <span class="st">'l'</span>)</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(alpha, <span class="at">col =</span> <span class="st">'red'</span>)</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">sqrt</span>(<span class="fu">diag</span>(C)), <span class="at">xlab =</span> <span class="st">"i"</span>,</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab =</span> <span class="fu">expression</span>(<span class="fu">s.e.</span>(<span class="fu">hat</span>(alpha[i]))), <span class="at">type =</span> <span class="st">'l'</span>)</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(<span class="fu">sqrt</span>(<span class="fu">diag</span>(P)), <span class="at">col =</span> <span class="st">'red'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In our concluding remarks, we remind the reader that in this Lab we considered a <em>linear</em> DSTM for modeling SSTs. Recent research has suggested that <em>nonlinear</em> DSTMs may provide superior prediction performance; see the case study in <a href="ChapterAppendixF.html" class="quarto-xref"><span>Appendix F</span></a>.</p>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" data-line-spacing="2" role="list" style="display: none">
<div id="ref-cressie2011statistics" class="csl-entry" role="listitem">
Cressie, N., &amp; Wikle, C. K. (2011). <em>Statistics for spatio-temporal data</em>. John Wiley &amp; Sons.
</div>
<div id="ref-douc2014nonlinear" class="csl-entry" role="listitem">
Douc, R., Moulines, E., &amp; Stoffer, D. (2014). <em>Nonlinear time series: Theory, methods and applications with <span>R</span> examples</em>. Chapman &amp; Hall/CRC.
</div>
<div id="ref-gamerman2006markov" class="csl-entry" role="listitem">
Gamerman, D., &amp; Lopes, H. F. (2006). <em>Markov chain monte carlo: Stochastic simulation for bayesian inference</em> (2nd ed.). Chapman &amp; Hall/CRC.
</div>
<div id="ref-goodfellow2016deep" class="csl-entry" role="listitem">
Goodfellow, I., Bengio, Y., Courville, A., &amp; Bengio, Y. (2016). <em>Deep learning</em>. MIT Press.
</div>
<div id="ref-lukovsevivcius2012practical" class="csl-entry" role="listitem">
Lukoševičius, M. (2012). A practical guide to applying echo state networks. In G. Montavon, G. B. Orr, &amp; K.-R. Müller (Eds.), <em>Neural networks: Tricks of the trade</em> (2nd ed., pp. 659–686). Springer.
</div>
<div id="ref-lukovsevivcius2009reservoir" class="csl-entry" role="listitem">
Lukoševičius, M., &amp; Jaeger, H. (2009). Reservoir computing approaches to recurrent neural network training. <em>Computer Science Review</em>, <em>3</em>(3), 127–149.
</div>
<div id="ref-mcdermott2016model" class="csl-entry" role="listitem">
McDermott, P. L., &amp; Wikle, C. K. (2016). A model-based approach for analog spatio-temporal dynamic forecasting. <em>Environmetrics</em>, <em>27</em>(2), 70–82.
</div>
<div id="ref-mcdermott2017ensemble" class="csl-entry" role="listitem">
McDermott, P. L., &amp; Wikle, C. K. (2017). An ensemble quadratic echo state network for non-linear spatio-temporal forecasting. <em>Stat</em>, <em>6</em>(1), 315–330.
</div>
<div id="ref-mcdermott2018hierarchical" class="csl-entry" role="listitem">
McDermott, P. L., Wikle, C. K., &amp; Millspaugh, J. (2018). A hierarchical spatiotemporal analog forecasting model for count data. <em>Ecology and Evolution</em>, <em>8</em>(1), 790–800.
</div>
<div id="ref-prado2010time" class="csl-entry" role="listitem">
Prado, R., &amp; West, M. (2010). <em>Time series: Modeling, computation, and inference</em>. Chapman &amp; Hall/CRC.
</div>
<div id="ref-rue2005gaussian" class="csl-entry" role="listitem">
Rue, H., &amp; Held, L. (2005). <em>Gaussian markov random fields: Theory and applications</em>. Chapman &amp; Hall/CRC.
</div>
<div id="ref-schott2016matrix" class="csl-entry" role="listitem">
Schott, J. R. (2017). <em>Matrix analysis for statistics</em> (3rd ed.). John Wiley &amp; Sons.
</div>
<div id="ref-shumway1982approach" class="csl-entry" role="listitem">
Shumway, R. H., &amp; Stoffer, D. S. (1982). An approach to time series smoothing and forecasting using the EM algorithm. <em>Journal of Time Series Analysis</em>, <em>3</em>(4), 253–264.
</div>
<div id="ref-shumway2006time" class="csl-entry" role="listitem">
Shumway, R. H., &amp; Stoffer, D. S. (2006). <em>Time series analysis and its applications with r examples</em> (2nd ed.). Springer.
</div>
<div id="ref-wikle2016hierarchical" class="csl-entry" role="listitem">
Wikle, C. K., &amp; Hooten, M. B. (2016). Hierarchical agent-based spatio-temporal dynamic models for discrete-valued data. In R. A. Davis, S. H. Holan, R. Lund, &amp; N. Ravishanker (Eds.), <em>Handbook of discrete-valued time series</em>. Chapman &amp; Hall/CRC.
</div>
</div>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chapter4.html" class="pagination-link" aria-label="Descriptive Spatio-Temporal Statistical Models">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Descriptive Spatio-Temporal Statistical Models</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Chapter6.html" class="pagination-link" aria-label="Evaluating Spatio-Temporal Statistical Models">
        <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Evaluating Spatio-Temporal Statistical Models</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>