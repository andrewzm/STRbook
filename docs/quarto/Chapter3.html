<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.28">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; Spatio-Temporal Statistical Models – Spatio-Temporal Statistics with R (1st edition)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Chapter4.html" rel="next">
<link href="./Chapter2.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-b719d3d4935f2b08311a76135e2bf442.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-7d2e1f8220df954187ab24ed36a0da9c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/quarto-contrib/foldbox/foldbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
.Algorithm {
  --color1: #948bde;
  --color2: #584eab;
}
</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Chapter3.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Spatio-Temporal Statistical Models</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Spatio-Temporal Statistics with R (1st edition)</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction to Spatio-Temporal Statistics</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Exploring Spatio-Temporal Data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter3.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Spatio-Temporal Statistical Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Descriptive Spatio-Temporal Statistical Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Dynamic Spatio-Temporal Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Evaluating Spatio-Temporal Statistical Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterPergimus.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Pergimus (Epilogue)</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixA.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Some Useful Matrix-Algebra Definitions and Properties</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixB.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">General Smoothing Kernels</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixC.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Estimation and Prediction for Dynamic Spatio-Temporal Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixD.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Mechanistically Motivated Dynamic Spatio-Temporal Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">Case Study: Physical-Statistical Bayesian Hierarchical Model for Predicting Mediterranean Surface Winds</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixF.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">Case Study: Quadratic Echo State Networks for Sea Surface Temperature Long-Lead Prediction</span></span></a>
  </div>
</li>
      </ul>
  </li>
  <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterRPackages.html" class="sidebar-item-text sidebar-link">
  <span class="menu-text">List of <code>R</code> packages</span></a>
  </div>
  </li>
  <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
  <span class="menu-text">References</span></a>
  </div>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-determ_pred" id="toc-sec-determ_pred" class="nav-link active" data-scroll-target="#sec-determ_pred"><span class="header-section-number">3.1</span> Spatio-Temporal Prediction</a></li>
  <li><a href="#sec-reg_pred" id="toc-sec-reg_pred" class="nav-link" data-scroll-target="#sec-reg_pred"><span class="header-section-number">3.2</span> Regression (Trend-Surface) Estimation</a>
  <ul class="collapse">
  <li><a href="#model-diagnostics-dependent-errors" id="toc-model-diagnostics-dependent-errors" class="nav-link" data-scroll-target="#model-diagnostics-dependent-errors"><span class="header-section-number">3.2.1</span> Model Diagnostics: Dependent Errors</a></li>
  <li><a href="#sec-STcovinf" id="toc-sec-STcovinf" class="nav-link" data-scroll-target="#sec-STcovinf"><span class="header-section-number">3.2.2</span> Parameter Inference for Spatio-Temporal Data</a></li>
  <li><a href="#variable-selection" id="toc-variable-selection" class="nav-link" data-scroll-target="#variable-selection"><span class="header-section-number">3.2.3</span> Variable Selection</a></li>
  </ul></li>
  <li><a href="#spatio-temporal-forecasting" id="toc-spatio-temporal-forecasting" class="nav-link" data-scroll-target="#spatio-temporal-forecasting"><span class="header-section-number">3.3</span> Spatio-Temporal Forecasting</a></li>
  <li><a href="#non-gaussian-errors" id="toc-non-gaussian-errors" class="nav-link" data-scroll-target="#non-gaussian-errors"><span class="header-section-number">3.4</span> Non-Gaussian Errors</a>
  <ul class="collapse">
  <li><a href="#sec-GLMGAM" id="toc-sec-GLMGAM" class="nav-link" data-scroll-target="#sec-GLMGAM"><span class="header-section-number">3.4.1</span> Generalized Linear Models and Generalized Additive Models</a></li>
  </ul></li>
  <li><a href="#sec-HSTmods" id="toc-sec-HSTmods" class="nav-link" data-scroll-target="#sec-HSTmods"><span class="header-section-number">3.5</span> Hierarchical Spatio-Temporal Statistical Models</a></li>
  <li><a href="#chapter-3-wrap-up" id="toc-chapter-3-wrap-up" class="nav-link" data-scroll-target="#chapter-3-wrap-up"><span class="header-section-number">3.6</span> Chapter 3 Wrap-Up</a></li>
  <li><a href="#lab-3.1-deterministic-prediction-methods" id="toc-lab-3.1-deterministic-prediction-methods" class="nav-link" data-scroll-target="#lab-3.1-deterministic-prediction-methods">Lab 3.1: Deterministic Prediction Methods</a>
  <ul class="collapse">
  <li><a href="#inverse-distance-weighting" id="toc-inverse-distance-weighting" class="nav-link" data-scroll-target="#inverse-distance-weighting">Inverse Distance Weighting</a></li>
  <li><a href="#generic-kernel-smoothing-and-cross-validation" id="toc-generic-kernel-smoothing-and-cross-validation" class="nav-link" data-scroll-target="#generic-kernel-smoothing-and-cross-validation">Generic Kernel Smoothing and Cross-Validation</a></li>
  </ul></li>
  <li><a href="#lab-3.2-trend-prediction" id="toc-lab-3.2-trend-prediction" class="nav-link" data-scroll-target="#lab-3.2-trend-prediction">Lab 3.2: Trend Prediction</a>
  <ul class="collapse">
  <li><a href="#fitting-the-model" id="toc-fitting-the-model" class="nav-link" data-scroll-target="#fitting-the-model">Fitting the Model</a></li>
  <li><a href="#predictions" id="toc-predictions" class="nav-link" data-scroll-target="#predictions">Predictions</a></li>
  </ul></li>
  <li><a href="#lab-3.3-regression-models-for-forecasting" id="toc-lab-3.3-regression-models-for-forecasting" class="nav-link" data-scroll-target="#lab-3.3-regression-models-for-forecasting">Lab 3.3: Regression Models for Forecasting</a>
  <ul class="collapse">
  <li><a href="#tidying-up-the-data" id="toc-tidying-up-the-data" class="nav-link" data-scroll-target="#tidying-up-the-data">Tidying Up the Data</a></li>
  <li><a href="#predicting-sst-pixelwise" id="toc-predicting-sst-pixelwise" class="nav-link" data-scroll-target="#predicting-sst-pixelwise">Predicting SST Pixelwise</a></li>
  </ul></li>
  <li><a href="#lab-3.4-generalized-linear-spatio-temporal-regression" id="toc-lab-3.4-generalized-linear-spatio-temporal-regression" class="nav-link" data-scroll-target="#lab-3.4-generalized-linear-spatio-temporal-regression">Lab 3.4: Generalized Linear Spatio-Temporal Regression</a>
  <ul class="collapse">
  <li><a href="#fitting-the-model-1" id="toc-fitting-the-model-1" class="nav-link" data-scroll-target="#fitting-the-model-1">Fitting the Model</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Spatio-Temporal Statistical Models</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>As you read this chapter and the next two, remind yourself that what you see in data may be different than what you might expect to see. Your view might be obstructed and/or not in sharp focus. Spatial predictive models can fill in the gaps and clear up your vision, but what you see in the data is still a “guess” at what is really there. We use statistical prediction methods that quantify these guesses with their associated prediction variances. Now, up the ante - include time as well and try to forecast the future… even in places where there are no current or past data! We show how this is possible in the pages that follow.</p>
<p>Spatio-temporal prediction based on spatio-temporal statistical modeling is a central theme of this book. Importantly, our type of prediction comes with prediction variances that quantify the uncertainty in the prediction. Predicting the future is notoriously hard, but at least the spatio-temporal prediction variances can quantify how hard it is - if you use the “right” model! In this spatio-temporal setting, what if your goal is not to predict new values but to study the impact of covariates on a response? As we shall see, the same statistical models that are useful for prediction also allow us to infer important relationships between covariates and responses.</p>
<p>We see <em>three principal goals for spatio-temporal statistical modeling</em>:</p>
<ol type="1">
<li>Predicting a plausible value of a response variable at some location in space within the time span of the observations and reporting the uncertainty of that prediction;</li>
<li>Performing scientific inference about the importance of covariates on the response variable in the presence of spatio-temporal dependence; and</li>
<li>Forecasting the future value of the response variable at some location, along with the uncertainty of that forecast.</li>
</ol>
<p>It is important to note that our observations associated with each of these goals will always include measurement error and will often be incomplete, in the sense that there are some locations in space and time that have missing observations. When modeling to accomplish any of the goals above, we have to be able to take into account these data issues, and also that our model is almost surely “wrong.” As the famous aphorism by George Box goes, “all models are wrong but some are useful” <span class="citation" data-cites="box1976science">Box (<a href="references.html#ref-box1976science" role="doc-biblioref">1976</a>)</span>, <span class="citation" data-cites="box1979robustness">Box (<a href="references.html#ref-box1979robustness" role="doc-biblioref">1979</a>)</span>. Our task is to maximize the “usefulness” and to minimize the “wrongness.”</p>
<p>The primary purpose of this chapter is to present an example illustrating each of the three goals given above, along with a potential modeling solution that initially does <em>not</em> account for a spatio-temporal error process. This will allow us to illustrate some of the benefits and shortcomings of standard approaches and show why it is often better to consider statistical models that <em>do</em> account for spatio-temporal dependent errors (see Chapters 4 and 5). This will also give you a chance to use some of the visualization and exploratory techniques you learned in Chapter 2, and the <code>R</code> Labs at the end of this chapter will further develop your <code>R</code> programming and analysis skills for spatio-temporal data, in preparation for later chapters.</p>
<section id="sec-determ_pred" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sec-determ_pred"><span class="header-section-number">3.1</span> Spatio-Temporal Prediction</h2>
<p>To start with, consider the prediction (i.e., “interpolation”) of maximum daily temperatures on 15 July 1993 at the location denoted by the triangle in the top panel of <a href="#fig-July1993temps" class="quarto-xref">Figure&nbsp;<span>3.1</span></a>, given observations on the same variable on the same date at 138 measurement locations in the central USA (NOAA data set). We seek a predictor, and it is easy to imagine visually how we might construct one – we somehow just combine the nearest observations. Indeed, as mentioned in <a href="Chapter1.html#sec-Tobler" class="quarto-xref"><span>Section 1.2.2</span></a>, Tobler’s “law” suggests that we should give more weight to nearby observations when we interpolate. But, why stop with just space? We also have other observations at different time points, so we should consider nearby observations in both space <em>and</em> time, as shown in the bottom panel of <a href="#fig-July1993temps" class="quarto-xref">Figure&nbsp;<span>3.1</span></a>. We have already shown in Chapter 2 (e.g., <a href="Chapter2.html#fig-TmaxTS" class="quarto-xref">Figure&nbsp;<span>2.9</span></a>) that there is strong spatio-temporal dependence in these data. Since we have observations at times before and after 15 July 1993, this application is an example of <em>smoothing</em> – that is, we seek a smoothing predictor. If we only had observations up to 15 July, then we would seek a <em>filtering</em> predictor for the entire temperature field on 15 July 1993, and a <em>forecasting</em> predictor for the entire field at any time after 15 July 1993. Discussion of the distinction between the three types of spatio-temporal predictor is given in <a href="Chapter1.html#sec-HMs" class="quarto-xref"><span>Section 1.3</span></a>.</p>
<p><img src="img/Chapter_3/NOAA4.png" class="img-fluid"></p>
<div id="fig-July1993temps" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-July1993temps-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_3/NOAA5.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-July1993temps-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.1: Top: NOAA maximum daily temperature observations for 15 July 1993 (degrees Fahrenheit).<br>
Bottom: NOAA maximum daily temperature observations for 01, 15, and 30 July 1993 (degrees Fahrenheit).<br>
The triangle corresponds to a spatial location and time point <span class="math inline">\(\{\mathbf{s}_0;t_0\}\)</span> for which we would like to obtain a prediction of the maximum daily temperatures.
</figcaption>
</figure>
</div>
<section id="deterministic-prediction" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="deterministic-prediction">Deterministic Prediction</h4>
<p>Perhaps the simplest way to perform spatio-temporal prediction would be to follow Tobler’s law and simply average the data in such a way as to give more weight to the nearest observations in space and time. The most obvious way to do this is through <em>inverse distance weighting</em> (IDW). Suppose we have spatio-temporal data given by</p>
<p><span class="math display">\[
\{Z(\mathbf{s}_{11};t_1), Z(\mathbf{s}_{21};t_1),\ldots, Z(\mathbf{s}_{m_1 1};t_1),\ldots, Z(\mathbf{s}_{1T};t_T), Z(\mathbf{s}_{2T};t_T),\ldots,Z(\mathbf{s}_{m_T T};t_T)\},
\]</span></p>
<p>where for each time <span class="math inline">\(t_j\)</span> we have <span class="math inline">\(m_{j}\)</span> observations. Then the IDW predictor at some location <span class="math inline">\(\mathbf{s}_{0}\)</span> and time <span class="math inline">\(t_0\)</span> (where, in this smoothing-predictor case, we assume that <span class="math inline">\(t_1 \leq t_0 \leq t_T\)</span>) is given by</p>
<p><span id="eq-IDW"><span class="math display">\[
\widehat{Z}(\mathbf{s}_0;t_0) =  \sum_{j=1}^T \sum_{i=1}^{m_j} w_{ij}(\mathbf{s}_0;t_0) Z(\mathbf{s}_{i j};t_j),
\tag{3.1}\]</span></span></p>
<p>where</p>
<p><span id="eq-IDWnw"><span class="math display">\[
w_{ij}(\mathbf{s}_0;t_0) \equiv \frac{\widetilde{w}_{ij}(\mathbf{s}_0;t_0)}{\sum_{k=1}^T \sum_{\ell=1}^{m_k} \widetilde{w}_{\ell k}(\mathbf{s}_0;t_0)},
\tag{3.2}\]</span></span></p>
<p><span id="eq-IDWw"><span class="math display">\[
\widetilde{w}_{ij}(\mathbf{s}_0;t_0) \equiv \frac{1}{d((\mathbf{s}_{i j};t_j),(\mathbf{s}_0;t_0))^\alpha},
\tag{3.3}\]</span></span></p>
<p><span class="math inline">\(d((\mathbf{s}_{i j};t_i),(\mathbf{s}_0;t_0))\)</span> is the “distance” between the spatio-temporal location <span class="math inline">\((\mathbf{s}_{i j};t_j)\)</span> and the prediction location <span class="math inline">\((\mathbf{s}_0;t_0)\)</span>, and the power coefficient <span class="math inline">\(\alpha\)</span> is a positive real number that controls the amount of smoothing (e.g., often <span class="math inline">\(\alpha = 2\)</span>, but it does not have to be). The notation makes this look more complicated than it actually is: IDW is simply a weighted average of the data points, giving the closest locations more weight (while requiring that the weights sum to 1). You are free to choose your preferred distance <span class="math inline">\(d(\cdot,\cdot)\)</span>; a simple one is the Euclidean distance (although this implicitly treats space and time in the same way, which may not be appropriate; see <a href="Chapter4.html#sec-LGestimation" class="quarto-xref"><span>Section 4.2.3</span></a>). Note that if we were interested in predicting at a different spatio-temporal location, we would necessarily get different weights, but in a way that respects Tobler’s first law of geography. Also note that some practitioners require an “exact interpolator” in the sense that if the prediction location <span class="math inline">\((\mathbf{s}_0;t_0)\)</span> corresponds to a data location, they want the prediction to be exactly the same as the data value (so, not a smoothed estimate there). The formula in <a href="#eq-IDW" class="quarto-xref">Equation&nbsp;<span>3.1</span></a> gives an exact interpolator. Thus, <span class="math inline">\(\widehat{Z}(\mathbf{s}_0;t_0) = Z(\mathbf{s}_{k \ell};t_\ell)\)</span> if a data location <span class="math inline">\((\mathbf{s}_{k \ell};t_\ell)\)</span> corresponds to the prediction location <span class="math inline">\((\mathbf{s}_0;t_0)\)</span> (since <span class="math inline">\(\alpha &gt; 0\)</span>, <span class="math inline">\((\mathbf{s}_0;t_0)\)</span> being a data location implies that the right-hand side of <a href="#eq-IDWw" class="quarto-xref">Equation&nbsp;<span>3.3</span></a> is infinite, so it gets a weight of 1 in <a href="#eq-IDWnw" class="quarto-xref">Equation&nbsp;<span>3.2</span></a>}. As discussed in <span class="citation" data-cites="cressie1993statistics">Cressie (<a href="references.html#ref-cressie1993statistics" role="doc-biblioref">1993, p. 379</a>)</span>, exact interpolators can be problematic when one has measurement uncertainty, and one way to obtain a smoothing predictor is to use weights in <a href="#eq-IDWw" class="quarto-xref">Equation&nbsp;<span>3.3</span></a> proportional to <span class="math inline">\(1/(d(\cdot,\cdot) + c)^\alpha\)</span>, where <span class="math inline">\(c &gt; 0\)</span>. (Setting <span class="math inline">\(c=0\)</span> reverts to the exact interpolator.)</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Computing distances between a single set of coordinates can be done in base <code>R</code> using the function <code>dist</code>. To compute distances between two sets of coordinates, it is more convenient to use the function <code>rdist</code> in the package <strong>fields</strong>, or the function <code>spDists</code> in the package <strong>sp</strong>, both of which take two sets of coordinates as arguments. The latter also works with <code>Spatial</code> objects defined in the package <strong>sp</strong>.</p>
</div>
</div>
<p>The left panel in <a href="#fig-pred_IDW_Gauss" class="quarto-xref">Figure&nbsp;<span>3.2</span></a> shows predictions of maximum temperature for six days within the month of July 1993 using 30 days of July 1993 data, where data from 14 July 1993 was omitted. These predictions were obtained using IDW with <span class="math inline">\(\alpha = 5\)</span>. In this example, setting <span class="math inline">\(\alpha\)</span> to a smaller value (such as <span class="math inline">\(2\)</span>) gives a smoother surface since more weight is given to observations that are “far” from the prediction locations. In deterministic interpolators, smoothing parameters such as <span class="math inline">\(\alpha\)</span> are usually chosen using a procedure known as cross-validation (see <a href="#nte-technote-CV" class="quarto-xref">Note&nbsp;<span>3.1</span></a> and the left panel in <a href="#fig-LOOCV" class="quarto-xref">Figure&nbsp;<span>3.3</span></a>). From the IDW prediction in <a href="#fig-pred_IDW_Gauss" class="quarto-xref">Figure&nbsp;<span>3.2</span></a>, we observe that our predictions on the day with no data look smoother than those on days for which we have data. We shall see in Chapter 4 that this is typical of most predictors, including stochastic ones that are optimal in the sense of minimizing the mean squared prediction error (MSPE).</p>
<div id="fig-pred_IDW_Gauss" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-pred_IDW_Gauss-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_3/IDW_pred.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pred_IDW_Gauss-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.2: Predictions of <code>Tmax</code> in degrees Fahrenheit for the maximum temperature in the NOAA data set within a square box enclosing the domain of interest for six days (each five days apart) spanning the temporal window of the data, 01 July 1993 to 30 July 1993, using (left) inverse distance weighting functionality from the <code>R</code> package <strong>gstat</strong> with inverse distance power <span class="math inline">\(\alpha = 5\)</span> and (right) a Gaussian radial basis kernel with bandwidth <span class="math inline">\(\theta =0.5\)</span>. Data for 14 July 1993 were omitted from the original data set.
</figcaption>
</figure>
</div>
<p>In general, IDW is a type of spatio-temporal <em>kernel predictor</em>. That is, in <a href="#eq-IDWw" class="quarto-xref">Equation&nbsp;<span>3.3</span></a> we can let</p>
<p><span class="math display">\[
\widetilde{w}_{ij}(\mathbf{s}_0;t_0) = k((\mathbf{s}_{ij};t_j),(\mathbf{s}_0;t_0);\theta),
\]</span></p>
<p>where <span class="math inline">\(k((\mathbf{s}_{ij};t_j),(\mathbf{s}_0;t_0);\theta)\)</span> is a <em>kernel function</em> (i.e., a function that quantifies the similarity between two locations) that depends on the distance between <span class="math inline">\((\mathbf{s}_{ij};t_j)\)</span> and <span class="math inline">\((\mathbf{s}_0;t_0)\)</span> and some <em>bandwidth</em> parameter, <span class="math inline">\(\theta\)</span>. Specifically, the bandwidth controls the “width” of the kernel, so a larger bandwidth averages more observations (and produces smoother prediction fields) than a narrow bandwidth. A classic example of a kernel function is the <em>Gaussian radial basis kernel</em></p>
<p><span id="eq-radialbasiskern"><span class="math display">\[
k((\mathbf{s}_{ij};t_j),(\mathbf{s}_0;t_0);\theta) \equiv \exp\left( - \frac{1}{\theta} d((\mathbf{s}_{ij};t_j),(\mathbf{s}_0;t_0))^2\right),
\tag{3.4}\]</span></span></p>
<p>where the bandwidth parameter <span class="math inline">\(\theta\)</span> is proportional to the variance parameter in a normal (Gaussian) distribution. Many other kernels exist (e.g., tricube, bisquare, Epanechnikov), some of which have <em>compact support</em> (i.e., provide zero weight beyond a certain distance threshold). If we write <span class="math inline">\(d(\cdot,\cdot)^\alpha = \exp( \alpha \log d(\cdot,\cdot))\)</span>, it is clear that <span class="math inline">\(\alpha\)</span> in IDW plays the role of the bandwidth parameter and IDW has non-compact support. The right panel of <a href="#fig-pred_IDW_Gauss" class="quarto-xref">Figure&nbsp;<span>3.2</span></a> shows an interpolation of the NOAA temperature data using a Gaussian radial basis kernel with <span class="math inline">\(\theta = 0.5\)</span>. As in IDW, <span class="math inline">\(\theta\)</span> is usually chosen by cross-validation (see the right panel in <a href="#fig-LOOCV" class="quarto-xref">Figure&nbsp;<span>3.3</span></a>).</p>
<p>Traditional implementations of deterministic methods do not explicitly account for measurement uncertainty in the data nor do they provide model-based estimates of the prediction uncertainty. One might argue that, for non-exact interpolators, one is implicitly removing (filtering or smoothing) the observation error with the averaging that takes place as part of the interpolation. However, there is no mechanism to incorporate explicit knowledge of the magnitude of the measurement error. Regarding prediction uncertainty of deterministic predictors, we can get estimates of the overall quality of predictions by doing cross-validation (see <a href="#nte-technote-CV" class="quarto-xref">Note&nbsp;<span>3.1</span></a>). Recall that we have also suggested using cross-validation to select the degree of smoothing (e.g., the <span class="math inline">\(\alpha\)</span> parameter in IDW and, more generally, the <span class="math inline">\(\theta\)</span> parameter in the kernel-based prediction). As an example, in <a href="#fig-LOOCV" class="quarto-xref">Figure&nbsp;<span>3.3</span></a> we show the leave-one-out cross-validation (LOOCV) MSPE score for different values of <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\theta\)</span> (lower cross-validation scores are better) when doing IDW and Gaussian kernel smoothing for the NOAA maximum temperature data set in July 1993. These cross-validation analyses suggest that <span class="math inline">\(\alpha = 5\)</span> and <span class="math inline">\(\theta = 0.6\)</span> are likely to give the best out-of-sample predictions for this specific example. In addition, note that the lowest cross-validation score for the Gaussian kernel smoother is lower (i.e., better) than the lowest cross-validation score for IDW. This suggests that the Gaussian kernel smoother is likely to be a better predictor than the IDW smoother for these data.</p>
<p>Cross-validation can also be used to compare models through their predictions, as the following <a href="#nte-technote-CV" class="quarto-xref">Note&nbsp;<span>3.1</span></a> explains.</p>
<div id="fig-LOOCV" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-LOOCV-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_3/LOOCV.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-LOOCV-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.3: The leave-one-out cross-validation score <span class="math inline">\(CV_{(m)}\)</span> (see <a href="#nte-technote-CV" class="quarto-xref">Note&nbsp;<span>3.1</span></a>) for different values of <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\theta\)</span> when doing IDW prediction (left) and Gaussian kernel prediction (right) of maximum temperature in the NOAA data set in July 1993.
</figcaption>
</figure>
</div>
<div id="nte-technote-CV" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;3.1: Cross-Validation
</div>
</div>
<div class="callout-body-container callout-body">
<p>Cross-validation seeks to evaluate model predictions by splitting up the data into a training sample and a validation sample, then fitting the model with the training sample and evaluating it with the validation sample. In <em>K</em>-fold cross-validation, we randomly split the available data into <span class="math inline">\(K\)</span> roughly equal-size components (or “folds”). Each fold is held out, the model is trained on the remaining <span class="math inline">\(K-1\)</span> folds, and then the model is evaluated on the fold that was held out. Specifically, for <span class="math inline">\(k=1,\ldots,K\)</span> folds, fit the model with the <span class="math inline">\(k\)</span>th fold removed, and obtain predictions <span class="math inline">\(\widehat{Z}^{(-k)}_i\)</span> for <span class="math inline">\(i=1,\ldots,m_k\)</span>, where <span class="math inline">\(m_k\)</span> is the number of data in the <span class="math inline">\(k\)</span>th fold. We then select a metric by which we evaluate the predictions relative to the held-out samples. For example, if we were interested in the mean squared prediction error (MSPE), we would compute <span class="math inline">\(MSPE_k = (1/m_k) \sum_{i=1}^{m_k} (Z_i - \widehat{Z}^{(-k)}_i)^2\)</span> for the <span class="math inline">\(m_k\)</span> observations in the <span class="math inline">\(k\)</span>th fold, <span class="math inline">\(k=1,\ldots,K\)</span>. The <span class="math inline">\(K\)</span>-fold cross-validation score is then</p>
<p><span class="math display">\[
CV_{(K)} = \frac{1}{K} \sum_{k=1}^K MSPE_k.
\]</span></p>
<p>It has been shown empirically that good choices for the number of folds are <span class="math inline">\(K=5\)</span> and <span class="math inline">\(K=10\)</span>.</p>
<p>A special case of <span class="math inline">\(K\)</span>-fold cross-validation occurs when <span class="math inline">\(K=m\)</span>. This is called <em>leave-one-out cross-validation</em> (LOOCV). In this case, only a single observation is used for validation and the remaining observations are used to make up the training set. This is repeated for all <span class="math inline">\(m\)</span> observations. The LOOCV score is then</p>
<p><span class="math display">\[
CV_{(m)} = \frac{1}{m} \sum_{i=1}^m MSPE_i.
\]</span></p>
<p>LOOCV typically has low bias as an estimate of the expected squared error of a test sample, but it can also have high variance. This is why the choice of <span class="math inline">\(K=5\)</span> or <span class="math inline">\(K=10\)</span> often provides a better compromise between bias and variance. It is also the case that LOOCV can be computationally expensive to implement in general, since it requires the model to be fitted <span class="math inline">\(m\)</span> times (although there are notable exceptions such as with the predicted residual error sum of squares (PRESS) statistic in multiple linear regression models; see <a href="ChapterAppendixB.html" class="quarto-xref"><span>Appendix B</span></a>). For more details on cross-validation, see <span class="citation" data-cites="hastie2009elements">Hastie et al. (<a href="references.html#ref-hastie2009elements" role="doc-biblioref">2009</a>)</span>, Section 7.10.</p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math inline">\(K\)</span>-fold cross-validation is an “embarrassingly parallel” problem since all the <span class="math inline">\(K\)</span> validations can be done simultaneously. There are several packages in <strong>R</strong> that enable this, with <strong>parallel</strong> and <strong>foreach</strong> among the most popular. The vignettes in these packages contain more information on how to use them for multicore computing.</p>
</div>
</div>
</section>
</section>
<section id="sec-reg_pred" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sec-reg_pred"><span class="header-section-number">3.2</span> Regression (Trend-Surface) Estimation</h2>
<p>In <a href="#sec-determ_pred" class="quarto-xref"><span>Section 3.1</span></a> we presented some simple deterministic predictors to obtain predictions at spatio-temporal locations given a spatio-temporal data set. We can also use a basic statistical regression model to obtain predictions for such data, assuming that all of the spatio-temporal dependence can be accounted for by “trend” (i.e., covariate) terms. Such a model has the advantage of being exceptionally simple to implement in almost any software package. In addition, a regression model explicitly accounts for model error (usually assumed independent), and it also allows us to obtain a model-based prediction-error variance, although cross-validation scores still provide useful insight into model performance.</p>
<p>Consider a regression model that attempts to account for spatial and temporal trends. To make the notation a bit simpler, we consider the case where we have observations at discrete times <span class="math inline">\(\{t_j: j =1,\ldots,T\}\)</span> for all spatial data locations <span class="math inline">\(\{\mathbf{s}_i: i=1,\ldots,m\}\)</span>. For example,</p>
<p><span id="eq-ST_reg"><span class="math display">\[
Z(\mathbf{s}_i;t_j) = \beta_0 + \beta_1 X_1(\mathbf{s}_i;t_j) + \ldots + \beta_p X_p(\mathbf{s}_i;t_j) + e(\mathbf{s}_i;t_j),
\tag{3.5}\]</span></span></p>
<p>where <span class="math inline">\(\beta_0\)</span> is the intercept and <span class="math inline">\(\beta_k~(k &gt; 0)\)</span> is a regression coefficient associated with <span class="math inline">\(X_k(\mathbf{s}_i;t_j)\)</span>, the <span class="math inline">\(k\)</span>th covariate at spatial location <span class="math inline">\(\mathbf{s}_i\)</span> and time <span class="math inline">\(t_j\)</span>. We also assume for the moment <span class="math inline">\(iid\)</span> errors such that <span class="math inline">\(e(\mathbf{s}_i;t_j) \sim \; indep. \; N(0,\sigma^2_e)\)</span> for all <span class="math inline">\(\{\mathbf{s}_i;t_j\}\)</span> where there are data, and note that <span class="math inline">\(N(\mu,\sigma^2)\)</span> corresponds to a normal distribution with mean <span class="math inline">\(\mu\)</span> and variance <span class="math inline">\(\sigma^2\)</span>. The covariates <span class="math inline">\(X_k(\mathbf{s}_i;t_j)\)</span> may describe explanatory features, such as elevation, that vary spatially but are temporally invariant (on the scales of interest here), time trends (such as an overall seasonal effect) that are spatially invariant but temporally varying, or other variables such as humidity, that are both spatially and temporally varying. We might also consider spatio-temporal “basis functions” that can be used to reconstruct the observed data.</p>
<p>We take a little space here to discuss <em>basis functions</em> beyond the brief explanation given in Chapter 1. What are basis functions? Imagine that we have a complex curve or surface in space. We are often able to decompose this curve or surface as a linear combination of some “elemental” basis functions. For example,</p>
<p><span id="eq-Ybasisexp"><span class="math display">\[
Y(\mathbf{s}) = \alpha_1 \phi_1(\mathbf{s}) + \alpha_2 \phi_2(\mathbf{s}) + \ldots + \alpha_r \phi_r(\mathbf{s}),
\tag{3.6}\]</span></span></p>
<p>where <span class="math inline">\(\{\alpha_i\}\)</span> are constants and <span class="math inline">\(\{\phi_i(\mathbf{s})\}\)</span> are known <em>basis functions</em>. We can think of the coefficients <span class="math inline">\(\{\alpha_i\}\)</span> as weights that describe how important each basis function is in representing the function <span class="math inline">\(Y(\mathbf{s})\)</span>. The basis functions can be <em>local</em> with compact support, or can be <em>global</em>, taking values across the whole domain (see <a href="#fig-basis_fns_1D" class="quarto-xref">Figure&nbsp;<span>3.4</span></a>). In statistics, when <span class="math inline">\(Y(\mathbf{s})\)</span> is a random process, we typically assume the basis functions are known and the coefficients (weights) are random. The expression in <a href="#eq-Ybasisexp" class="quarto-xref">Equation&nbsp;<span>3.6</span></a> could be written as a function of time <span class="math inline">\(t\)</span>, or most generally as a function of <span class="math inline">\(\mathbf{s}\)</span> and <span class="math inline">\(t\)</span>. In time series, the domain over which the basis functions take their values is the one-dimensional real line, whereas in spatial statistics, the domain is typically one-dimensional space (see <a href="#fig-basis_fns_1D" class="quarto-xref">Figure&nbsp;<span>3.4</span></a>) or two-dimensional space (see <a href="#fig-spatial2D" class="quarto-xref">Figure&nbsp;<span>3.5</span></a>); in spatio-temporal statistics, the domain is over both space and time. Examples of basis functions include polynomials, splines, wavelets, sines and cosines, among many others. We often construct spatio-temporal basis functions via a tensor product of spatial basis functions and temporal basis functions (see <a href="Chapter4.html#nte-technote-Kronecker" class="quarto-xref">Note&nbsp;<span>4.1</span></a>).</p>
<div id="fig-basis_fns_1D" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-basis_fns_1D-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_3/basis_examples.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-basis_fns_1D-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.4: Left: Local (top) and global (bottom) basis functions over a one-dimensional spatial domain. Different colors are used to denote different basis functions. Right: Linear combination (red curve) of the individual basis functions (dashed lines depicted in the left panels). In this case, the coefficients <span class="math inline">\(\{\alpha_i\}\)</span> give the relative importance of the basis functions (curves).
</figcaption>
</figure>
</div>
<div id="fig-spatial2D" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-spatial2D-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_3/basis2d-compiled.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spatial2D-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.5: Two-dimensional spatial basis functions and associated coefficients <span class="math inline">\(\boldsymbol{\alpha}_1\)</span> and <span class="math inline">\(\boldsymbol{\alpha}_2\)</span> that lead to two different spatial-process realizations, <span class="math inline">\(Y_1(\mathbf{s})\)</span> and <span class="math inline">\(Y_2(\mathbf{s})\)</span>, respectively.
</figcaption>
</figure>
</div>
<p>Now consider the maximum daily temperature <code>Tmax</code> in the NOAA data set for the month of July 1993, where we have observations at <span class="math inline">\(m = 138\)</span> common spatial locations <span class="math inline">\(\{\mathbf{s}_i: i=1,\ldots,m\}\)</span> for <span class="math inline">\(\{t_j: j = 1,\ldots, T= 31\}\)</span> days. In this case, we could account for spatial trends by allowing the covariates <span class="math inline">\(\{X_k\}\)</span> to correspond to the spatio-temporal coordinate, and/or their transformations and interactions. For example, let <span class="math inline">\(\mathbf{s}_i \equiv (s_{1,i},s_{2,i})'\)</span>, and consider a linear model with the following basis functions:</p>
<ul>
<li>overall mean: <span class="math inline">\(X_0(\mathbf{s}_i;t_j) =  1\)</span>, for all <span class="math inline">\(\mathbf{s}_i\)</span> and <span class="math inline">\(t_j\)</span>;</li>
<li>linear in <span class="math inline">\(lon\)</span>-coordinate: <span class="math inline">\(X_1(\mathbf{s}_i;t_j) =   s_{1,i}\)</span>, for all <span class="math inline">\(t_j\)</span>,</li>
<li>linear in <span class="math inline">\(lat\)</span>-coordinate: <span class="math inline">\(X_2(\mathbf{s}_i;t_j) = s_{2,i}\)</span>, for all <span class="math inline">\(t_j\)</span>;</li>
<li>linear time (day) trend: <span class="math inline">\(X_3(\mathbf{s}_i;t_j) =  t_j\)</span>, for all <span class="math inline">\(\mathbf{s}_i\)</span>;</li>
<li><span class="math inline">\(lon\)</span>–<span class="math inline">\(lat\)</span> interaction: <span class="math inline">\(X_4(\mathbf{s}_i;t_j) =  s_{1,i} \, s_{2,i}\)</span>, for all <span class="math inline">\(t_j\)</span>;</li>
<li><span class="math inline">\(lon\)</span>–<span class="math inline">\(t\)</span> interaction: <span class="math inline">\(X_5(\mathbf{s}_i;t_j) = s_{1,i} \, t_j\)</span>, for all <span class="math inline">\(s_{2,i}\)</span>;</li>
<li><span class="math inline">\(lat\)</span>–<span class="math inline">\(t\)</span> interaction: <span class="math inline">\(X_6(\mathbf{s}_i;t_j) =  s_{2,i} \, t_j\)</span>, for all <span class="math inline">\(s_{1,i}\)</span>;</li>
<li>additional spatial-only basis functions: <span class="math inline">\(X_k(\mathbf{s}_i;t_j) = \phi_{k-6}(\mathbf{s}_i), k =7,\dots,18\)</span>, for all <span class="math inline">\(t_j\)</span> (see <a href="#fig-basis_lin_reg" class="quarto-xref">Figure&nbsp;<span>3.13</span></a>).</li>
</ul>
<p>Note that the space and time coordinates used in <span class="math inline">\(X_0,\ldots,X_6\)</span> can be thought of as basis functions; we choose the separate notation between these latitude, longitude, and time trend covariates and the spatial-only basis functions (denoted <span class="math inline">\(\{\phi_k: k=1,\ldots,12\}\)</span>) given in <a href="#fig-basis_lin_reg" class="quarto-xref">Figure&nbsp;<span>3.13</span></a> for the sake of interpretability. In this example, there is an intercept and <span class="math inline">\(p=18\)</span> regression coefficients.</p>
<div id="fig-basis_lin_reg" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-basis_lin_reg-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_3/basis_fns.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-basis_lin_reg-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.6: The time-invariant basis functions, <span class="math inline">\(\phi_1(\mathbf{s}),\dots,\phi_{12}(\mathbf{s})\)</span>, used for regression prediction of maximum temperature data from the NOAA data set for July 1993.
</figcaption>
</figure>
</div>
<p>The regression model given in <a href="#eq-ST_reg" class="quarto-xref">Equation&nbsp;<span>3.16</span></a> can be fitted via <em>ordinary least squares</em> (OLS), in which case we find estimates of the parameters <span class="math inline">\(\beta_0, \beta_1,\ldots,\beta_p\)</span> that minimize the residual sum of squares,</p>
<p><span id="eq-RegRSS"><span class="math display">\[
RSS = \sum_{j=1}^T \sum_{i=1}^m (Z(\mathbf{s}_{i};t_j) - \widehat{Z}(\mathbf{s}_{i};t_j))^2.
\tag{3.7}\]</span></span></p>
<p>We denote these estimates by <span class="math inline">\(\{\widehat{\beta}_0,\widehat{\beta}_1,\ldots,\widehat{\beta}_p\}\)</span> and we write <span class="math inline">\(\widehat{Z}(\mathbf{s};t) = \widehat{\beta}_0 + \widehat{\beta}_1 X_1(\mathbf{s};t) + \ldots + \widehat{\beta}_p X_p(\mathbf{s};t)\)</span>. (We also obtain an estimate of the variance parameter, namely <span class="math inline">\(\widehat{\sigma}^2_e = RSS/(mT-p-1)\)</span>.) This then allows us to get predictions for a mean response, or a new response, <span class="math inline">\(Z(\mathbf{s}_0;t_0)\)</span>, at any location <span class="math inline">\(\{\mathbf{s}_0;t_0\}\)</span> for which we have covariates. We can also obtain uncertainty estimates for these predictions. The formulas for these estimates and predictors are most easily seen from a matrix representation, as shown in <a href="#nte-technote-matReg" class="quarto-xref">Note&nbsp;<span>3.3</span></a>. <a href="#fig-LinReg_pred" class="quarto-xref">Figure&nbsp;<span>3.7</span></a> shows the predictions and the prediction standard errors (assuming the regression model with an intercept and <span class="math inline">\(p=18\)</span>) for the maximum temperature data in the NOAA data set in July 1993, with 14 July 1993 omitted when fitting the model.</p>
<div id="fig-LinReg_pred" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-LinReg_pred-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_3/LinReg_pred.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-LinReg_pred-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.7: Regression predictions (left) and associated prediction standard errors (right) of maximum temperature (in degrees Fahrenheit) within a square box enclosing the domain of interest for six individual days (each 5 days apart) in July 1993 using the <code>R</code> function <code>lm</code>. Data for 14 July 1993 were purposely omitted from the original data set during fitting.
</figcaption>
</figure>
</div>
<p>The predictions are much smoother than those found using kernel smoothing (<a href="#fig-pred_IDW_Gauss" class="quarto-xref">Figure&nbsp;<span>3.2</span></a>), a direct result of using basis functions that are spatio-temporally smooth. This is not always the case, and using covariates that are highly spatially varying (e.g., from topography) will yield predictions that also vary substantially with space. Note also from <a href="#fig-LinReg_pred" class="quarto-xref">Figure&nbsp;<span>3.7</span></a> that the prediction standard errors do not show much structure because the <span class="math inline">\(X\)</span>s are accounting for most of the spatio-temporal variation in the data. Uncertainty increases at the domain edges where prediction becomes extrapolation.</p>
<p>It is important to mention here that the regression model given in <a href="#eq-ST_reg" class="quarto-xref">Equation&nbsp;<span>3.16</span></a> does not explicitly account for measurement errorss in the responses, and thus that variation due to measurement error is confounded with the variation due to lack of fit in the residual variance <span class="math inline">\(\sigma^2_e\)</span>. We account explicitly for this measurement-error variation (and small-scale spatio-temporal variation) in Chapters 4 and 5. In addition, note that the regression predictor can be considered a type of kernel predictor (see <a href="ChapterAppendixB.html" class="quarto-xref"><span>Appendix B</span></a>).</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Basis functions such as those depicted in <a href="#fig-basis_lin_reg" class="quarto-xref">Figure&nbsp;<span>3.13</span></a> can be easily constructed using the package <strong>FRK</strong>, which we explore further in Chapter 4. Basis functions can be constructed at multiple resolutions, can be spatial-only (as used here) or also spatio-temporal. See Lab 3.2 for more details.</p>
</div>
</div>
<section id="model-diagnostics-dependent-errors" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="model-diagnostics-dependent-errors"><span class="header-section-number">3.2.1</span> Model Diagnostics: Dependent Errors</h3>
<p>When we first learn how to do regression modeling in statistics, we gain an appreciation for the importance of model diagnostics to verify the assumptions of the model. For example, we look for the presence of outliers, influential observations, non-constant error variance, non-normality, dependence in the errors, and so forth <span class="citation" data-cites="kutner2004applied">Kutner et al. (<a href="references.html#ref-kutner2004applied" role="doc-biblioref">2004</a>)</span>. It is particularly important to consider the possibility of dependent errors in the case where the data are indexed in space or time (see Chapter 6 for more detailed discussion about model evaluation). From an exploratory perspective, one can calculate the spatio-temporal covariogram (or semivariogram), discussed in Chapter 2, from the residuals, <span class="math inline">\(\widehat{e}(\mathbf{s}_{i};t_j) \equiv Z(\mathbf{s}_{i};t_j) - \widehat{Z}(\mathbf{s}_{i};t_j)\)</span>, and look for dependence structure as a function of spatial and temporal lags. As seen in <a href="#fig-var_cov_residuals" class="quarto-xref">Figure&nbsp;<span>3.8</span></a>, there is ample spatial and temporal structure in the residuals. It is instructive to compare <a href="#fig-var_cov_residuals" class="quarto-xref">Figure&nbsp;<span>3.8</span></a> with the empirical semivariogram calculated from the original data set and given in <a href="Chapter2.html#fig-var_cov" class="quarto-xref">Figure&nbsp;<span>2.17</span></a>. The former has a lower sill, and therefore the basis functions and the other covariates have been able to explain some of the spatio-temporal variability in the data, but clearly not all of it.</p>
<div id="fig-var_cov_residuals" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-var_cov_residuals-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_3/STvar_residuals.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-var_cov_residuals-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.8: Empirical spatio-temporal semivariogram of the residuals after fitting a linear model to daily maximum temperatures in the NOAA data set during July 2003, computed using the function <code>variogram</code> in <strong>gstat</strong>.
</figcaption>
</figure>
</div>
<p>More formally, one can apply a statistical test for <em>temporal</em> dependence such as the Durbin–Watson test (see <a href="#nte-technote-durbin-watson-morans-i" class="quarto-xref">Note&nbsp;<span>3.2</span></a>), and if the data correspond to areal regions in two-dimensional space, one can use a test for <em>spatial</em> dependence such as Moran’s <span class="math inline">\(I\)</span> test (see <a href="#nte-technote-durbin-watson-morans-i" class="quarto-xref">Note&nbsp;<span>3.2</span></a>). In looking at <em>spatio-temporal</em> dependence, we can consider the “space-time index” (STI) approach of <span class="citation" data-cites="henebry1995spatial">Henebry (<a href="references.html#ref-henebry1995spatial" role="doc-biblioref">1995</a>)</span>, which is a type of Moran’s <span class="math inline">\(I\)</span> statistic for spatio-temporal data <span class="citation" data-cites="cressie2011statistics">(see <a href="references.html#ref-cressie2011statistics" role="doc-biblioref">Cressie &amp; Wikle, 2011, p. 303</a>)</span>. This approach was developed for areal regions that have a known adjacency structure. In principle, this can be extended to the case of spatio-temporal data with continuous spatial support; see Lab 3.2.</p>
<p>Alternatively, we can consider a spatio-temporal analog to the Durbin–Watson test. <span class="citation" data-cites="cressie2011statistics">Cressie &amp; Wikle (<a href="references.html#ref-cressie2011statistics" role="doc-biblioref">2011, p. 131</a>)</span> give a statistic based on the empirical (spatial) semivariogram that can be extended to the spatio-temporal setting. In particular, let</p>
<p><span class="math display">\[
F \equiv \left| \frac{\widehat{\gamma}_e(||\mathbf{h}_1||;\tau_1)}{\widehat{\sigma}^2_e}-1\right| ,
\]</span></p>
<p>where <span class="math inline">\(\widehat{\gamma}_e (||\mathbf{h}_1||;\tau_1)\)</span> is the empirical semivariogram estimate at the smallest possible spatial (<span class="math inline">\(||\mathbf{h}_1||\)</span>) and temporal (<span class="math inline">\(\tau_1\)</span>) lags (see <a href="Chapter2.html#nte-technote-semivariogram" class="quarto-xref">Note&nbsp;<span>2.1</span></a>), and <span class="math inline">\(\widehat{\sigma}^2_e\)</span> is the regression-error-variance estimate (see <a href="#nte-technote-matReg" class="quarto-xref">Note&nbsp;<span>3.3</span></a>). If this value of <span class="math inline">\(F\)</span> is “large,” we reject the null hypothesis of spatio-temporal independence. We can evaluate what is “large” in this case by doing a permutation test of the null hypothesis of independence, which does not depend on any distributional assumptions on the test statistic, <span class="math inline">\(F\)</span>. In this case, the data locations (in space and time) are randomly permuted and <span class="math inline">\(F\)</span> is calculated for many such permutation samples. If the statistic <span class="math inline">\(F\)</span> calculated with the observed data is below the 2.5th percentile or above the 97.5th percentile of these permutation samples, then we reject the null hypothesis of spatio-temporal independence (at the 5% level of significance), which suggests that the data are dependent.</p>
<div id="nte-technote-durbin-watson-morans-i" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;3.2: Durbin–Watson and Moran’s <span class="math inline">\(I\)</span> Tests
</div>
</div>
<div class="callout-body-container callout-body">
<p>One of the most used tests for serial dependence in time-series residuals is the <em>Durbin–Watson</em> test <span class="citation" data-cites="kutner2004applied">Kutner et al. (<a href="references.html#ref-kutner2004applied" role="doc-biblioref">2004</a>)</span>. Let <span class="math inline">\(\widehat{e}_t = Z_t - \widehat{Z}_t\)</span> be the residual from some fitted time-series model for which we have <span class="math inline">\(T\)</span> observations <span class="math inline">\(\{Z_t\}\)</span>. The Durbin–Watson test statistic is given by</p>
<p><span class="math display">\[
d = \frac{\sum_{t=2}^T (\widehat{e}_t - \widehat{e}_{t-1})^2}{\sum_{t=1}^T \widehat{e}_t^2}.
\]</span></p>
<p>The intuition for this test is that if residuals are highly (positively) correlated, then <span class="math inline">\(\widehat{e}_t - \widehat{e}_{t-1}\)</span> is small relative to <span class="math inline">\(\widehat{e}_t\)</span> and so, as <span class="math inline">\(d\)</span> gets closer to 0, there is more evidence of positive serial dependence (e.g., a “rule of thumb” suggests that values less than 1 indicate strong positive serial dependence). In contrast, as the value of <span class="math inline">\(d\)</span> gets larger (it is bounded above by 4), it is indicative of no positive serial dependence. This test can be formalized with appropriate upper and lower critical values for <span class="math inline">\(d\)</span>, and statistical software packages can easily calculate these, as well as the analogous test for negative serial dependence.</p>
<p>One of the most commonly used tests for spatial dependence for spatial lattice data is <em>Moran’s <span class="math inline">\(I\)</span></em> test <span class="citation" data-cites="waller2004applied">Waller &amp; Gotway (<a href="references.html#ref-waller2004applied" role="doc-biblioref">2004</a>)</span>. This test can be applied to the data directly, or to the residuals from some spatial regression model. Let <span class="math inline">\(\{Z_i: i=1,\ldots,m\}\)</span> represent spatially referenced data (or residuals) for <span class="math inline">\(m\)</span> spatial locations. Then, Moran’s <span class="math inline">\(I\)</span> statistic is calculated as</p>
<p><span id="eq-moransI"><span class="math display">\[
I = \frac{m \sum_{i=1}^m \sum_{j=1}^m w_{ij} (Z_i - \bar{Z})(Z_j - \bar{Z}) }{(\sum_{i=1}^m \sum_{j=1}^m w_{ij})(\sum_{i=1}^m (Z_i - \bar{Z})^2) },
\tag{3.8}\]</span></span></p>
<p>where <span class="math inline">\(\bar{Z} = (1/m)\sum_{i=1}^m Z_i\)</span> is the spatial mean and <span class="math inline">\(w_{ij}\)</span> are spatial adjacency “weights” between locations <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> (where we require <span class="math inline">\(w_{ii} = 0\)</span>, for all <span class="math inline">\(i=1,\ldots,m\)</span>). Thus, Moran’s <span class="math inline">\(I\)</span> statistic is simply a weighted form of the usual Pearson correlation coefficient, where the weights are the spatial proximity weights, and it takes values between <span class="math inline">\(-1\)</span> and <span class="math inline">\(1\)</span>. If <a href="#eq-moransI" class="quarto-xref">Equation&nbsp;<span>3.8</span></a> is positive, then neighboring regions tend to have similar values, and if it is negative, then neighboring regions tend to have different values. Appropriate critical values or <span class="math inline">\(p\)</span>-values are easily obtained in many software packages.</p>
<p>Note that there are additional measures of temporal dependence (e.g., the Ljung–Box test; see <span class="citation" data-cites="shumway2006time">Shumway &amp; Stoffer (<a href="references.html#ref-shumway2006time" role="doc-biblioref">2006</a>)</span>) and spatial dependence (e.g., the Geary <span class="math inline">\(C\)</span> test; see <span class="citation" data-cites="waller2004applied">Waller &amp; Gotway (<a href="references.html#ref-waller2004applied" role="doc-biblioref">2004</a>)</span>).</p>
</div>
</div>
<p>It is very common, when studying environmental phenomena, that a linear model of some covariates will not explain all the observed spatio-temporal variability. Thus, fitting such a model will frequently result in residuals that are spatially and temporally correlated. This is not surprising, since several environmental processes are certainly more complex than could be described by simple geographical and temporal trend terms. In <a href="#fig-reg_residuals" class="quarto-xref">Figure&nbsp;<span>3.9</span></a> we show the time series of the residuals at two observation locations <span class="math inline">\((81.38^\circ\)</span>W, <span class="math inline">\(35.73^\circ\)</span>N) and (<span class="math inline">\(83.32^\circ\)</span>W, <span class="math inline">\(37.60^\circ\)</span>N), respectively, and the spatial residuals between 24 July and 31 July 1993. The residual time series exhibit considerable <em>temporal</em> correlation (i.e., residuals close together in time tend to be more similar than residuals far apart in time), and the spatial residuals exhibit clear <em>spatial</em> correlation (i.e., residuals close together in space tend to be more similar than residuals far apart in space). In Lab 3.2 we go further and use the Durbin–Watson and Moran’s <span class="math inline">\(I\)</span> tests to reject the null hypotheses of no temporal or spatial correlation in these residuals.</p>
<p><img src="img/Chapter_3/temp_residuals.png" class="img-fluid"></p>
<div id="fig-reg_residuals" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-reg_residuals-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_3/spatial_residuals.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-reg_residuals-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.9: Top: Temporal residuals at station 3810 (black line) and station 3889 (red line), and bottom: spatial residuals between 24 and 31 July 1993, inclusive, when fitting the regression (trend) model described in <a href="#sec-reg_pred" class="quarto-xref"><span>Section 3.2</span></a> to the maximum temperature data in the NOAA data set in July 1993 (but recall that in the fitting we excluded data from 14 July 1993). The triangles denote the two station locations.
</figcaption>
</figure>
</div>
<p>Given that our diagnostics have suggested there is spatio-temporal dependence in the errors after fitting the trend surface, what can we do? Readers who are familiar with more complicated regression procedures might suggest that we could use a generalized least squares (GLS) procedure that explicitly accounts for the dependence in the errors. That is, GLS relaxes the assumption of independence in the errors, so that <span class="math inline">\(e(\mathbf{s}_i;t_j)\)</span> and <span class="math inline">\(e(\mathbf{s}_\ell;t_k)\)</span> could be correlated. In this case, the vector of errors, <span class="math inline">\(\mathbf{e}\equiv (e(\mathbf{s}_1;t_1),\ldots,e(\mathbf{s}_m;t_T))'\)</span>, has the multivariate normal distribution <span class="math inline">\(\mathbf{e}\sim N(\mathbf{0},\mathbf{C}_e)\)</span>, where <span class="math inline">\(\mathbf{C}_e\)</span> is a spatio-temporal covariance matrix. But do we know in advance what this covariance matrix is? Typically, no – and it is further complicated by the fact that to predict at spatio-temporal locations for which we do not have data, we need to know what the error dependence is between <em>any</em> two locations in time and space within our prediction domain, not just those for which we have observations! This aspect of spatio-temporal prediction will be a primary focus of Chapter 4.</p>
<p>One might ask, what is the problem with ignoring the dependence in the errors when doing OLS regression? The answer depends somewhat on the goal. It is fairly easy to show that the OLS parameter estimates and predictions are still unbiased even if one has ignored the dependence in the errors. But ignoring the dependence tends to give inappropriate standard errors and prediction standard errors. In the case of positive dependence (which is the most common case in spatio-temporal data – recall Tobler’s law), the standard errors and prediction standard errors are underestimated if one ignores dependence, giving a false sense of how good the estimates and predictions really are. This issue comes up again in <a href="#sec-STcovinf" class="quarto-xref"><span>Section 3.2.2</span></a>.</p>
<div id="nte-technote-matReg" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;3.3: Ordinary Least Squares Regression: Matrix Representation
</div>
</div>
<div class="callout-body-container callout-body">
<p>Consider an <span class="math inline">\(m\)</span>-dimensional response vector, <span class="math inline">\(\mathbf{Z}= (Z_1,\ldots,Z_m)'\)</span>, and an <span class="math inline">\(m \times (p+1)\)</span> matrix of predictors, <span class="math inline">\(\mathbf{X}\)</span>, where we assume that the first column of this matrix contains a vector of <span class="math inline">\(1\)</span>s for the model intercept. That is,</p>
<p><span class="math display">\[
\mathbf{X}= \left[\begin{array}{cccc}
1 &amp; x_{11} &amp; \ldots &amp; x_{1p} \\
1 &amp; x_{21} &amp; \ldots &amp; x_{2p} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
1 &amp; x_{m1} &amp; \ldots &amp; x_{mp}
\end{array}
\right].
\]</span></p>
<p>Then the regression equation is given by</p>
<p><span class="math display">\[
\mathbf{Z}= \mathbf{X}\boldsymbol{\beta}+ \mathbf{e},
\]</span></p>
<p>where <span class="math inline">\(\boldsymbol{\beta}\)</span> is a <span class="math inline">\((p+1)\)</span>-dimensional parameter vector, and the error vector, <span class="math inline">\(\mathbf{e}= (e_1,\ldots,e_m)'\)</span>, has the multivariate normal distribution <span class="math inline">\(\mathbf{e}\sim N(\mathbf{0},\sigma^2_e \mathbf{I})\)</span>, where <span class="math inline">\(\mathbf{I}\)</span> is an <span class="math inline">\(m \times m\)</span> identity matrix. The ordinary least squares parameter estimates are given by <span class="math inline">\(\widehat{\boldsymbol{\beta}} = (\mathbf{X}' \mathbf{X})^{-1} \mathbf{X}' \mathbf{Z}\)</span>, and the variance–covariance matrix for these estimates is given by <span class="math inline">\(\widehat{\sigma}^2_e (\mathbf{X}' \mathbf{X})^{-1}\)</span>, with <span class="math inline">\(\widehat{\sigma}^2_e = (1/(m-p-1)) \sum_i (Z_i - \widehat{Z}_i)^2\)</span>. The estimated mean response and prediction, <span class="math inline">\(\widehat{Z}_i\)</span>, is given by <span class="math inline">\(\widehat{Z}_i = \mathbf{x}_i' \widehat{\boldsymbol{\beta}}\)</span>, where <span class="math inline">\(\mathbf{x}'_i\)</span> is the <span class="math inline">\(i\)</span>th row of <span class="math inline">\(\mathbf{X}\)</span>. Further, the variance of the <span class="math inline">\(j\)</span>th regression-coefficient estimator, <span class="math inline">\(\widehat{\beta}_j\)</span>, is given by the <span class="math inline">\(j\)</span>th diagonal element of <span class="math inline">\(\widehat{\sigma}^2_\epsilon (\mathbf{X}' \mathbf{X})^{-1}\)</span>. If <span class="math inline">\(\widehat{Z}_i\)</span> is an estimate of the mean response, then an estimate of its variance is given by <span class="math inline">\(\widehat{\sigma}^2_e  (\mathbf{x}_i ' (\mathbf{X}' \mathbf{X})^{-1} \mathbf{x}_i)\)</span>. If one is predicting a new observation, say <span class="math inline">\(Z_h\)</span>, the prediction is <span class="math inline">\(\widehat{Z}_h= \mathbf{x}_h' \widehat{\boldsymbol{\beta}}\)</span>, and the <em>prediction variance</em> is estimated by <span class="math inline">\(\widehat{\sigma}^2_e (1 +  \mathbf{x}_h ' (\mathbf{X}' \mathbf{X})^{-1} \mathbf{x}_h)\)</span>. Derivations and details can be found in textbooks on multiple regression <span class="citation" data-cites="kutner2004applied">(see for example <a href="references.html#ref-kutner2004applied" role="doc-biblioref">Kutner et al., 2004</a>)</span>.</p>
</div>
</div>
</section>
<section id="sec-STcovinf" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="sec-STcovinf"><span class="header-section-number">3.2.2</span> Parameter Inference for Spatio-Temporal Data</h3>
<p>In many scientific applications of spatio-temporal modeling, one may only be interested in whether the covariates (the <span class="math inline">\(X\)</span>s) are important in the model for explanation rather than for prediction. Such examples typically include scientifically meaningful covariates, such as a habitat covariate (<span class="math inline">\(X\)</span>) related to the relative abundance (<span class="math inline">\(Z\)</span>) of an animal in some area, or whether some demographic variable (<span class="math inline">\(X\)</span>) is associated with household income (<span class="math inline">\(Z\)</span>). In this section, for illustration we again consider the maximum temperature data in the NOAA data set – specifically, we consider the regression model given in <a href="#sec-reg_pred" class="quarto-xref"><span>Section 3.2</span></a>, but our focus here is on the regression parameters. For example, do we need the longitude-by-latitude spatial interaction term (<span class="math inline">\(X_4\)</span>) or the latitude-by-day term (<span class="math inline">\(X_6\)</span>) in the regression?</p>
<div id="tbl-reg_results" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-reg_results-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;3.1: Estimated regression coefficients and the standard errors (within parentheses) for the linear regression model of <a href="#sec-reg_pred" class="quarto-xref"><span>Section 3.2</span></a> using ordinary least squares (OLS) and generalized least squares (GLS). One, two, and three asterisks denote significance at the 10%, 5%, and 1% levels, respectively.
</figcaption>
<div aria-describedby="tbl-reg_results-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 28%">
<col style="width: 35%">
<col style="width: 35%">
</colgroup>
<thead>
<tr class="header">
<th>Term</th>
<th><span class="math inline">\(\hat\beta_{\textrm{ols}}\)</span> (SE)</th>
<th><span class="math inline">\(\hat\beta_{\textrm{gls}}\)</span> (SE)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Intercept</td>
<td>192.240<sup>**</sup> (97.854)</td>
<td>195.320<sup>**</sup> (98.845)</td>
</tr>
<tr class="even">
<td>Longitude</td>
<td>1.757 (1.088)</td>
<td>1.780 (1.097)</td>
</tr>
<tr class="odd">
<td>Latitude</td>
<td>-1.317 (2.556)</td>
<td>-0.974 (2.597)</td>
</tr>
<tr class="even">
<td>Day</td>
<td>-1.216<sup>***</sup> (0.134)</td>
<td>-1.237<sup>***</sup> (0.136)</td>
</tr>
<tr class="odd">
<td>Longitude × Latitude</td>
<td>-0.026 (0.028)</td>
<td>-0.022 (0.029)</td>
</tr>
<tr class="even">
<td>Longitude × Day</td>
<td>-0.023<sup>***</sup> (0.001)</td>
<td>-0.023<sup>***</sup> (0.001)</td>
</tr>
<tr class="odd">
<td>Latitude × Day</td>
<td>-0.019<sup>***</sup> (0.002)</td>
<td>-0.019<sup>***</sup> (0.002)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\alpha_{1}\)</span></td>
<td>16.647<sup>***</sup> (4.832)</td>
<td>19.174<sup>***</sup> (4.849)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\alpha_{2}\)</span></td>
<td>18.528<sup>***</sup> (3.056)</td>
<td>16.224<sup>***</sup> (3.125)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\alpha_{3}\)</span></td>
<td>-6.607<sup>**</sup> (3.172)</td>
<td>-4.204 (3.199)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\alpha_{4}\)</span></td>
<td>30.545<sup>***</sup> (4.370)</td>
<td>27.500<sup>***</sup> (4.493)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\alpha_{5}\)</span></td>
<td>14.739<sup>***</sup> (2.747)</td>
<td>13.957<sup>***</sup> (2.759)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\alpha_{6}\)</span></td>
<td>-17.541<sup>***</sup> (3.423)</td>
<td>-15.779<sup>***</sup> (3.461)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\alpha_{7}\)</span></td>
<td>28.472<sup>***</sup> (3.552)</td>
<td>25.985<sup>***</sup> (3.613)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\alpha_{8}\)</span></td>
<td>-27.348<sup>***</sup> (3.164)</td>
<td>-25.230<sup>***</sup> (3.202)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\alpha_{9}\)</span></td>
<td>-10.235<sup>**</sup> (4.457)</td>
<td>-7.401 (4.556)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\alpha_{10}\)</span></td>
<td>10.558<sup>***</sup> (3.327)</td>
<td>8.561<sup>**</sup> (3.396)</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\alpha_{11}\)</span></td>
<td>-22.758<sup>***</sup> (3.533)</td>
<td>-19.834<sup>***</sup> (3.569)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\alpha_{12}\)</span></td>
<td>21.864<sup>***</sup> (4.813)</td>
<td>17.771<sup>***</sup> (5.041)</td>
</tr>
<tr class="even">
<td><strong>Observations</strong></td>
<td>3,989</td>
<td>3,989</td>
</tr>
</tbody>
</table>
<p><strong>Note:</strong> <span class="math inline">\(^{*}p &lt; 0.1\)</span>; <span class="math inline">\(^{**}p &lt; 0.05\)</span>; <span class="math inline">\(^{***}p &lt; 0.01\)</span></p>
</div>
</figure>
</div>
<p>The middle column of <a href="#tbl-reg_results" class="quarto-xref">Table&nbsp;<span>3.1</span></a> shows the OLS parameter estimates and their standard errors (i.e., square root of their variances) from the OLS fit of this regression model, assuming independent errors. The standard errors suggest that longitude, latitude, and the longitude–latitude interaction, are not important in the model given all of the other variables included in the model, based on the observation that their confidence intervals cover zero. It might be surprising to think that latitude is not important here, since we saw in Chapter 2 that there is a clear latitudinal dependence in temperature for these data (it is typically cooler the further north you go in the central USA). But recall that when interpreting parameters in multiple regression we are considering their importance <em>in the presence of</em> all of the other variables in the model. Thus, this result may be due to the fact that there are interactions of the latitude effect with longitude and/or time, or it could be due to other factors. We discuss some of these below.</p>
<p>As discussed in <a href="#sec-reg_pred" class="quarto-xref"><span>Section 3.2</span></a>, the residuals from this regression fit exhibit spatio-temporal dependence, and thus the OLS assumption of independent errors is violated, which calls into question the validity of the standard errors given in the middle column of Table <a href="#tbl-reg_results" class="quarto-xref">Table&nbsp;<span>3.1</span></a>. As already mentioned, in the case of positive dependence (present in the residuals here) the standard errors are underestimated, potentially implying that a covariate is important in the model when it really is not. In the right-hand column we show the estimates and standard errors after fitting using GLS, where the covariance of the errors is assumed, <em>a priori</em>, to be a function of distance in space and time, specifically constructed from a Gaussian kernel with bandwidth 0.5 (see Lab 3.2 for details). Note that all the standard errors are larger, and some of our conclusions have changed regarding which effects are significant, and which are not.</p>
<p>Readers who are familiar with regression analysis may also recall that there are other factors that might affect the standard errors given in <a href="#tbl-reg_results" class="quarto-xref">Table&nbsp;<span>3.1</span></a>. For example, the presence of moderate to serious <em>multicollinearity</em> in the covariates (e.g., when some linear combination of <span class="math inline">\(X\)</span>s is approximately equal to one or more of the other <span class="math inline">\(X\)</span> variables) can inflate the standard errors. In Lab 3.2, we see the effect of adding another basis function, <span class="math inline">\(\phi_{13}(\mathbf{s})\)</span>, that is a slightly noisy version of <span class="math inline">\(\phi_5(\mathbf{s})\)</span>. Without <span class="math inline">\(\phi_{13}(\mathbf{s})\)</span>, the effect of <span class="math inline">\(\phi_5(\mathbf{s})\)</span> is considered significant in the model (see <a href="#tbl-reg_results" class="quarto-xref">Table&nbsp;<span>3.1</span></a>). However, the estimate of <span class="math inline">\(\alpha_5\)</span> is <em>not</em> significant at the 1% level when both <span class="math inline">\(\phi_5(\mathbf{s})\)</span> and <span class="math inline">\(\phi_{13}(\mathbf{s})\)</span> are included in the model.</p>
<p>Inference can also be affected by <em>confounding</em>, in which interpretation or significance is substantially altered when an important variable is ignored, or perhaps when an extraneous variable is included in the model. Since we typically do not know or have access to all of the important variables in a regression, this is often a problem. Indeed, one of the interpretations of dependent errors in spatial, time-series, and spatio-temporal models is that they probably represent the effects of covariates that were left out of the model. As we describe in Chapter 4, this implies that there can be confounding between the spatio-temporally dependent random errors and covariates of primary interest, which can affect parameter inference and accompanying interpretations. But, if our goal is spatio-temporal prediction, this confounding is not necessarily a bad thing, since building dependence into the model is somewhat of an “insurance policy” against our model missing important covariates.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Several excellent packages can be used to neatly display results from models in <code>R</code>, such as <strong>xtable</strong> and <strong>stargazer</strong>. All tables in this chapter were produced using <strong>stargazer</strong>.</p>
</div>
</div>
</section>
<section id="variable-selection" class="level3" data-number="3.2.3">
<h3 data-number="3.2.3" class="anchored" data-anchor-id="variable-selection"><span class="header-section-number">3.2.3</span> Variable Selection</h3>
<p>As mentioned in the previous section, it can be the case that when <span class="math inline">\(p\)</span> (the number of covariates) is fairly large, we do not believe that all of them are truly related to the response, and we are interested in choosing which are the most important. This is generally called <em>variable selection</em>. Outside the context of regression, Chapter 6 considers the more general problem of <em>model selection</em>.</p>
<p>It would be ideal if we could test all possible combinations of all <span class="math inline">\(p\)</span> covariates and determine which one gives the best predictive ability. This can be done if <span class="math inline">\(p\)</span> is small, but it quickly becomes problematic for large <span class="math inline">\(p\)</span> as there are <span class="math inline">\(2^p\)</span> possible models that would have to be considered, assuming all of them have an intercept parameter. Alternatively, we can consider a <em>best subsets</em> procedure that uses a special algorithm (such as the “leaps and bounds algorithm”) to efficiently find a few of the best models for a given number of covariates <span class="citation" data-cites="kutner2004applied">(see, for example, <a href="references.html#ref-kutner2004applied" role="doc-biblioref">Kutner et al., 2004</a>)</span>.</p>
<p>Another option is to use an automated selection algorithm such as <em>forward selection</em>. In this case, we start with a model that includes just the intercept, and then we find which covariate reduces the error sums of squares (or some other chosen model-selection criterion) the most. That covariate is added to the model, and we then consider which of the remaining <span class="math inline">\((p-1)\)</span> gives the best two-variable model. We continue this until some pre-specified stopping rule is reached. In the context of the regression with the NOAA data set, <a href="#tbl-step_results" class="quarto-xref">Table&nbsp;<span>3.2</span></a> shows the best candidate models for one to four variables (in addition to the intercept), as obtained by the forward-selection algorithm using the function <code>step</code> in <code>R</code>; here the Akaike information criterion (AIC, see Section 6.4.4) was adopted as the model-selection criterion. Note how the residual standard error decreases sharply with the inclusion of one covariate (in this case, latitude) and slowly thereafter. We have already seen that there is considerable correlation between maximum temperature and latitude, so this is not surprising. As further evidence of this, note that latitude, which was not significant in the full model, is the single most important variable according to forward stepwise selection. But when the latitude-by-day interaction term enters the model, the parameter estimate for latitude decreases noticeably. For comparison, <a href="#tbl-step_rss_results_table" class="quarto-xref">Table&nbsp;<span>3.3</span></a> shows the same forward-selection analysis but now using the residual sum of squares (RSS) as the model-selection criterion. Note that this still has latitude as the most important single variable, but the longitude-by-day interaction is the second variable entered into the model (followed by the latitude-by-day variable), and the day variable is not included. This shows that the choice of criterion can make a substantial difference when doing stepwise selection: the AIC criterion penalizes for model complexity (i.e., the number of variables in the model), whereas the RSS criterion does not.</p>
<p>Alternative stepwise methods include <em>backward-selection</em> and <em>mixed-selection</em> algorithms <span class="citation" data-cites="james2013introduction">(see <a href="references.html#ref-james2013introduction" role="doc-biblioref">James et al., 2013, Chapter 6</a>)</span>. Note that no stepwise procedure is guaranteed to give the best model other than for the single-covariate case, but these methods can provide potential candidate models that are reasonable. It is also important to realize that the forward-selection procedure can be used in the “large <span class="math inline">\(p\)</span>, small <span class="math inline">\(n\)</span>” case where one has more covariates <span class="math inline">\(p\)</span> than observations <span class="math inline">\(n\)</span>, at least up to models of size <span class="math inline">\(n-1\)</span>, which is increasingly common in “big data” statistical-learning applications <span class="citation" data-cites="james2013introduction">(<a href="references.html#ref-james2013introduction" role="doc-biblioref">James et al., 2013</a>)</span>. (Note that in this book we prefer to use <span class="math inline">\(m\)</span> instead of <span class="math inline">\(n\)</span> to represent sample size for spatio-temporal data.)</p>
<p>The subset-selection methods discussed above penalize model complexity at the expense of model fit by removing variables. This is a manifestation of a common problem in statistics, balancing the trade-off between variance and bias. That is, these methods trade some bias for variance reduction by removing variables. Another approach to this problem in regression is to constrain the least squares estimates in such a way that the regression coefficients are <em>regularized</em> (or shrunk) towards zero, hence adding bias. The two most-used approaches for regularization in regression are <em>ridge regression</em> and the <em>lasso</em>. These are briefly described in <a href="#nte-technote-RidgeLassoReg" class="quarto-xref">Note&nbsp;<span>3.4</span></a>.</p>
<div id="tbl-step_results" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-step_results-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;3.2: Estimated regression coefficients for the linear regression model of <a href="#sec-reg_pred" class="quarto-xref"><span>Section 3.2</span></a> when using ordinary least squares to estimate the parameters and forward selection based on the AIC, starting from the intercept-only model. One, two, and three asterisks are used to denote significance at the 10%, 5%, and 1% levels of significance, respectively. Note that the residual standard error when fitting the full model (<span class="math inline">\(p=18\)</span>) was <span class="math inline">\(4.230\)</span>.
</figcaption>
<div aria-describedby="tbl-step_results-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 14%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 17%">
<col style="width: 17%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>(1)</th>
<th>(2)</th>
<th>(3)</th>
<th>(4)</th>
<th>(5)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Intercept</td>
<td>88.673<sup>***</sup></td>
<td>148.940<sup>***</sup></td>
<td>147.840<sup>***</sup></td>
<td>136.810<sup>***</sup></td>
<td>138.420<sup>***</sup></td>
</tr>
<tr class="even">
<td>Latitude</td>
<td></td>
<td>-1.559<sup>***</sup></td>
<td>-1.559<sup>***</sup></td>
<td>-1.274<sup>***</sup></td>
<td>-1.273<sup>***</sup></td>
</tr>
<tr class="odd">
<td>Day</td>
<td></td>
<td></td>
<td>0.069<sup>***</sup></td>
<td>0.755<sup>***</sup></td>
<td>0.755<sup>***</sup></td>
</tr>
<tr class="even">
<td>Latitude × Day</td>
<td></td>
<td></td>
<td></td>
<td>-0.018<sup>***</sup></td>
<td>-0.018<sup>***</sup></td>
</tr>
<tr class="odd">
<td>Longitude</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0.019</td>
</tr>
<tr class="even">
<td><strong>Observations</strong></td>
<td>3,989</td>
<td>3,989</td>
<td>3,989</td>
<td>3,989</td>
<td>3,989</td>
</tr>
<tr class="odd">
<td><strong>Residual Std. Error</strong></td>
<td>7.726</td>
<td>4.710</td>
<td>4.669</td>
<td>4.626</td>
<td>4.625</td>
</tr>
</tbody>
</table>
<p><strong>Note:</strong> <span class="math inline">\(^{*}p &lt; 0.1\)</span>; <span class="math inline">\(^{**}p &lt; 0.05\)</span>; <span class="math inline">\(^{***}p &lt; 0.01\)</span></p>
</div>
</figure>
</div>
<div id="tbl-step_rss_results_table" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-step_rss_results_table-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;3.3: Same as <a href="#tbl-step_results" class="quarto-xref">Table&nbsp;<span>3.2</span></a> but using a forward-selection criterion given by the total residual sum of squares.
</figcaption>
<div aria-describedby="tbl-step_rss_results_table-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 20%">
<col style="width: 14%">
<col style="width: 15%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>(1)</th>
<th>(2)</th>
<th>(3)</th>
<th>(4)</th>
<th>(5)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Intercept</td>
<td>88.673<sup>***</sup></td>
<td>148.940<sup>***</sup></td>
<td>147.780<sup>***</sup></td>
<td>140.420<sup>***</sup></td>
<td>122.020<sup>***</sup></td>
</tr>
<tr class="even">
<td>Latitude</td>
<td></td>
<td>-1.559<sup>***</sup></td>
<td>-1.560<sup>***</sup></td>
<td>-1.366<sup>***</sup></td>
<td>-0.838<sup>***</sup></td>
</tr>
<tr class="odd">
<td>Longitude × Day</td>
<td></td>
<td></td>
<td>-0.001<sup>***</sup></td>
<td>-0.006<sup>***</sup></td>
<td>-0.011<sup>***</sup></td>
</tr>
<tr class="even">
<td>Latitude × Day</td>
<td></td>
<td></td>
<td></td>
<td>-0.012<sup>***</sup></td>
<td>-0.023<sup>***</sup></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\alpha_{10}\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>-6.927<sup>***</sup></td>
</tr>
<tr class="even">
<td><strong>Observations</strong></td>
<td>3,989</td>
<td>3,989</td>
<td>3,989</td>
<td>3,989</td>
<td>3,989</td>
</tr>
<tr class="odd">
<td><strong>Residual Std. Error</strong></td>
<td>7.726</td>
<td>4.710</td>
<td>4.661</td>
<td>4.607</td>
<td>4.470</td>
</tr>
</tbody>
</table>
<p><strong>Note:</strong> <span class="math inline">\(^{*}p &lt; 0.1\)</span>; <span class="math inline">\(^{**}p &lt; 0.05\)</span>; <span class="math inline">\(^{***}p &lt; 0.01\)</span></p>
</div>
</figure>
</div>
<div id="nte-technote-RidgeLassoReg" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;3.4: Ridge and Lasso Regression
</div>
</div>
<div class="callout-body-container callout-body">
<p>Recall that the OLS spatio-temporal regression estimates are found by minimizing the RSS given in <a href="#eq-RegRSS" class="quarto-xref">Equation&nbsp;<span>3.7</span></a>. One can consider a <em>regularization</em> in which a penalty term is added to the RSS that effectively <em>shrinks</em> the regression parameter estimates towards zero. Specifically, consider estimates of <span class="math inline">\(\boldsymbol{\beta}\)</span> that come from a penalized (regularization) form of the RSS given by</p>
<p><span id="eq-RegRSSridge"><span class="math display">\[
\sum_{j=1}^T \sum_{i=1}^{m} \left[Z(\mathbf{s}_{i};t_j) - (\beta_0 + \beta_1 X_1(\mathbf{s}_{i};t_j) + \ldots + \beta_p X_p(\mathbf{s}_{i};t_j))\right]^2 +  \lambda \sum_{\ell=1}^p |\beta_\ell|^q,
\tag{3.9}\]</span></span></p>
<p>where <span class="math inline">\(\lambda\)</span> is a tuning parameter and <span class="math inline">\(\sum_{\ell=1}^p |\beta_\ell|^q\)</span> is the penalty term. Note that the penalty term does not include the intercept parameter <span class="math inline">\(\beta_0\)</span>. When <span class="math inline">\(q=2\)</span>, the estimates, say <span class="math inline">\(\widehat{\boldsymbol{\beta}}_R\)</span>, are said to be <em>ridge regression</em> estimates, and when <span class="math inline">\(q=1\)</span> the estimates, say <span class="math inline">\(\widehat{\boldsymbol{\beta}}_L\)</span>, are <em>lasso</em> estimates. Clearly, <span class="math inline">\(q=2\)</span> corresponds to the square of an <span class="math inline">\(L_2\)</span>-norm penalty and <span class="math inline">\(q=1\)</span> corresponds to an <span class="math inline">\(L_1\)</span>-norm penalty; recall that the <span class="math inline">\(L_2\)</span>-norm of a vector <span class="math inline">\(\mathbf{a}= (a_1,\ldots,a_q)'\)</span> is given by <span class="math inline">\(\sqrt{\sum_{k=1}^q a_k^2}\)</span>, and the <span class="math inline">\(L_1\)</span>-norm is given by <span class="math inline">\(\sum_{k=1}^q | a_k|\)</span>.</p>
<p>Thus, minimizing <a href="#eq-RegRSSridge" class="quarto-xref">Equation&nbsp;<span>3.9</span></a> with respect to the regression coefficients subject to these penalty constraints attempts to balance the model fit (variance) given by the first term and shrinking the parameters towards zero (adding bias) via the penalty term. It is clear that both the ridge-regression estimates, <span class="math inline">\(\widehat{\boldsymbol{\beta}}_R\)</span>, and the lasso estimates, <span class="math inline">\(\widehat{\boldsymbol{\beta}}_L\)</span>, should be closer to zero than the equivalent OLS estimates. (When <span class="math inline">\(\lambda = 0\)</span>, the ridge or lasso estimates are just the OLS estimates.) A potential advantage of the lasso is that it can shrink parameters <em>exactly</em> to zero (unlike ridge regression, which only shrinks towards zero). This provides a more explicit form of variable selection. More general {regularization} in regression can be achieved by assigning prior distributions to the parameters <span class="math inline">\(\boldsymbol{\beta}\)</span> and considering the analysis from a Bayesian perspective. Indeed, both ridge and lasso regression have equivalent Bayesian formulations. In practice, one selects the tuning parameter <span class="math inline">\(\lambda\)</span> by cross-validation. Note also that these penalized regression estimates are not scale-invariant, so one typically scales (and centers) the <span class="math inline">\(X\)</span>s when implementing ridge or lasso regression. See <span class="citation" data-cites="james2013introduction">James et al. (<a href="references.html#ref-james2013introduction" role="doc-biblioref">2013</a>)</span> for more information about these procedures.</p>
</div>
</div>
</section>
</section>
<section id="spatio-temporal-forecasting" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="spatio-temporal-forecasting"><span class="header-section-number">3.3</span> Spatio-Temporal Forecasting</h2>
<p>As an example of the third goal of spatio-temporal modeling, suppose we want to forecast the sea surface temperature (SST) in the tropical Pacific Ocean six months from now. For example, the top left panel of <a href="#fig-SSTaproct97" class="quarto-xref">Figure&nbsp;<span>3.10</span></a> shows SST anomalies, which are just deviations from long-term monthly averages, for April 1997, and the bottom right panel shows the SST anomalies for October 1997. You might ask why we would be interested in predicting SST six months ahead. As it turns out, the so-called El Niño Southern Oscillation (ENSO) phenomenon is in this region, which is characterized by frequent (but not regular) periods of warmer-than-normal and cooler-than-normal ocean temperatures, and ENSO has a dramatic effect on worldwide weather patterns and associated impacts (e.g., droughts, floods, tropical storms, tornadoes). Thus, being able to predict these warmer (El Niño) or cooler (La Niña) periods can help with resource and disaster planning. The series of plots shown in <a href="#fig-SSTaproct97" class="quarto-xref">Figure&nbsp;<span>3.10</span></a> corresponds to a major El Niño event.</p>
<div id="fig-SSTaproct97" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-SSTaproct97-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_3/SST_1997.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-SSTaproct97-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.10: Tropical Pacific Ocean SST anomalies for April, June, August, and October 1997. This series of plots shows the onset of the extreme El Niño event that happened in the Northern Hemisphere in the fall of 1997.
</figcaption>
</figure>
</div>
<p>One way we might try to forecast the SST anomalies into the future is to use regression. For example, the Southern Oscillation Index (SOI) is a well-known indicator of ENSO that is regularly recorded; here we consider it at monthly time steps. In what follows, we use the SOI index at time <span class="math inline">\(t\)</span> (e.g., April 1997) to forecast the SST at time <span class="math inline">\(t+\tau\)</span> (e.g., October 1997, where <span class="math inline">\(\tau = 6\)</span> months). We do this for each spatial location separately, so that each oceanic pixel in the domain shown in <a href="#fig-SSTaproct97" class="quarto-xref">Figure&nbsp;<span>3.10</span></a> gets its own simple linear regression (including an intercept coefficient and a coefficient corresponding to the lagged SOI value). The top panels in <a href="#fig-SSTsoipred" class="quarto-xref">Figure&nbsp;<span>3.11</span></a> show the intercept (left) and SOI regression coefficient (right) for the regression fit at each location. Note the fairly distinct pattern in these coefficients that corresponds to the El Niño warm region in <a href="#fig-SSTaproct97" class="quarto-xref">Figure&nbsp;<span>3.10</span></a> – clearly, these estimated regression coefficients exhibit quite strong spatial dependencies. The middle panels in <a href="#fig-SSTsoipred" class="quarto-xref">Figure&nbsp;<span>3.11</span></a> show contour plots of the actual anomalies for October 1997 (left), as well as the pixelwise simple-linear-regression forecast based on SOI from April 1997 (right; note the different color scale). The associated regression-forecast prediction standard error (see <a href="#nte-technote-matReg" class="quarto-xref">Note&nbsp;<span>3.3</span></a>) is given in the bottom panel.</p>
<p>It is clear that although the forecast in the middle-right panel of <a href="#fig-SSTaproct97" class="quarto-xref">Figure&nbsp;<span>3.10</span></a> captures the broad El Niño feature, it is very biased towards a cooler anomaly than that observed. This illustrates that we likely need additional information to perform a long-lead forecast of SST, something we discuss in more detail using dynamic models in Chapter 5. This example also shows that it might be helpful to account for the fact that these regression-coefficient estimates show such strong spatial dependence. This is often the case in time-series regressions at nearby spatial locations, and we shall see another example of this in <a href="Chapter4.html#sec-basisfunctions" class="quarto-xref"><span>Section 4.4</span></a>.</p>
<div id="fig-SSTsoipred" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-SSTsoipred-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_3/SST_Oct_1997_combined.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-SSTsoipred-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.11: Top: Spatially varying estimated intercept (left) and spatially varying estimated regression coefficient of lagged SOI (right) in a simple linear regression of lagged SOI on the SST anomalies at each oceanic spatial location (fitted individually). Middle: Contour plots of SST anomalies for October 1997 (left) and six-month-ahead forecast (right) based on a simple linear regression model regressed on the SOI value in April 1997. Note the different color scales. Bottom: Prediction standard error for the forecast (see <a href="#nte-technote-matReg" class="quarto-xref">Note&nbsp;<span>3.3</span></a>).
</figcaption>
</figure>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Fitting multiple models to groups of data in a single data frame in long format has been made easy and computationally efficient using functions in the packages <strong>tidyr</strong>, <strong>purrr</strong>, and <strong>broom</strong>. Take a look at Labs 3.2 and 3.3 to see how multiple models, predictions, and tests can be easily carried out using these packages.</p>
</div>
</div>
</section>
<section id="non-gaussian-errors" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="non-gaussian-errors"><span class="header-section-number">3.4</span> Non-Gaussian Errors</h2>
<p>You have probably already heard about the normal distribution that was used to describe the regression errors in the previous sections. The name “normal” seems to imply that any other distribution is abnormal – not so! Data that are binary or counts or skewed are common and of great interest to scientists and statisticians. Consequently, in spatial and spatio-temporal statistics we use the terminology <em>Gaussian distribution</em> and “Gau” instead of “<span class="math inline">\(N\)</span>,” which falls into line with the well-known Gaussian processes defined in time or in Euclidean space (see <a href="Chapter4.html#sec-GaussDataProc" class="quarto-xref"><span>Section 4.2</span></a>). There are many off-the-shelf methods that can be used for non-Gaussian modeling – both from the statistics perspective and from the machine-learning perspective. By “machine learning” we are referring to methods that do not explicitly account for the <em>random</em> spatio-temporal nature of the data. From the statistical perspective, we could simply use a <em>generalized linear model</em> (GLM) or a <em>generalized additive model</em> (GAM) to analyze spatio-temporal data.</p>
<section id="sec-GLMGAM" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="sec-GLMGAM"><span class="header-section-number">3.4.1</span> Generalized Linear Models and Generalized Additive Models</h3>
<p>The basic GLM has two components, a random component and a systematic component. The random component assumes that observations, conditioned on their respective means and (in some cases) scaling parameters, are independent and come from the <em>exponential family</em> of distributions. That is,</p>
<p><span id="eq-basicglm"><span class="math display">\[
Z(\mathbf{s}_{i};t_j) | Y(\mathbf{s}_{i};t_j), \gamma \; \sim \; \text{indep.} \; EF(Y(\mathbf{s}_{i};t_j);\gamma),
\tag{3.10}\]</span></span></p>
<p>where <span class="math inline">\(EF( \cdot)\)</span> refers to the exponential family, <span class="math inline">\(Y(\mathbf{s}_{i};t_j)\)</span> is the mean, and <span class="math inline">\(\gamma\)</span> is a scale parameter <span class="citation" data-cites="mcculloch2001generalized">(see <a href="references.html#ref-mcculloch2001generalized" role="doc-biblioref">McCulloch &amp; Searle, 2001</a> for for details)</span>. Members of the exponential family include common distributions such as the normal (Gaussian), Poisson, binomial, and gamma distributions.</p>
<p>The systematic component of the GLM then specifies a relationship between the mean response and the covariates. In particular, the systematic component consists of a <em>link function</em> that transforms the mean response and then expresses this transformed mean in terms of a linear function of the covariates. In our notation, this is given by</p>
<p><span id="eq-glmlink"><span class="math display">\[
g(Y(\mathbf{s};t)) = \beta_0 + \beta_1 X_1(\mathbf{s};t) + \beta_2 X_2(\mathbf{s};t) + \ldots + \beta_p X_p(\mathbf{s};t),
\tag{3.11}\]</span></span></p>
<p>where <span class="math inline">\(g(\cdot)\)</span> is some specified monotonic link function. Note that in a classic GLM there is no additive random effect term in <a href="#eq-glmlink" class="quarto-xref">Equation&nbsp;<span>3.11</span></a>, but this can be added to make the model a <em>generalized linear mixed model</em> (GLMM), where “mixed” refers to having both fixed and random effects in the model for <span class="math inline">\(g(Y(\mathbf{s};t))\)</span>.</p>
<p>The GAM is also composed of a random component and a systematic component. The random component is the same as for the GLM, namely <a href="#eq-basicglm" class="quarto-xref">Equation&nbsp;<span>3.10</span></a>. In addition, like the GLM, the systematic component of the GAM also considers a transformation of the mean response related to the covariates, but it assumes a more flexible function of the covariates. That is,</p>
<p><span id="eq-gamlink"><span class="math display">\[
g(Y(\mathbf{s};t)) = \beta_0 +  f_1(X_1(\mathbf{s};t)) + f_2(X_2(\mathbf{s};t)) + \ldots + f_p(X_p(\mathbf{s};t)),
\tag{3.12}\]</span></span></p>
<p>where the functions <span class="math inline">\(\{f_k(\cdot)\}\)</span> can have a specified parametric form (such as polynomials in the covariate), or, more generally, they can be some smooth function specified semi-parametrically or nonparametrically. Often, <span class="math inline">\(f_k(\cdot)\)</span> is written as a basis expansion <span class="citation" data-cites="R_mgcv">(see <a href="references.html#ref-R_mgcv" role="doc-biblioref">Wood, 2017</a> for more details)</span>. Thus, the GLM is a special parametric case of the GAM. These models can be quite flexible. Again, note that a random effect can be added to <a href="#eq-gamlink" class="quarto-xref">Equation&nbsp;<span>3.12</span></a>, as with the GLM, in which case the model becomes a <em>generalized additive mixed model</em> (GAMM).</p>
<p>As with normal (Gaussian) error regression, so long as covariates (or functions of these in the case of GAMs) are available at any location in the space-time domain, GLMs or GAMs can be used for spatio-temporal prediction. Whether or not this accommodates sufficiently the dependence in the observations depends on the specific data set and the covariates that are available. A straightforward way to fit a GLM in <code>R</code> is to use the function <code>glm</code>. In Lab 3.4 we fit a GLM to the Carolina wren counts in the BBS data set, where we assume a Poisson response and a log link. We consider the same classes of covariates used in the regression example in <a href="#sec-reg_pred" class="quarto-xref"><span>Section 3.2</span></a>, where the response was <code>Tmax</code> in the NOAA data set. The latent mean surface is given by <a href="#eq-glmlink" class="quarto-xref">Equation&nbsp;<span>3.11</span></a> (with estimated regression parameters <span class="math inline">\(\boldsymbol{\beta}\)</span>) and is illustrated in <a href="#fig-GLMfit_Wren" class="quarto-xref">Figure&nbsp;<span>3.12</span></a>. This latent spatial surface captures the large-scale trends, but it is unable to reproduce the small-scale spatial and temporal fluctuations in the Carolina wren intensity, and the residuals show both temporal and spatial correlation. We could accommodate this additional dependence structure by adding more basis functions and treating their regression coefficients as fixed effects, but this will likely result in overfitting. In Chapter 4 we explore the use of random effects to circumvent this problem.</p>
<div id="fig-GLMfit_Wren" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-GLMfit_Wren-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_3/GLMfit_Wren.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-GLMfit_Wren-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.12: Prediction of <span class="math inline">\(\log Y(\cdot)\)</span> for the Carolina wren sighting data set on a grid between <span class="math inline">\(t=1\)</span> (the year 1994) and <span class="math inline">\(t=21\)</span> (2014) based on a Poisson response model, implemented with the function <code>glm</code>. The log of the observed count is shown in circles using the same color scale.
</figcaption>
</figure>
</div>
<p>Recall that it is useful to consider residuals in the linear-regression context to evaluate the model fit and potential violations of model assumptions. In the context of GLMs, we typically consider a special type of residual when the data are not assumed to come from a Gaussian distribution. <a href="#nte-technote-Dev_residuals" class="quarto-xref">Note&nbsp;<span>3.5</span></a> defines so-called <em>deviance residuals</em> and <em>Pearson (chi-squared) residuals</em>, which are often used for GLM model evaluation <span class="citation" data-cites="mccullagh1989generalized">(see, for example, <a href="references.html#ref-mccullagh1989generalized" role="doc-biblioref">McCullagh &amp; Nelder, 1989</a>)</span>. Heuristically, examining these residuals for spatio-temporal structure can often suggest that additional spatial, temporal, or spatio-temporal random effects are needed in the model, or that a different response model is warranted (e.g., to account for over-dispersion; see Lab 3.4).</p>
<div id="nte-technote-Dev_residuals" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;3.5: Deviance and Pearson Residuals
</div>
</div>
<div class="callout-body-container callout-body">
<p>One way to consider the agreement between a model and data is to compare the predictions of the model to a “saturated” model that fits the data exactly. In GLMs, this corresponds to the notion of <em>deviance</em>. Specifically, suppose we have a model for an <span class="math inline">\(m\)</span>-dimensional vector of data <span class="math inline">\(\mathbf{Z}\)</span> that depends on parameters <span class="math inline">\(\boldsymbol{\theta}_{\mathrm{model}}\)</span> and has a log-likelihood given by <span class="math inline">\(\ell(\mathbf{Z};\boldsymbol{\theta}_{\mathrm{model}})\)</span>. We then define the deviance as</p>
<p><span class="math display">\[
D(\mathbf{Z};\widehat{\boldsymbol{\theta}}_{\mathrm{model}}) = 2 \{ \ell(\mathbf{Z}; \widehat{\boldsymbol{\theta}}_{\mathrm{sat}}) - \ell(\mathbf{Z};\widehat{\boldsymbol{\theta}}_{\mathrm{model}}) \} =   \sum_{i=1}^m D(Z_i;\widehat{\boldsymbol{\theta}}_{\mathrm{model}}),
\]</span></p>
<p>where <span class="math inline">\(\ell(\mathbf{Z};\widehat{\boldsymbol{\theta}}_{\mathrm{sat}})\)</span> is the log-likelihood for the so-called <em>saturated model</em>, which is the model that has one parameter per observation (i.e., that fits the data exactly). Note that <span class="math inline">\(D(Z_i;\widehat{\boldsymbol{\theta}}_{\mathrm{model}})\)</span> corresponds to the contribution of observation <span class="math inline">\(Z_i\)</span> to the deviance given the parameter estimates <span class="math inline">\(\boldsymbol{\theta}_{\mathrm{model}}\)</span>. The deviance is just 2 times the log-likelihood <em>ratio</em> of the full (saturated) model relative to the reduced model of interest. We then define the <em>deviance residual</em> as</p>
<p><span id="eq-Devresid"><span class="math display">\[
r_{d,i} \equiv \mbox{sign}(Z_i - \widehat{\mu}_i) \sqrt{D(Z_i;\widehat{\boldsymbol{\theta}}_{\mathrm{model}})},
\tag{3.13}\]</span></span></p>
<p>where <span class="math inline">\(\widehat{\mu}_i\)</span> corresponds to <span class="math inline">\(E(Z_i | \widehat{\boldsymbol{\theta}}_{\mathrm{model}})\)</span>, the estimate of the mean response from the model given parameter estimates, <span class="math inline">\(\widehat{\boldsymbol{\theta}}_{\mathrm{model}}\)</span>. The <span class="math inline">\(\mbox{sign}(\cdot)\)</span> function in <a href="#eq-Devresid" class="quarto-xref">Equation&nbsp;<span>3.13</span></a> assigns the sign of the residual to indicate whether the mean response is less than or greater than the observation. In practice, we often consider standardized deviance residuals <span class="citation" data-cites="mccullagh1989generalized">(see, for example, <a href="references.html#ref-mccullagh1989generalized" role="doc-biblioref">McCullagh &amp; Nelder, 1989</a>)</span>.</p>
<p>Alternatively, we can define a standardized residual that more directly considers the difference between the data and the estimated mean response. That is,</p>
<p><span class="math display">\[
r_{p,i} \equiv \frac{(Z_i - \widehat{\mu}_i)^2}{V(\widehat{\mu}_i)},
\]</span></p>
<p>where <span class="math inline">\(V(\widehat{\mu}_i)\)</span> is called the <em>variance function</em>, and it is generally a function of the mean response (except when the likelihood is Gaussian). The specific form of the variance function depends on the form of the data likelihood. The unsigned residual, <span class="math inline">\(r_{p,i}\)</span>, is known as a Pearson residual (or Pearson chi-squared residual) because the sum of these residuals for all <span class="math inline">\(i=1,\ldots,m\)</span> gives a Pearson chi-squared statistic, which can be used for formal hypothesis tests of model adequacy <span class="citation" data-cites="mccullagh1989generalized">(see, for example, <a href="references.html#ref-mccullagh1989generalized" role="doc-biblioref">McCullagh &amp; Nelder, 1989</a>)</span>.</p>
</div>
</div>
</section>
</section>
<section id="sec-HSTmods" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="sec-HSTmods"><span class="header-section-number">3.5</span> Hierarchical Spatio-Temporal Statistical Models</h2>
<p>The previous sections showed that it may be possible to accomplish the goals of spatio-temporal modeling without using specialized methodology. However, it was also clear from those examples that there are some serious limitations with the standard methodology. In particular, our methods should be able to include measurement uncertainty explicitly, they should have the ability to predict at locations in time or space, and they should allow us to perform parameter inference when there are dependent errors. In the remainder of this book, we shall describe models that can deal with these problems.</p>
<p>To put our spatio-temporal statistical models into perspective, we consider a hierarchical spatio-temporal model that includes at least two stages. Specifically,</p>
<p><span id="eq-obs"><span class="math display">\[
\text{observations} \; = \; \text{true process} \;\; + \;\; \text{observation error}
\tag{3.14}\]</span></span> <span id="eq-proc"><span class="math display">\[
\text{true process} \; = \; \text{regression component} \;\; + \;\; \text{dependent random process},
\tag{3.15}\]</span></span></p>
<p>where <a href="#eq-obs" class="quarto-xref">Equation&nbsp;<span>3.14</span></a> and <a href="#eq-proc" class="quarto-xref">Equation&nbsp;<span>3.15</span></a> are the first two stages of the hierarchical-statistical-model paradigm presented in Chapter 1. There are two general approaches to modeling the last term in <a href="#eq-proc" class="quarto-xref">Equation&nbsp;<span>3.15</span></a>: the <em>descriptive</em> approach and the <em>dynamic</em> approach; see <a href="Chapter1.html#sec-approaches" class="quarto-xref"><span>Section 1.2.1</span></a>. The descriptive approach is considered in Chapter 4 and offers a more traditional perspective. In that case, the dependent random process in <a href="#eq-proc" class="quarto-xref">Equation&nbsp;<span>3.15</span></a> is defined in terms of the first-order and second-order moments (means, variances, and covariances) of its marginal distribution. This framework is not particularly concerned with the underlying causal structure that leads to dependence in the random process. Rather, it is most useful for the first two goals presented in <a href="Chapter1.html#sec-goals" class="quarto-xref"><span>Section 1.2</span></a>: spatio-temporal prediction and parameter inference.</p>
<p>In contrast, we consider the dynamic approach in Chapter 5. In that case, the modeling effort is focused on conditional distributions that describe the evolution of the dependent random process in time; it is most useful for the third goal - forecasting (but also can be used for the other two goals). We note that the conditional perspective can also be considered in the context of mixed-effects descriptive models, with or without a dynamic specification, as we discuss in <a href="Chapter4.html#sec-basisfunctions" class="quarto-xref"><span>Section 4.4</span></a>.</p>
</section>
<section id="chapter-3-wrap-up" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="chapter-3-wrap-up"><span class="header-section-number">3.6</span> Chapter 3 Wrap-Up</h2>
<p>The primary purpose of this chapter was to discuss in detail the three goals of spatio-temporal statistical modeling: predicting at a new location in space given spatio-temporal data; doing parameter inference with spatio-temporal data; and forecasting a new value at a future time. We have also emphasized the importance of quantifying the uncertainty in our predictions, parameter estimates, and forecasts. We showed that deterministic methods for spatio-temporal prediction are sensible in that they typically follow Tobler’s law and give more weight to nearby observations in space and time; however, they do not provide direct estimates of the prediction uncertainty. We then showed that one could use a (linear) regression model with spatio-temporal data and that, as long as the residuals do not have spatio-temporal dependence, it is easy to obtain statistically optimal predictions and, potentially, statistically optimal forecasts. With respect to parameter inference, we showed that the linear-regression approach is again relevant but that our inference can be misleading in the presence of unmodeled extra variation, dependent errors, multicollinearity, and confounding. Finally, we showed that standard generalized linear models or generalized additive models can be used for many problems with non-Gaussian data. But again, without random effects to account for extra variation and dependence, these models are likely to give inappropriate prediction uncertainty and inferences.</p>
<p>The methods presented in this chapter are very common throughout the literature, and the references provided in the chapter are excellent places to find additional background material. Of course, topics such as interpolation, regression, and generalized linear models are discussed in a wide variety of textbooks and online resources, and the interested reader should have no trouble finding additional references.</p>
<p>In the next two chapters, we explore what to do when there <em>is</em> spatio-temporal dependence beyond what can be explained by covariates. We shall cover descriptive models that focus more on the specification of spatio-temporal covariance functions in Chapter 4, and dynamic models that focus explicitly on the evolution of spatial processes through time in Chapter 5. These two chapters together make up the “protein” in the book, and the material in them will have a decidedly more technical flavor. More powerful, more flexible, but more complex, dependent processes require a higher technical level than is usually found in introductory statistical-modeling courses. That said, we maintain an emphasis on describing the motivations for our methods and on their implementation in the associated <strong>R</strong> Labs.</p>
</section>
<section id="lab-3.1-deterministic-prediction-methods" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="lab-3.1-deterministic-prediction-methods">Lab 3.1: Deterministic Prediction Methods</h2>
<section id="inverse-distance-weighting" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="inverse-distance-weighting">Inverse Distance Weighting</h3>
<p>Inverse distance weighting (IDW) is one of the simplest deterministic spatio-temporal interpolation methods. It can be implemented easily in <code>R</code> using the function <code>idw</code> in the package <strong>gstat</strong>, or from scratch, and in this Lab we shall demonstrate both approaches. We require the following packages.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"dplyr"</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"fields"</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggplot2"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"gstat"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"RColorBrewer"</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"sp"</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"spacetime"</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"STRbook"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We consider the maximum temperature field in the NOAA data set for the month of July 1993. These data can be obtained from the data <code>NOAA_df_1990</code> using the <code>filter</code> function in <strong>dplyr</strong>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"NOAA_df_1990"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>Tmax <span class="ot">&lt;-</span> <span class="fu">filter</span>(NOAA_df_1990,       <span class="co"># subset the data</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>              proc <span class="sc">==</span> <span class="st">"Tmax"</span> <span class="sc">&amp;</span>     <span class="co"># only max temperature</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>              month <span class="sc">==</span> <span class="dv">7</span> <span class="sc">&amp;</span>         <span class="co"># July</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>              year <span class="sc">==</span> <span class="dv">1993</span>)        <span class="co"># year of 1993</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We next construct the three-dimensional spatio-temporal prediction grid using <code>expand.grid</code>. We consider a 20 <span class="math inline">\(\times\)</span> 20 grid in longitude and latitude and a sequence of 6 days regularly arranged in the month.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>pred_grid <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(<span class="at">lon =</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="dv">100</span>, <span class="sc">-</span><span class="dv">80</span>, <span class="at">length =</span> <span class="dv">20</span>),</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>                         <span class="at">lat =</span> <span class="fu">seq</span>(<span class="dv">32</span>, <span class="dv">46</span>, <span class="at">length =</span> <span class="dv">20</span>),</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>                         <span class="at">day =</span> <span class="fu">seq</span>(<span class="dv">4</span>, <span class="dv">29</span>, <span class="at">length =</span> <span class="dv">6</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The function in <strong>gstat</strong> that does the inverse distance weighting, <code>idw</code>, takes the following arguments: <code>formula</code>, which identifies the variable to interpolate; <code>locations</code>, which identifies the spatial and temporal variables; <code>data</code>, which can take the data in a data frame; <code>newdata</code>, which contains the space-time grid locations at which to interpolate; and <code>idp</code>, which corresponds to <span class="math inline">\(\alpha\)</span> in <a href="#eq-IDWw" class="quarto-xref">Equation&nbsp;<span>3.3</span></a>. The larger <span class="math inline">\(\alpha\)</span> (<code>idp</code>) is, the less the smoothing. This parameter is typically set using cross-validation, which we explore later in this Lab; here we fix <span class="math inline">\(\alpha = 5\)</span>. We run <code>idw</code> below with the variable <code>Tmax</code>, omitting data on 14 July 1993.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>Tmax_no_14 <span class="ot">&lt;-</span> <span class="fu">filter</span>(Tmax, <span class="sc">!</span>(day <span class="sc">==</span> <span class="dv">14</span>))         <span class="co"># remove day 14</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>Tmax_July_idw <span class="ot">&lt;-</span> <span class="fu">idw</span>(<span class="at">formula =</span> z <span class="sc">~</span> <span class="dv">1</span>,            <span class="co"># dep. variable</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>                     <span class="at">locations =</span> <span class="sc">~</span> lon <span class="sc">+</span> lat <span class="sc">+</span> day, <span class="co"># inputs</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>                     <span class="at">data =</span> Tmax_no_14,          <span class="co"># data set</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>                     <span class="at">newdata =</span> pred_grid,        <span class="co"># prediction grid</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>                     <span class="at">idp =</span> <span class="dv">5</span>)                    <span class="co"># inv. dist. pow.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The output <code>Tmax_July_idw</code> contains the fields <code>lon</code>, <code>lat</code>, <code>day</code>, and <code>var1.pred</code> corresponding to the IDW interpolation over the prediction grid. This data frame can be plotted using <strong>ggplot2</strong> commands as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(Tmax_July_idw) <span class="sc">+</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_tile</span>(<span class="fu">aes</span>(<span class="at">x =</span> lon, <span class="at">y =</span> lat,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>                  <span class="at">fill =</span> var1.pred)) <span class="sc">+</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fill_scale</span>(<span class="at">name =</span> <span class="st">"degF"</span>) <span class="sc">+</span>    <span class="co"># attach color scale</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">xlab</span>(<span class="st">"Longitude (deg)"</span>) <span class="sc">+</span>           <span class="co"># x-axis label</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ylab</span>(<span class="st">"Latitude (deg)"</span>) <span class="sc">+</span>            <span class="co"># y-axis label</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">facet_wrap</span>(<span class="sc">~</span> day, <span class="at">ncol =</span> <span class="dv">3</span>) <span class="sc">+</span>       <span class="co"># facet by day</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">coord_fixed</span>(<span class="at">xlim =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">100</span>, <span class="sc">-</span><span class="dv">80</span>),</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                <span class="at">ylim =</span> <span class="fu">c</span>(<span class="dv">32</span>, <span class="dv">46</span>))  <span class="sc">+</span>    <span class="co"># zoom in</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_bw</span>()                          <span class="co"># B&amp;W theme</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A similar plot to the one above, but produced using <code>stplot</code> instead, is shown in the left panel of <a href="#fig-pred_IDW_Gauss" class="quarto-xref">Figure&nbsp;<span>3.2</span></a>. Notice how the day with missing data is “smoothed out” when compared to the others. As an exercise, you can redo IDW including the 14 July 1993 in the data set, and observe how the prediction changes for that day.</p>
<section id="implementing-idw-from-first-principles" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="implementing-idw-from-first-principles">Implementing IDW from First Principles</h4>
<p>It is often preferable to implement simple algorithms, like IDW, from scratch, as doing so increases code versatility (e.g., it facilitates implementation of a cross-validation study). Reducing dependence on other packages will also help the code last the test of time (as it becomes immune to package changes).</p>
<p>We showed that IDW is a kernel predictor and yields the kernel weights given by <a href="#eq-IDW" class="quarto-xref">Equation&nbsp;<span>3.1</span></a>. To construct these kernel weights we first need to find the distances between all prediction locations and data locations, take their reciprocals and raise them to the power (<code>idp</code>) of <span class="math inline">\(\alpha\)</span>. Pairwise distances between two arbitrary sets of points are most easily computed using the <code>rdist</code> function in the package <strong>fields</strong>. Since we wish to generate these kernel weights for different observation and prediction sets and different bandwidth parameters, we create a function <code>Wt_IDW</code> that generates the required kernel-weights matrix.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>pred_obs_dist_mat <span class="ot">&lt;-</span> <span class="fu">rdist</span>(<span class="fu">select</span>(pred_grid, lon, lat, day),</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>                           <span class="fu">select</span>(Tmax_no_14, lon, lat, day))</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>Wt_IDW <span class="ot">&lt;-</span> <span class="cf">function</span>(theta, dist_mat) <span class="dv">1</span><span class="sc">/</span>dist_mat<span class="sc">^</span>theta</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>Wtilde <span class="ot">&lt;-</span> <span class="fu">Wt_IDW</span>(<span class="at">theta =</span> <span class="dv">5</span>, <span class="at">dist_mat =</span> pred_obs_dist_mat)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The matrix <code>Wtilde</code> now contains all the <span class="math inline">\(\tilde{w}_{ij}\)</span> described in <a href="#eq-IDWw" class="quarto-xref">Equation&nbsp;<span>3.3</span></a>; that is, the <span class="math inline">\((k,l)\)</span>th element in <code>Wtilde</code> contains the distance between the <span class="math inline">\(k\)</span>th prediction location and the <span class="math inline">\(l\)</span>th observation location, raised to the power of 5, and reciprocated.</p>
<p>Next, we compute the weights in <a href="#eq-IDWnw" class="quarto-xref">Equation&nbsp;<span>3.2</span></a>. These are just the kernel weights normalized by the sum of all kernel weights associated with each prediction location. Normalizing the weights at every location can be done easily using <code>rowSums</code> in <code>R</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>Wtilde_rsums <span class="ot">&lt;-</span> <span class="fu">rowSums</span>(Wtilde)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>W <span class="ot">&lt;-</span> Wtilde<span class="sc">/</span>Wtilde_rsums</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The resulting matrix <code>W</code> is the weight matrix, sometimes known as the <em>influence matrix</em>. The predictions are then given by <a href="#eq-IDW" class="quarto-xref">Equation&nbsp;<span>3.1</span></a>, which is just the influence matrix multiplied by the data.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>z_pred_IDW <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(W <span class="sc">%*%</span> Tmax_no_14<span class="sc">$</span>z)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>One can informally verify the computed predictions by comparing them to those given by <code>idw</code> in <strong>gstat</strong>. We see that the two results are very close; numerical mismatches of this order of magnitude are likely to arise from the slightly different way the IDW weights are computed in <strong>gstat</strong> (and it is possible that you get different, but still small, mismatches on your computer).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(Tmax_July_idw<span class="sc">$</span>var1.pred <span class="sc">-</span> z_pred_IDW)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      Min.    1st Qu.     Median       Mean    3rd Qu.       Max. 
-1.080e-12 -1.421e-13  1.421e-14  2.428e-15  1.563e-13  1.037e-12 </code></pre>
</div>
</div>
</section>
</section>
<section id="generic-kernel-smoothing-and-cross-validation" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="generic-kernel-smoothing-and-cross-validation">Generic Kernel Smoothing and Cross-Validation</h3>
<p>One advantage of implementing IDW from scratch is that now we can change the kernel function to whatever we want and compare predictions from different kernel functions. We implement a kernel smoother below, where the kernel is a Gaussian radial basis function given by <a href="#eq-radialbasiskern" class="quarto-xref">Equation&nbsp;<span>3.4</span></a> with <span class="math inline">\(\theta = 0.5\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>theta <span class="ot">&lt;-</span> <span class="fl">0.5</span>                       <span class="co"># set bandwidth</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>Wt_Gauss <span class="ot">&lt;-</span> <span class="cf">function</span>(theta, dist_mat) <span class="fu">exp</span>(<span class="sc">-</span>dist_mat<span class="sc">^</span><span class="dv">2</span><span class="sc">/</span>theta)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>Wtilde <span class="ot">&lt;-</span> <span class="fu">Wt_Gauss</span>(<span class="at">theta =</span> <span class="fl">0.5</span>, <span class="at">dist_mat =</span> pred_obs_dist_mat)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>Wtilde_rsums <span class="ot">&lt;-</span> <span class="fu">rowSums</span>(Wtilde)    <span class="co"># normalizing factors</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>W <span class="ot">&lt;-</span> Wtilde<span class="sc">/</span>Wtilde_rsums           <span class="co"># normalized kernel weights</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>z_pred2 <span class="ot">&lt;-</span> W <span class="sc">%*%</span> Tmax_no_14<span class="sc">$</span>z      <span class="co"># predictions</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The vector <code>z_pred2</code> can be assigned to the prediction grid <code>pred_grid</code> and plotted using <strong>ggplot2</strong> as shown above. Note that the predictions are similar, but not identical, to those produced by IDW. But which predictions are the best in terms of squared prediction error? A method commonly applied to assess goodness of fit is known as <em>cross-validation</em> (CV). CV also allows us to choose bandwidth parameters (i.e., <span class="math inline">\(\alpha\)</span> or <span class="math inline">\(\theta\)</span>) that are optimal for a given data set. See <a href="Chapter6.html#sec-ValCrosVal" class="quarto-xref"><span>Section 6.1.3</span></a> for more discussion on CV.</p>
<p>To carry out CV, we need to fit the model using a subset of the data (known as the training set), predict at the data locations that were omitted (known as the validation set), and compute a <em>discrepancy</em>, usually the squared error, between the predicted and observed values. If we leave one data point out at a time, the procedure is known as leave-one-out cross-validation (LOOCV). We denote the mean of the discrepancies for a particular bandwidth parameter <span class="math inline">\(\theta\)</span> as the LOOCV score, <span class="math inline">\(CV_{(m)}(\theta)\)</span> (note that <span class="math inline">\(m\)</span>, here, is the number of folds used in the cross-validation; in LOOCV, the number of folds is equal to the number of data points, <span class="math inline">\(m\)</span>).</p>
<p>The LOOCV for simple predictors, like kernel smoothers, can be computed analytically without having to refit; see <a href="ChapterAppendixB.html" class="quarto-xref"><span>Appendix B</span></a>. Since the data set is reasonably small, it is feasible here to do the refitting with each data point omitted (since each prediction is just an inner product of two vectors). The simplest way to do LOOCV in this context is to compute the pairwise distances between <em>all</em> observation locations and the associated kernel-weight matrix, and then to select the appropriate rows and columns from the resulting matrix to do prediction at a left-out observation; this is repeated for every observation.</p>
<p>The distances between all observations are computed as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>obs_obs_dist_mat <span class="ot">&lt;-</span> <span class="fu">rdist</span>(<span class="fu">select</span>(Tmax, lon, lat, day),</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>                          <span class="fu">select</span>(Tmax, lon, lat, day))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A function that computes the LOOCV score is given as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>LOOCV_score <span class="ot">&lt;-</span> <span class="cf">function</span>(Wt_fun, theta, dist_mat, Z) {</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  Wtilde <span class="ot">&lt;-</span> <span class="fu">Wt_fun</span>(theta, dist_mat)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  CV <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(Z)) {</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    Wtilde2 <span class="ot">&lt;-</span> Wtilde[i,<span class="sc">-</span>i]</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    W2 <span class="ot">&lt;-</span> Wtilde2 <span class="sc">/</span> <span class="fu">sum</span>(Wtilde2)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    z_pred <span class="ot">&lt;-</span> W2 <span class="sc">%*%</span> Z[<span class="sc">-</span>i]</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    CV[i] <span class="ot">&lt;-</span> (z_pred <span class="sc">-</span> Z[i])<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mean</span>(CV)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The function takes as arguments the kernel function that computes the kernel weights <code>Wt_fun</code>; the kernel bandwidth parameter <code>theta</code>; the full distance matrix <code>dist_mat</code>; and the data <code>Z</code>. The function first constructs the kernel-weights matrix for the given bandwidth. Then, for the <span class="math inline">\(i\)</span>th observation, it selects the <span class="math inline">\(i\)</span>th row and excludes the <span class="math inline">\(i\)</span>th column from the kernel-weights matrix and assigns the resulting vector to <code>Wtilde2</code>. This vector contains the kernel weights for the <span class="math inline">\(i\)</span>th observation location (which is now a prediction location) with the weights contributed by this <span class="math inline">\(i\)</span>th observation removed. This vector is normalized and then cross-multiplied with the data to yield the prediction. This is done for all <span class="math inline">\(i = 1,\dots,n\)</span>, and then the mean of the squared errors is returned. To see which of the two predictors is “better,” we now simply call <code>LOOCV_score</code> with the two different kernel functions and bandwidths.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">LOOCV_score</span>(<span class="at">Wt_fun =</span> Wt_IDW,</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>            <span class="at">theta =</span> <span class="dv">5</span>,</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>            <span class="at">dist_mat =</span> obs_obs_dist_mat,</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>            <span class="at">Z =</span> Tmax<span class="sc">$</span>z)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 7.775333</code></pre>
</div>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">LOOCV_score</span>(<span class="at">Wt_fun =</span> Wt_Gauss,</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>            <span class="at">theta =</span> <span class="fl">0.5</span>,</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>            <span class="at">dist_mat =</span> obs_obs_dist_mat,</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>            <span class="at">Z =</span> Tmax<span class="sc">$</span>z)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 7.526056</code></pre>
</div>
</div>
<p>Clearly the Gaussian kernel smoother has performed marginally better than IDW in this case. But how do we know the chosen kernel bandwidths are suitable? Currently we do not, as these were set by simply “eye-balling” the predictions and assessing visually whether they looked suitable or not. An objective way to set the bandwidth parameters is to put them equal to those values that minimize the LOOCV scores. This can be done by simply computing <code>LOOCV_score</code> for a set, say 21, of plausible bandwidths and finding the minimum. We do this below for both IDW and the Gaussian kernel.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>theta_IDW <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">4</span>, <span class="dv">6</span>, <span class="at">length =</span> <span class="dv">21</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>theta_Gauss <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="fl">0.1</span>, <span class="fl">2.1</span>, <span class="at">length =</span> <span class="dv">21</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>CV_IDW <span class="ot">&lt;-</span> CV_Gauss <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="fu">seq_along</span>(theta_IDW)) {</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  CV_IDW[i] <span class="ot">&lt;-</span> <span class="fu">LOOCV_score</span>(<span class="at">Wt_fun =</span> Wt_IDW,</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>                           <span class="at">theta =</span> theta_IDW[i],</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>                           <span class="at">dist_mat =</span> obs_obs_dist_mat,</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>                           <span class="at">Z =</span> Tmax<span class="sc">$</span>z)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>  CV_Gauss[i] <span class="ot">&lt;-</span> <span class="fu">LOOCV_score</span>(<span class="at">Wt_fun =</span> Wt_Gauss,</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>                          <span class="at">theta =</span> theta_Gauss[i],</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>                          <span class="at">dist_mat =</span> obs_obs_dist_mat,</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>                          <span class="at">Z =</span> Tmax<span class="sc">$</span>z)</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The plots showing the LOOCV scores as a function of <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\theta\)</span> for the IDW and Gaussian kernels, respectively, exhibit clear minima when plotted, which is very typical of plots of this kind.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(theta_IDW, CV_IDW,</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab =</span> <span class="fu">expression</span>(alpha),</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab =</span> <span class="fu">expression</span>(CV[(m)](alpha)),</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylim =</span> <span class="fu">c</span>(<span class="fl">7.4</span>, <span class="fl">8.5</span>), <span class="at">type =</span> <span class="st">'o'</span>)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(theta_Gauss, CV_Gauss,</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab =</span> <span class="fu">expression</span>(theta),</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab =</span> <span class="fu">expression</span>(CV[(m)](theta)),</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylim =</span> <span class="fu">c</span>(<span class="fl">7.4</span>, <span class="fl">8.5</span>), <span class="at">type =</span> <span class="st">'o'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The optimal inverse-power and minimum LOOCV score for IDW are</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>theta_IDW[<span class="fu">which.min</span>(CV_IDW)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 5</code></pre>
</div>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">min</span>(CV_IDW)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 7.775333</code></pre>
</div>
</div>
<p>The optimal bandwidth and minimum LOOCV score for the Gaussian kernel smoother are</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>theta_Gauss[<span class="fu">which.min</span>(CV_Gauss)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.6</code></pre>
</div>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">min</span>(CV_Gauss)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 7.468624</code></pre>
</div>
</div>
<p>Our choice of <span class="math inline">\(\alpha = 5\)</span> was therefore (sufficiently close to) optimal when doing IDW, while a bandwidth of <span class="math inline">\(\theta = 0.6\)</span> is better for the Gaussian kernel than our initial choice of <span class="math inline">\(\theta = 0.5\)</span>. It is clear from the results that the Gaussian kernel predictor with <span class="math inline">\(\theta = 0.6\)</span> has, in this example, provided superior performance to IDW with <span class="math inline">\(\alpha = 5\)</span>, in terms of mean-squared-prediction error.</p>
</section>
</section>
<section id="lab-3.2-trend-prediction" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="lab-3.2-trend-prediction">Lab 3.2: Trend Prediction</h2>
<p>There is considerable in-built functionality in <code>R</code> for linear regression and for carrying out hypothesis tests associated with linear models. Several packages have also been written to extend functionality, and in this Lab we shall make use of <strong>leaps</strong>, which contains functionality for stepwise regression; <strong>lmtest</strong>, which contains a suite of tests to carry out on fitted linear models; and <strong>nlme</strong>, which is a package generally used for fitting nonlinear mixed effects models (but we shall use it to fit linear models in the presence of correlated errors).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"leaps"</span>)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"lmtest"</span>)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"nlme"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In addition, we use <strong>ape</strong>, which is one of several packages that contain functionality for testing spatial or spatio-temporal independence with Moran’s <span class="math inline">\(I\)</span> statistic; and we use <strong>FRK</strong>, which contains functionality for constructing the basis functions shown in <a href="#fig-basis_lin_reg" class="quarto-xref">Figure&nbsp;<span>3.13</span></a>. We also make use of <strong>broom</strong> and <strong>purrr</strong> to easily carry out multiple tests on groups within our data set.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ape"</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"broom"</span>)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"FRK"</span>)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"purrr"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We need the following for plotting purposes.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"lattice"</span>)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggplot2"</span>)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"RColorBrewer"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We also need the usual packages for data wrangling and handling of spatial/spatio-temporal objects as in the previous Labs.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"dplyr"</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"gstat"</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"sp"</span>)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"spacetime"</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"STRbook"</span>)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"tidyr"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="fitting-the-model" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="fitting-the-model">Fitting the Model</h3>
<p>For this Lab we again consider the NOAA data set, specifically the maximum temperature data for the month of July 1993. These data can be extracted as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"NOAA_df_1990"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>Tmax <span class="ot">&lt;-</span> <span class="fu">filter</span>(NOAA_df_1990,       <span class="co"># subset the data</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>              proc <span class="sc">==</span> <span class="st">"Tmax"</span> <span class="sc">&amp;</span>     <span class="co"># only max temperature</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>              month <span class="sc">==</span> <span class="dv">7</span> <span class="sc">&amp;</span>         <span class="co"># July</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>              year <span class="sc">==</span> <span class="dv">1993</span>)        <span class="co"># year of 1993</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The linear model we fit has the form</p>
<p><span id="eq-ST_reg"><span class="math display">\[
Z(\mathbf{s}_i;t) = \beta_0 + \beta_1 X_1(\mathbf{s}_i;t) + \ldots + \beta_p X_p(\mathbf{s}_i;t) + e(\mathbf{s}_i;t),
\tag{3.16}\]</span></span></p>
<p>for <span class="math inline">\(i=1,\ldots,n\)</span> and <span class="math inline">\(t=1,\ldots,T\)</span>, where <span class="math inline">\(\beta_0\)</span> is the intercept and <span class="math inline">\(\beta_j~(j &gt; 0)\)</span> is a regression coefficient associated with <span class="math inline">\(X_j(\mathbf{s}_i;t)\)</span>, the <span class="math inline">\(j\)</span>th covariate at spatial location <span class="math inline">\(\mathbf{s}_i\)</span> and time <span class="math inline">\(t\)</span>. We also assume independent errors such that <span class="math inline">\(e(\mathbf{s}_i;t) \sim \; indep. \; N(0,\sigma^2_e)\)</span>. We consider a model with linear space-time interactions and a set of basis functions that fill the spatial domain:</p>
<ul>
<li>linear in <span class="math inline">\(lon\)</span>-coordinate: <span class="math inline">\(X_1(\mathbf{s}_i;t) = s_{1,i}\)</span>, for all <span class="math inline">\(t\)</span>;</li>
<li>linear in <span class="math inline">\(lat\)</span>-coordinate: <span class="math inline">\(X_2(\mathbf{s}_i;t) = s_{2,i}\)</span>, for all <span class="math inline">\(t\)</span>;</li>
<li>linear time (day) trend: <span class="math inline">\(X_3(\mathbf{s}_i;t) = t\)</span>, for all <span class="math inline">\(\mathbf{s}_i\)</span>;</li>
<li><span class="math inline">\(lon\)</span>–<span class="math inline">\(lat\)</span> interaction: <span class="math inline">\(X_4(\mathbf{s}_i;t) = s_{1,i}s_{2,i}\)</span>, for all <span class="math inline">\(t\)</span>;</li>
<li><span class="math inline">\(lon\)</span>–<span class="math inline">\(t\)</span> interaction: <span class="math inline">\(X_5(\mathbf{s}_i;t) = s_{1,i}t_i\)</span>, for all <span class="math inline">\(s_{2,i}\)</span>;</li>
<li><span class="math inline">\(lat\)</span>–<span class="math inline">\(t\)</span> interaction: <span class="math inline">\(X_6(\mathbf{s}_i;t) = s_{2,i}t_i\)</span>, for all <span class="math inline">\(s_{1,i}\)</span>;</li>
<li>spatial basis functions: <span class="math inline">\(X_j(\mathbf{s}_i;t) = \phi_{j - 6}(\mathbf{s}_i), j =7,\dots,18\)</span>, for all <span class="math inline">\(t\)</span>.</li>
</ul>
<p>The set of basis functions can be constructed using the function <code>auto_basis</code> in <strong>FRK</strong>. The function takes as arguments <code>data</code>, which is a spatial object; <code>nres</code>, which is the number of “resolutions” to construct; and <code>type</code>, which indicates the type of basis function to use. Here we consider a single resolution of the Gaussian radial basis function; see <a href="#fig-basis_lin_reg" class="quarto-xref">Figure&nbsp;<span>3.13</span></a>.</p>
<div id="fig-basis_lin_reg" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-basis_lin_reg-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_3/basis_fns.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-basis_lin_reg-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.13: The time-invariant basis functions <span class="math inline">\(\phi_1(\cdot),\dots,\phi_{12}(\cdot)\)</span> used for regression prediction of the NOAA maximum temperature data in July 1993.
</figcaption>
</figure>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>G <span class="ot">&lt;-</span> <span class="fu">auto_basis</span>(<span class="at">data =</span> Tmax[,<span class="fu">c</span>(<span class="st">"lon"</span>,<span class="st">"lat"</span>)] <span class="sc">%&gt;%</span>  <span class="co"># Take Tmax</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>                       <span class="fu">SpatialPoints</span>(),           <span class="co"># To sp obj</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">nres =</span> <span class="dv">1</span>,                         <span class="co"># One resolution</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">type =</span> <span class="st">"Gaussian"</span>)                <span class="co"># Gaussian BFs</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>These basis functions evaluated at data locations are then the covariates we seek for fitting the data. The functions are evaluated at any arbitrary location using the function <code>eval_basis</code>. This function requires the locations as a <code>matrix</code> object, and it returns the evaluations as an object of class <code>Matrix</code>, which can be easily converted to a <code>matrix</code> as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>S <span class="ot">&lt;-</span> <span class="fu">eval_basis</span>(<span class="at">basis =</span> G,                     <span class="co"># basis functions</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">s =</span> Tmax[,<span class="fu">c</span>(<span class="st">"lon"</span>,<span class="st">"lat"</span>)] <span class="sc">%&gt;%</span>  <span class="co"># spat locations</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>                     <span class="fu">as.matrix</span>()) <span class="sc">%&gt;%</span>          <span class="co"># conv. to matrix</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>     <span class="fu">as.matrix</span>()                               <span class="co"># results as matrix</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(S) <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">"B"</span>, <span class="dv">1</span><span class="sc">:</span><span class="fu">ncol</span>(S)) <span class="co"># assign column names</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>When fitting the linear model we shall use the convenient notation “.” to denote “all variables in the data frame” as covariates. This is particularly useful when we have many covariates, such as the 12 basis functions above. Therefore, we first remove all variables (except the field <code>id</code> that we shall omit manually later) that we do not wish to include in the model, and we save the resulting data frame as <code>Tmax2</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>Tmax2 <span class="ot">&lt;-</span> <span class="fu">cbind</span>(Tmax, S) <span class="sc">%&gt;%</span>             <span class="co"># append S to Tmax</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>         <span class="fu">select</span>(<span class="sc">-</span>year, <span class="sc">-</span>month, <span class="sc">-</span>proc,   <span class="co"># and remove vars we</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>                <span class="sc">-</span>julian, <span class="sc">-</span>date)         <span class="co"># will not be using in</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>                                        <span class="co"># the model</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As we did in Lab 3.1, we also remove 14 July 1993 to see how predictions on this day are affected, given that we have no data on that day.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>Tmax_no_14 <span class="ot">&lt;-</span> <span class="fu">filter</span>(Tmax2, <span class="sc">!</span>(day <span class="sc">==</span> <span class="dv">14</span>))  <span class="co"># remove day 14</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We now fit the linear model using <code>lm</code>. The formula we use is <code>z ~ (lon + lat + day)^2 + .</code> which indicates that we have as covariates longitude, latitude, day, and all the interactions between them, as well as the other covariates in the data frame (the 12 basis functions) without interactions.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>Tmax_July_lm <span class="ot">&lt;-</span> <span class="fu">lm</span>(z <span class="sc">~</span> (lon <span class="sc">+</span> lat <span class="sc">+</span> day)<span class="sc">^</span><span class="dv">2</span> <span class="sc">+</span> .,     <span class="co"># model</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">data =</span> <span class="fu">select</span>(Tmax_no_14, <span class="sc">-</span>id))  <span class="co"># omit id</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The results of this fit can be viewed using <code>summary</code>. Note that latitude is no longer considered a significant effect, largely because of the presence of the latitude-by-day interaction in the model, which is considered significant. The output from <code>summary</code> corresponds to what is shown in Table <a href="#tbl-reg_results" class="quarto-xref">Table&nbsp;<span>3.1</span></a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>Tmax_July_lm <span class="sc">%&gt;%</span> <span class="fu">summary</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = z ~ (lon + lat + day)^2 + ., data = select(Tmax_no_14, 
    -id))

Residuals:
     Min       1Q   Median       3Q      Max 
-17.5136  -2.4797   0.1098   2.6644  14.1659 

Coefficients:
              Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept) 192.243242  97.854126   1.965 0.049531 *  
lon           1.756918   1.088175   1.615 0.106486    
lat          -1.317402   2.555626  -0.515 0.606239    
day          -1.216456   0.133547  -9.109  &lt; 2e-16 ***
B1           16.646617   4.832399   3.445 0.000577 ***
B2           18.528159   3.056082   6.063 1.46e-09 ***
B3           -6.606896   3.171759  -2.083 0.037312 *  
B4           30.545361   4.369591   6.990 3.20e-12 ***
B5           14.739147   2.746866   5.366 8.52e-08 ***
B6          -17.541177   3.423081  -5.124 3.13e-07 ***
B7           28.472198   3.551900   8.016 1.42e-15 ***
B8          -27.348145   3.164317  -8.643  &lt; 2e-16 ***
B9          -10.234777   4.456735  -2.296 0.021701 *  
B10          10.558234   3.327370   3.173 0.001519 ** 
B11         -22.757661   3.532508  -6.442 1.32e-10 ***
B12          21.864383   4.812940   4.543 5.72e-06 ***
lon:lat      -0.026021   0.028232  -0.922 0.356755    
lon:day      -0.022696   0.001288 -17.615  &lt; 2e-16 ***
lat:day      -0.019032   0.001876 -10.147  &lt; 2e-16 ***
---
Signif. codes:  
0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 4.225 on 3970 degrees of freedom
Multiple R-squared:  0.7023,    Adjusted R-squared:  0.701 
F-statistic: 520.4 on 18 and 3970 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
</div>
<section id="correlated-errors" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="correlated-errors">Correlated Errors</h4>
<p>As we show later in this Lab, there is clearly correlation in the residuals, indicating that the fixed effects are not able to explain the spatio-temporal variability in the data. If we knew the spatio-temporal covariance function of these errors, we could then use generalized least squares to fit the model. For example, if we knew that the covariance function was a Gaussian function, isotropic, and with a range of <span class="math inline">\(0.5\)</span> (see Chapter 4 for more details on covariance functions), then we could fit the model as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>Tmax_July_gls <span class="ot">&lt;-</span> <span class="fu">gls</span>(z <span class="sc">~</span> (lon <span class="sc">+</span> lat <span class="sc">+</span> day)<span class="sc">^</span><span class="dv">2</span> <span class="sc">+</span> .,</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>                     <span class="at">data =</span> <span class="fu">select</span>(Tmax_no_14, <span class="sc">-</span>id),</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>                     <span class="at">correlation =</span> <span class="fu">corGaus</span>(<span class="at">value =</span> <span class="fl">0.5</span>,</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>                                        <span class="at">form =</span> <span class="sc">~</span> lon <span class="sc">+</span> lat <span class="sc">+</span> day,</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>                                        <span class="at">fixed =</span> <span class="cn">TRUE</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Results of the linear fitting can be seen using <code>summary</code>. Note that the estimated coefficients are quite similar to those using linear regression, but the standard errors are larger. The output from <code>summary</code> should correspond to what is shown in Table <a href="#tbl-reg_results" class="quarto-xref">Table&nbsp;<span>3.1</span></a>.</p>
</section>
<section id="stepwise-selection" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="stepwise-selection">Stepwise Selection</h4>
<p>Stepwise selection is a procedure used to find a parsimonious model (where parsimony refers to a model with as few parameters as possible for a given criterion) from a large selection of explanatory variables, such that each variable is included or excluded in a <em>step</em>. In the simplest of cases, a step is the introduction of a variable (always the case in forward selection) or the removal of a variable (always the case in backward selection).</p>
<p>The function <code>step</code> takes as arguments the initial (usually the intercept) model as an <code>lm</code> object, the full model as its <code>scope</code> and, if <code>direction = "forward"</code>, starts from an intercept model and at each step introduces a new variable that minimizes the Akaike information criterion (AIC) (see <a href="Chapter6.html#sec-informationcriteria" class="quarto-xref"><span>Section 6.4.4</span></a>) of the fitted model. The following <code>for</code> loop retrieves the fitted model for each step of the stepwise AIC forward-selection method.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>Tmax_July_lm4 <span class="ot">&lt;-</span> <span class="fu">list</span>()   <span class="co"># initialize</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">4</span>) {           <span class="co"># for four steps (after intercept model)</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>   <span class="do">## Carry out stepwise forward selection for i steps</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>   Tmax_July_lm4[[i<span class="sc">+</span><span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">step</span>(<span class="fu">lm</span>(z <span class="sc">~</span> <span class="dv">1</span>,</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>                               <span class="at">data =</span> <span class="fu">select</span>(Tmax_no_14, <span class="sc">-</span>id)),</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>                               <span class="at">scope =</span> z <span class="sc">~</span>(lon <span class="sc">+</span> lat <span class="sc">+</span> day)<span class="sc">^</span><span class="dv">2</span> <span class="sc">+</span> .,</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>                               <span class="at">direction =</span> <span class="st">'forward'</span>,</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>                               <span class="at">steps =</span> i)</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Each model in the list can be analyzed using <code>summary</code>, as above.</p>
<p>Notice from the output of <code>summary</code> that <code>Tmax_July_lm4[[5]]</code> contains the covariate <code>lon</code> whose effect is not significant. This is fairly common with stepwise AIC procedures. One is more likely to include covariates whose effects are significant when minimizing the residual sum of squares at each step. This can be carried out using the function <code>regsubsets</code> from the <strong>leaps</strong> package, which can be called as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>regfit.full <span class="ot">=</span> <span class="fu">regsubsets</span>(z <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> (lon <span class="sc">+</span> lat <span class="sc">+</span> day)<span class="sc">^</span><span class="dv">2</span> <span class="sc">+</span> .,  <span class="co"># model</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>                         <span class="at">data =</span> <span class="fu">select</span>(Tmax_no_14, <span class="sc">-</span>id),</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>                         <span class="at">method =</span> <span class="st">"forward"</span>,</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>                         <span class="at">nvmax =</span> <span class="dv">4</span>)                  <span class="co"># 4 steps</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>All information from the stepwise-selection procedure is available in the object returned by the <code>summary</code> function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>regfit.summary <span class="ot">&lt;-</span> <span class="fu">summary</span>(regfit.full)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>You can type <code>regfit.summary</code> to see which covariates were selected in each step of the algorithm. The outputs from <code>step</code> and <code>regsubsets</code> are shown in Tables <a href="#tbl-step_results" class="quarto-xref">Table&nbsp;<span>3.2</span></a> and <a href="#tbl-step_rss_results_table" class="quarto-xref">Table&nbsp;<span>3.3</span></a>, respectively.</p>
</section>
<section id="multicollinearity" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="multicollinearity">Multicollinearity</h4>
<p>It is fairly common in spatio-temporal modeling to have multicollinearity, both in space and in time. For example, in a spatial setting, average salary might be highly correlated with unemployment levels, but both could be included in a model to explain life expectancy. It is beyond the scope of this book to discuss methods to deal with multicollinearity, but it is important to be aware of its implications.</p>
<p>Consider, for example, a setting where we have a 13th basis function that is simply the 5th basis function corrupted by some noise.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>) <span class="co"># Fix seed for reproducibility</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>Tmax_no_14_2 <span class="ot">&lt;-</span> Tmax_no_14 <span class="sc">%&gt;%</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>                <span class="fu">mutate</span>(<span class="at">B13 =</span> B5 <span class="sc">+</span> <span class="fl">0.01</span><span class="sc">*</span><span class="fu">rnorm</span>(<span class="fu">nrow</span>(Tmax_no_14)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we fit the same linear model, but this time we include the 13th basis function, then the effects of both the 5th and the 13th basis functions are no longer considered significant at the 1% level, although the effect of the 5th basis function was considered very significant initially (without the 13th basis function being present).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>Tmax_July_lm3 <span class="ot">&lt;-</span> <span class="fu">lm</span>(z <span class="sc">~</span> (lon <span class="sc">+</span> lat <span class="sc">+</span> day)<span class="sc">^</span><span class="dv">2</span> <span class="sc">+</span> .,</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">data =</span> Tmax_no_14_2 <span class="sc">%&gt;%</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>                          <span class="fu">select</span>(<span class="sc">-</span>id))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(Tmax_July_lm3)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = z ~ (lon + lat + day)^2 + ., data = Tmax_no_14_2 %&gt;% 
    select(-id))

Residuals:
     Min       1Q   Median       3Q      Max 
-17.7869  -2.4946   0.1034   2.6743  14.3179 

Coefficients:
              Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept) 195.365087  97.819550   1.997 0.045872 *  
lon           1.785474   1.087752   1.641 0.100786    
lat          -1.414127   2.554836  -0.554 0.579946    
day          -1.215853   0.133485  -9.109  &lt; 2e-16 ***
B1           16.675811   4.830184   3.452 0.000561 ***
B2           18.379495   3.055443   6.015 1.96e-09 ***
B3           -6.470935   3.170917  -2.041 0.041345 *  
B4           30.303993   4.368998   6.936 4.68e-12 ***
B5            0.603294   7.092149   0.085 0.932214    
B6          -17.322017   3.423000  -5.060 4.37e-07 ***
B7           28.135550   3.553672   7.917 3.12e-15 ***
B8          -27.002158   3.166901  -8.526  &lt; 2e-16 ***
B9          -10.181760   4.454742  -2.286 0.022330 *  
B10          10.379666   3.326858   3.120 0.001822 ** 
B11         -22.419432   3.534340  -6.343 2.50e-10 ***
B12          21.664508   4.811603   4.503 6.91e-06 ***
B13          13.998555   6.475621   2.162 0.030698 *  
lon:lat      -0.026943   0.028222  -0.955 0.339805    
lon:day      -0.022625   0.001288 -17.563  &lt; 2e-16 ***
lat:day      -0.018884   0.001876 -10.066  &lt; 2e-16 ***
---
Signif. codes:  
0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 4.223 on 3969 degrees of freedom
Multiple R-squared:  0.7027,    Adjusted R-squared:  0.7013 
F-statistic: 493.7 on 19 and 3969 DF,  p-value: &lt; 2.2e-16</code></pre>
</div>
</div>
<p>The introduction of the 13th basis function will not adversely affect the predictions and prediction standard errors, but it does compromise our ability to correctly interpret the fixed effects. Multicollinearity will result in a high positive or negative correlation between the estimators of the regression coefficients. For example, the correlation matrix of the estimators of the fixed effects corresponding to these two basis functions is given by</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="fu">vcov</span>(Tmax_July_lm3)[<span class="fu">c</span>(<span class="st">"B5"</span>, <span class="st">"B13"</span>),<span class="fu">c</span>(<span class="st">"B5"</span>, <span class="st">"B13"</span>)] <span class="sc">%&gt;%</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cov2cor</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>            B5        B13
B5   1.0000000 -0.9220244
B13 -0.9220244  1.0000000</code></pre>
</div>
</div>
</section>
<section id="analyzing-the-residuals" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="analyzing-the-residuals">Analyzing the Residuals</h4>
<p>Having fitted a spatio-temporal model, it is good practice to check the residuals. If they are still spatio-temporally correlated, then our model will not have captured adequately the spatial and temporal variability in the data. We extract the residuals from our linear model using the function <code>residuals</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>Tmax_no_14<span class="sc">$</span>residuals <span class="ot">&lt;-</span> <span class="fu">residuals</span>(Tmax_July_lm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now let us plot the residuals of the last eight days. Notice how these residuals, shown in the bottom panel of <a href="#fig-reg_residuals" class="quarto-xref">Figure&nbsp;<span>3.9</span></a>, are strongly spatially correlated. The triangles in the image correspond to the two stations whose time series of residuals we shall analyze later.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="fu">filter</span>(Tmax_no_14, day <span class="sc">%in%</span> <span class="dv">24</span><span class="sc">:</span><span class="dv">31</span>)) <span class="sc">+</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="fu">aes</span>(lon, lat, <span class="at">colour =</span> residuals)) <span class="sc">+</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span> day, <span class="at">ncol=</span><span class="dv">4</span>) <span class="sc">+</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">col_scale</span>(<span class="at">name =</span> <span class="st">"degF"</span>) <span class="sc">+</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> <span class="fu">filter</span>(Tmax_no_14,day <span class="sc">%in%</span> <span class="dv">24</span><span class="sc">:</span><span class="dv">31</span> <span class="sc">&amp;</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>                                        id <span class="sc">%in%</span> <span class="fu">c</span>(<span class="dv">3810</span>, <span class="dv">3889</span>)),</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>               <span class="fu">aes</span>(lon, lat), <span class="at">colour =</span> <span class="st">"black"</span>,</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>               <span class="at">pch =</span> <span class="dv">2</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(g)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>One of the most used tests for spatial dependence for lattice spatial data is Moran’s <span class="math inline">\(I\)</span>G test. This can be applied to the data directly, or to the residuals from some spatial regression model. Let <span class="math inline">\(Z_i\)</span> represent spatially referenced data (or residuals) for <span class="math inline">\(i=1,\ldots,n\)</span> spatial locations. Then Moran’s <span class="math inline">\(I\)</span> is calculated as</p>
<p><span id="eq-MoransI"><span class="math display">\[
I = \frac{n \sum_{i=1}^n \sum_{j=1}^n w_{ij} (Z_i - \bar{Z})(Z_j - \bar{Z}) }{(\sum_{i=1}^n \sum_{j=1}^n w_{ij})(\sum_{i=1}^n (Z_i - \bar{Z})^2) },
\tag{3.17}\]</span></span></p>
<p>where <span class="math inline">\(\bar{Z} = (1/n)\sum_{i=1}^n Z_i\)</span> is the spatial mean and <span class="math inline">\(w_{ij}\)</span> are spatial adjacency “weights” between location <span class="math inline">\(i\)</span> and location <span class="math inline">\(j\)</span> (where we require <span class="math inline">\(w_{ii} = 0\)</span> for all <span class="math inline">\(i=1,\ldots,n\)</span>). Thus, Moran’s <span class="math inline">\(I\)</span> statistic is simply a weighted form of the usual Pearson correlation coefficient, where the weights are the spatial proximity weights, and it takes values between <span class="math inline">\(-1\)</span> and <span class="math inline">\(1\)</span>. If <a href="#eq-MoransI" class="quarto-xref">Equation&nbsp;<span>3.17</span></a> is positive, then neighboring values tend to have similar values, and if it is negative, then neighboring regions tend to have different values. We can use Moran’s <span class="math inline">\(I\)</span> test, described in <a href="#nte-technote-durbin-watson-morans-i" class="quarto-xref">Note&nbsp;<span>3.2</span></a>, to test for spatial dependence in the residuals on each day. In the following code, we take each day in our data set, compute the distances, form the weight matrix, and carry out Moran’s <span class="math inline">\(I\)</span> test using the function <code>Moran.I</code> from the package <strong>ape</strong>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>P <span class="ot">&lt;-</span> <span class="fu">list</span>()                                 <span class="co"># init list</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>days <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">13</span>, <span class="dv">15</span><span class="sc">:</span><span class="dv">31</span>)                      <span class="co"># set of days</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="fu">seq_along</span>(days)) {                 <span class="co"># for each day</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>  Tmax_day <span class="ot">&lt;-</span> <span class="fu">filter</span>(Tmax_no_14,</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>                     day <span class="sc">==</span> days[i])        <span class="co"># filter by day</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>  station.dists <span class="ot">&lt;-</span> Tmax_day <span class="sc">%&gt;%</span>             <span class="co"># take the data</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">select</span>(lon, lat) <span class="sc">%&gt;%</span>                    <span class="co"># extract coords.</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">dist</span>() <span class="sc">%&gt;%</span>                              <span class="co"># comp. dists.</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">as.matrix</span>()                             <span class="co"># conv. to matrix</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>  station.dists.inv <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span>station.dists      <span class="co"># weight matrix</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">diag</span>(station.dists.inv) <span class="ot">&lt;-</span> <span class="dv">0</span>              <span class="co"># 0 on diag</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>  P[[i]] <span class="ot">&lt;-</span> <span class="fu">Moran.I</span>(Tmax_day<span class="sc">$</span>residuals,     <span class="co"># run Moran's I</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>                    station.dists.inv) <span class="sc">%&gt;%</span></span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>            <span class="fu">do.call</span>(<span class="st">"cbind"</span>, .)             <span class="co"># conv. to df</span></span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The object <code>P</code> is a list of single-row data frames that can be collapsed into a single data frame by calling <code>do.call</code> and proceeding to row-bind the elements of each list item together. We print the first six records of the resulting data frame below.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="fu">do.call</span>(<span class="st">"rbind"</span>, P) <span class="sc">%&gt;%</span> <span class="fu">head</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      observed     expected         sd p.value
[1,] 0.2716679 -0.007575758 0.01235583       0
[2,] 0.2264147 -0.007575758 0.01236886       0
[3,] 0.2113966 -0.007575758 0.01236374       0
[4,] 0.1626477 -0.007575758 0.01238872       0
[5,] 0.2580333 -0.007575758 0.01241006       0
[6,] 0.1216741 -0.007575758 0.01227211       0</code></pre>
</div>
</div>
<p>The maximum <span class="math inline">\(p\)</span>-value from the 30 tests is 8.0401863^{-6}, which is very small. Since we are in a multiple-hypothesis setting, we need to control the familywise error rate and, for a level of significance <span class="math inline">\(\alpha\)</span>, reject the null hypothesis of no correlation only if the <span class="math inline">\(p\)</span>-value is less than <span class="math inline">\(c(\alpha)\)</span> <span class="math inline">\((&lt; \alpha)\)</span>, where <span class="math inline">\(c(\cdot)\)</span> is a correction function. In this case, even the very conservative Bonferroni correction (for which <span class="math inline">\(c(\alpha) = \alpha / T\)</span>, where <span class="math inline">\(T\)</span> is the number of time points) will result in rejecting the null hypothesis at each time point.</p>
<p>It is straightforward to extend Moran’s <span class="math inline">\(I\)</span> test to the spatio-temporal setting, as one need only extend the concept of “spatial distance” to “spatio-temporal distance.” We are faced with the usual problem of how to appropriately scale time to make a Euclidean distance across space and time have a realistic interpretation. One way to do this is to fit a dependence model that allows for scaling in time, and subsequently scale time by an estimate of the scaling factor prior to computing the Euclidean distance. We shall work with one such model, which uses an anisotropic covariance function, in Chapter 4. For now, as we did with IDW, we do not scale time and compute distances on the spatio-temporal domain (which happens to be reasonable for these data).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>station.dists <span class="ot">&lt;-</span> Tmax_no_14 <span class="sc">%&gt;%</span>  <span class="co"># take the data</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(lon, lat, day) <span class="sc">%&gt;%</span>      <span class="co"># extract coordinates</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">dist</span>() <span class="sc">%&gt;%</span>                     <span class="co"># compute distances</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.matrix</span>()                    <span class="co"># convert to matrix</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We now need to compute the weights from the distances, set the diagonal to zero and call <code>Moran.I</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>station.dists.inv <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span>station.dists</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="fu">diag</span>(station.dists.inv) <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="fu">Moran.I</span>(Tmax_no_14<span class="sc">$</span>residuals, station.dists.inv)<span class="sc">$</span>p.value</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0</code></pre>
</div>
</div>
<p>Unsurprisingly, given what we saw when analyzing individual time slices, the <span class="math inline">\(p\)</span>-value is very small, strongly suggesting that there is spatio-temporal dependence in the data.</p>
<p>When the data are regularly spaced in time, as is the case here, one may also look at the “temporal” residuals at some location and test for temporal correlation in these residuals using the Durbin–Watson test. For example, consider the maximum temperature (<code>Tmax</code>) residuals at stations 3810 and 3889.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>TS1 <span class="ot">&lt;-</span> <span class="fu">filter</span>(Tmax_no_14, id <span class="sc">==</span> <span class="dv">3810</span>)<span class="sc">$</span>residuals</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>TS2 <span class="ot">&lt;-</span> <span class="fu">filter</span>(Tmax_no_14, id <span class="sc">==</span> <span class="dv">3889</span>)<span class="sc">$</span>residuals</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>These residuals can be easily plotted using base <code>R</code> graphics as follows; see the top panel of <a href="#fig-reg_residuals" class="quarto-xref">Figure&nbsp;<span>3.9</span></a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mar=</span><span class="fu">c</span>(<span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(TS1,                           <span class="co"># Station 3810 residuals</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab =</span> <span class="st">"day of July 1993"</span>,</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab =</span> <span class="st">"residuals (degF)"</span>,</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>     <span class="at">type =</span> <span class="st">'o'</span>, <span class="at">ylim =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">8</span>, <span class="dv">7</span>))</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(TS2,                          <span class="co"># Station 3889 residuals</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>      <span class="at">xlab =</span> <span class="st">"day of July 1993"</span>,</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>      <span class="at">ylab =</span> <span class="st">"residuals (degF)"</span>,</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>      <span class="at">type =</span> <span class="st">'o'</span>, <span class="at">col =</span> <span class="st">"red"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note that there is clear temporal correlation in the residuals; that is, residuals close to each other in time tend to be more similar than residuals further apart. It is also interesting to note that the residuals are correlated between the stations; that is, at the same time point, the residuals at both stations are more similar than at different time points. This is due to the spatial correlation in the residuals that was tested for above (these two stations happen to be quite close to each other; recall the previous image of the spatial residuals). One may also look at the <em>correlogram</em> (the empirical autocorrelation function) of the residuals by typing <code>acf(TS1)</code> and <code>acf(TS2)</code>, respectively. From these plots it can be clearly seen that there is significant lag-1 correlation in both these residual time series.</p>
<p>Now let us proceed with carrying out a Durbin–Watson test for the residuals at every station. This can be done using a <code>for</code> loop as we did with Moran’s <span class="math inline">\(I\)</span> test; however, we shall now introduce a more sophisticated way of carrying out multiple tests and predictions on groups of data within a data frame, using the packages <strong>tidyr</strong>, <strong>purrr</strong>, and <strong>broom</strong>, which will also be used in Lab 3.3.</p>
<p>In Lab 2.1 we investigated data wrangling techniques for putting data that are in a data frame into groups using <code>group_by</code>, and then we performed an operation on each of those groups using <code>summarise</code>. The grouped data frame returned by <code>group_by</code> is simply the original frame with each row associated with a group. A more elaborate representation of these data is in a <em>nested data frame</em>, where we have a data frame containing one row <em>for each group</em>. The “nested” property comes from the fact that we may have a data frame, conventionally under the field name “data,” for each group. For example, if we group <code>Tmax_no_14</code> by <code>lon</code> and <code>lat</code>, we obtain the following first three records.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>nested_Tmax_no_14 <span class="ot">&lt;-</span> <span class="fu">group_by</span>(Tmax_no_14, lon, lat) <span class="sc">%&gt;%</span> <span class="fu">nest</span>()</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(nested_Tmax_no_14, <span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 3 × 3
# Groups:   lon, lat [3]
    lat   lon data              
  &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt;            
1  39.3 -81.4 &lt;tibble [30 × 16]&gt;
2  35.7 -81.4 &lt;tibble [30 × 16]&gt;
3  35.6 -88.9 &lt;tibble [30 × 16]&gt;</code></pre>
</div>
</div>
<p>Note the third column, <code>data</code>, which is a column of <em>tibbles</em> (which, for the purposes of this book, should be treated as sophisticated data frames). Next we define a function that takes the data frame associated with a single group, carries out the test (in this case the Durbin–Watson test), and returns the results. The function <code>dwtest</code> takes an <code>R</code> formula as the first argument and the data as the second argument. In this case, we test for autocorrelation in the residuals after removing a temporal (constant) trend and by using the formula <code>residuals ~ 1</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>dwtest_one_station <span class="ot">&lt;-</span> <span class="cf">function</span>(data)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>                        <span class="fu">dwtest</span>(residuals <span class="sc">~</span> <span class="dv">1</span>, <span class="at">data =</span> data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Calling <code>dwtest_one_station</code> for the data in the first record will carry out the test at the first station, in the second record at the second station, and so on. For example,</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dwtest_one_station</span>(nested_Tmax_no_14<span class="sc">$</span>data[[<span class="dv">1</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>carries out the Durbin–Watson test on the residuals at the first station.</p>
<p>To carry out the test on each record in the nested data frame, we use the function <code>map</code> from the package <strong>purrr</strong>. For example, the command</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span>(nested_Tmax_no_14<span class="sc">$</span>data, dwtest_one_station) <span class="sc">%&gt;%</span> <span class="fu">head</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The test results for the first six stations can be assigned to another column within our nested data frame using <code>mutate</code>. These results are of class <code>htest</code> and not easy to analyze or visualize in their native form. We therefore use the function <code>tidy</code> from the package <strong>broom</strong> to extract the key information from the test (in this case the statistic, the <span class="math inline">\(p\)</span>-value, the method, and the hypothesis) and put it into a data frame. For example,</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>dwtest_one_station_tidy <span class="ot">&lt;-</span> nested_Tmax_no_14<span class="sc">$</span>data[[<span class="dv">1</span>]] <span class="sc">%&gt;%</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>                           <span class="fu">dwtest_one_station</span>() <span class="sc">%&gt;%</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>                           <span class="fu">tidy</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>tidies up the results at the first station. The first three columns of the returned data are</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>dwtest_one_station_tidy[, <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1 × 3
  statistic p.value method            
      &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;             
1     0.982 0.00122 Durbin-Watson test</code></pre>
</div>
</div>
<p>To assign the test results to each record in the nested data frame as added fields (instead of as another data frame), we then use the function <code>unnest</code>. In summary, the code</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>Tmax_DW_no_14 <span class="ot">&lt;-</span> nested_Tmax_no_14 <span class="sc">%&gt;%</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mutate</span>(<span class="at">dwtest =</span> <span class="fu">map</span>(data, dwtest_one_station)) <span class="sc">%&gt;%</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mutate</span>(<span class="at">test_df =</span> <span class="fu">map</span>(dwtest, tidy)) <span class="sc">%&gt;%</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">unnest</span>(test_df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>provides all the information we need. The first three records, excluding the last two columns, are</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>Tmax_DW_no_14 <span class="sc">%&gt;%</span> <span class="fu">select</span>(<span class="sc">-</span>method, <span class="sc">-</span>alternative) <span class="sc">%&gt;%</span> <span class="fu">head</span>(<span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 3 × 6
# Groups:   lon, lat [3]
    lat   lon data     dwtest  statistic  p.value
  &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt;   &lt;list&gt;      &lt;dbl&gt;    &lt;dbl&gt;
1  39.3 -81.4 &lt;tibble&gt; &lt;htest&gt;     0.982 0.00122 
2  35.7 -81.4 &lt;tibble&gt; &lt;htest&gt;     0.921 0.000586
3  35.6 -88.9 &lt;tibble&gt; &lt;htest&gt;     1.59  0.129   </code></pre>
</div>
</div>
<p>The proportion of <span class="math inline">\(p\)</span>-values <em>below</em> the 5% level of significance divided by the number of tests (Bonferroni correction) is</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(Tmax_DW_no_14<span class="sc">$</span>p.value <span class="sc">&lt;</span> <span class="fl">0.05</span><span class="sc">/</span><span class="fu">nrow</span>(Tmax_DW_no_14)) <span class="sc">*</span> <span class="dv">100</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 21.8</code></pre>
</div>
</div>
<p>This proportion of 21.8% is reasonably high and provides evidence that there is considerable temporal autocorrelation in the residuals, as expected.</p>
<p>Finally, we can also compute and visualize the empirical spatio-temporal semivariogram of the residuals. Recall that in Lab 2.1 we put the maximum temperature data in the NOAA data set into an <code>STFDF</code> object that we labeled <code>STObj3</code>. We now load these data and subset the month of July 1993.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"STObj3"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>STObj4 <span class="ot">&lt;-</span> STObj3[, <span class="st">"1993-07-01::1993-07-31"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>All we need to do is merge <code>Tmax_no_14</code>, which contains the residuals, with the <code>STFDF</code> object <code>STObj4</code>, so that the empirical semivariogram of the residuals can be computed. This can be done quickly, and safely, using the function <code>left_join</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>STObj4<span class="sc">@</span>data <span class="ot">&lt;-</span> <span class="fu">left_join</span>(STObj4<span class="sc">@</span>data, Tmax_no_14)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As in Lab 2.3, we now compute the empirical semivariogram with the function <code>variogram</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>vv <span class="ot">&lt;-</span> <span class="fu">variogram</span>(<span class="at">object =</span> residuals <span class="sc">~</span> <span class="dv">1</span>, <span class="co"># fixed effect component</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">data =</span> STObj4,     <span class="co"># July data</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">width =</span> <span class="dv">80</span>,        <span class="co"># spatial bin (80 km)</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">cutoff =</span> <span class="dv">1000</span>,     <span class="co"># consider pts &lt; 1000 km apart</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>                <span class="at">tlags =</span> <span class="fl">0.01</span><span class="sc">:</span><span class="fl">6.01</span>) <span class="co"># 0 days to 6 days</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The command <code>plot(vv)</code> displays the empirical semivariogram of the residuals, which is shown in <a href="#fig-var_cov_residuals" class="quarto-xref">Figure&nbsp;<span>3.8</span></a>. This empirical semivariogram is clearly different from that of the data <a href="Chapter2.html#fig-var_cov" class="quarto-xref">Figure&nbsp;<span>2.17</span></a> and has a lower sill, but it suggests that there is still spatial and temporal correlation in the residuals.</p>
</section>
</section>
<section id="predictions" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="predictions">Predictions</h3>
<p>Prediction from linear or generalized linear models in <code>R</code> is carried out using the function <code>predict</code>. As in Lab 3.1, we use the following prediction grid.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>pred_grid <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(<span class="at">lon =</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="dv">100</span>, <span class="sc">-</span><span class="dv">80</span>, <span class="at">length =</span> <span class="dv">20</span>),</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>                         <span class="at">lat =</span> <span class="fu">seq</span>(<span class="dv">32</span>, <span class="dv">46</span>, <span class="at">length =</span> <span class="dv">20</span>),</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>                         <span class="at">day =</span> <span class="fu">seq</span>(<span class="dv">4</span>, <span class="dv">29</span>, <span class="at">length =</span> <span class="dv">6</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We require all the covariate values at all the prediction locations. Hence, the 12 basis functions need to be evaluated on this grid. As above, we do this by calling <code>eval_basis</code> and converting the result to a matrix, which we then attach to our prediction grid.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>Spred <span class="ot">&lt;-</span> <span class="fu">eval_basis</span>(<span class="at">basis =</span> G,                      <span class="co"># basis functs</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">s =</span> pred_grid[,<span class="fu">c</span>(<span class="st">"lon"</span>,<span class="st">"lat"</span>)] <span class="sc">%&gt;%</span>  <span class="co"># pred locs</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>                     <span class="fu">as.matrix</span>()) <span class="sc">%&gt;%</span>         <span class="co"># conv. to matrix</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>     <span class="fu">as.matrix</span>()                              <span class="co"># results as matrix</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(Spred) <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">"B"</span>, <span class="dv">1</span><span class="sc">:</span><span class="fu">ncol</span>(Spred)) <span class="co"># assign col names</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>pred_grid <span class="ot">&lt;-</span> <span class="fu">cbind</span>(pred_grid, Spred)          <span class="co"># attach to grid</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now that we have all the covariates in place, we can call <code>predict</code>. We supply <code>predict</code> with the model <code>Tmax_July_lm</code>, the prediction grid, and the argument <code>interval = "prediction"</code>, so that <code>predict</code> returns the prediction intervals.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>linreg_pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(Tmax_July_lm,</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>                       <span class="at">newdata =</span> pred_grid,</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>                       <span class="at">interval =</span> <span class="st">"prediction"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>When <code>predict</code> is called as above, it returns a matrix containing three columns with names <code>fit</code>, <code>lwr</code>, and <code>upr</code>, which contain the prediction and the lower and upper bounds of the 95% prediction interval, respectively. Since in this case the prediction interval is the prediction <span class="math inline">\(\pm\)</span> 1.96 times the prediction standard error, we can calculate the prediction standard error from the given interval as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Assign prediction and prediction s.e. to the prediction grid</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>pred_grid<span class="sc">$</span>z_pred <span class="ot">&lt;-</span> linreg_pred[,<span class="dv">1</span>]</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>pred_grid<span class="sc">$</span>z_err <span class="ot">&lt;-</span> (linreg_pred[,<span class="dv">3</span>] <span class="sc">-</span> linreg_pred[,<span class="dv">2</span>]) <span class="sc">/</span> (<span class="dv">2</span><span class="sc">*</span><span class="fl">1.96</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Plotting the prediction and prediction standard error proceeds in a straightforward fashion using <strong>ggplot2</strong>; see <a href="#fig-LinReg_pred" class="quarto-xref">Figure&nbsp;<span>3.7</span></a>. This is left as an exercise for the reader.</p>
</section>
</section>
<section id="lab-3.3-regression-models-for-forecasting" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="lab-3.3-regression-models-for-forecasting">Lab 3.3: Regression Models for Forecasting</h2>
<p>In this Lab we fit a simple linear model to every pixel in the SST data set, and we use these models to predict SST for a month in which we have no SST data. The models will simply contain an intercept and a single covariate, namely the Southern Oscillation Index (SOI). The SOI data we use here are supplied with <strong>STRbook</strong> and were retrieved from <a href="https://www.esrl.noaa.gov/psd/gcos_wgsp/Timeseries/SOI/">https://www.esrl.noaa.gov/psd/gcos_wgsp/Timeseries/SOI/</a>.</p>
<p>For this Lab we need the usual data-wrangling and plotting packages, as well as the packages <strong>broom</strong> and <strong>purrr</strong> for fitting and predicting with multiple models simultaneously.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"broom"</span>)</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"dplyr"</span>)</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggplot2"</span>)</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"STRbook"</span>)</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"purrr"</span>)</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"tidyr"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In the first section of this Lab we tidy up the data to obtain the SST data frame from the raw data. You may also skip this section by loading <code>SST_df</code> from <strong>STRbook</strong>, and fast-forwarding to the section that is concerned with fitting the data.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"SST_df"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="tidying-up-the-data" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="tidying-up-the-data">Tidying Up the Data</h3>
<p>The first task in this Lab is to wrangle the SST data into a long-format data frame that is amenable to linear fitting and plotting. Recall from Lab 2.3 that the SST data are provided in three data frames, one describing the land mask, one containing the SST values in wide format, and one containing the coordinates.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"SSTlandmask"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"SSTdata"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"SSTlonlat"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We first combine the land mask data with the coordinates data frame.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>lonlatmask_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="fu">cbind</span>(SSTlonlat, SSTlandmask))</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(lonlatmask_df) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"lon"</span>, <span class="st">"lat"</span>, <span class="st">"mask"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then we form our SST data frame in wide format by attaching <code>SSTdata</code> to the coordinate-mask data frame.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>SSTdata <span class="ot">&lt;-</span> <span class="fu">cbind</span>(lonlatmask_df, SSTdata)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, we use <code>gather</code> to put the data frame into long format.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>SST_df <span class="ot">&lt;-</span> <span class="fu">gather</span>(SSTdata, date, sst, <span class="sc">-</span>lon, <span class="sc">-</span>lat, <span class="sc">-</span>mask)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Our data frame now contains the SST data, but the <code>date</code> field contains as entries <code>V1</code>, <code>V2</code>, …, which were the names of the columns in <code>SSTdata</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>SST_df <span class="sc">%&gt;%</span> <span class="fu">head</span>(<span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  lon lat mask date      sst
1 124 -29    1   V1 -0.36289
2 126 -29    1   V1 -0.28461
3 128 -29    1   V1 -0.19195</code></pre>
</div>
</div>
<p>We replace this <code>date</code> field with two fields, one containing the month and one containing the year. We can do this by first creating a mapping table that links <code>V1</code> to January 1970, <code>V2</code> to February 1970, and so on, and then merging using <code>left_join</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>date_grid <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(<span class="at">Month =</span> <span class="fu">c</span>(<span class="st">"Jan"</span>, <span class="st">"Feb"</span>, <span class="st">"Mar"</span>, <span class="st">"Apr"</span>,</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>                                   <span class="st">"May"</span>, <span class="st">"Jun"</span>, <span class="st">"Jul"</span>, <span class="st">"Aug"</span>,</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>                                   <span class="st">"Sep"</span>, <span class="st">"Oct"</span>, <span class="st">"Nov"</span>, <span class="st">"Dec"</span>),</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>                         <span class="at">Year =</span> <span class="dv">1970</span><span class="sc">:</span><span class="dv">2002</span>,</span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>                         <span class="at">stringsAsFactors =</span>  <span class="cn">FALSE</span>)</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>date_grid<span class="sc">$</span>date <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">"V"</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">396</span>)</span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>SST_df <span class="ot">&lt;-</span> <span class="fu">left_join</span>(SST_df, date_grid) <span class="sc">%&gt;%</span></span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>          <span class="fu">select</span>(<span class="sc">-</span>date)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For good measure, we also add in the <code>date</code> field again but this time in month–year format.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>SST_df<span class="sc">$</span>date <span class="ot">&lt;-</span> <span class="fu">paste</span>(SST_df<span class="sc">$</span>Month, SST_df<span class="sc">$</span>Year)</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>SST_df <span class="sc">%&gt;%</span> <span class="fu">head</span>(<span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  lon lat mask      sst Month Year     date
1 124 -29    1 -0.36289   Jan 1970 Jan 1970
2 126 -29    1 -0.28461   Jan 1970 Jan 1970
3 128 -29    1 -0.19195   Jan 1970 Jan 1970</code></pre>
</div>
</div>
<p>Next, we set SST data that are coincident with land locations to <code>NA</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>SST_df<span class="sc">$</span>sst <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(SST_df<span class="sc">$</span>mask <span class="sc">==</span> <span class="dv">0</span>, SST_df<span class="sc">$</span>sst, <span class="cn">NA</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Our SST data frame is now in place. The following code plots a series of SSTs leading up to the 1997 El Niño event; see <a href="#fig-SSTaproct97" class="quarto-xref">Figure&nbsp;<span>3.10</span></a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="fu">filter</span>(SST_df, Year <span class="sc">==</span> <span class="dv">1997</span> <span class="sc">&amp;</span>  <span class="co"># subset by month/year</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>                      Month <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"Apr"</span>,<span class="st">"Aug"</span>,<span class="st">"Jun"</span>,<span class="st">"Oct"</span>))) <span class="sc">+</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_tile</span>(<span class="fu">aes</span>(lon, lat,</span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>                  <span class="at">fill =</span> <span class="fu">pmin</span>(sst, <span class="dv">4</span>))) <span class="sc">+</span>  <span class="co"># clamp SST at 4deg</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">facet_wrap</span>(<span class="sc">~</span>date, <span class="at">dir =</span> <span class="st">"v"</span>) <span class="sc">+</span>         <span class="co"># facet by date</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fill_scale</span>(<span class="at">limits =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">4</span>, <span class="dv">4</span>),          <span class="co"># color limits</span></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>               <span class="at">name =</span> <span class="st">"degC"</span>) <span class="sc">+</span>            <span class="co"># legend title</span></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_bw</span>() <span class="sc">+</span> <span class="fu">coord_fixed</span>()             <span class="co"># fix scale and theme</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we need to add the SOI data to the SST data frame. The SOI time series is available as a 14-column data frame, with the first column containing the year, the next 12 columns containing the SOI for each month in the respective year, and the last column containing the mean SOI for that year. In the following, we remove the annual average from the data frame, which is in wide format, and then put it into long format using <code>gather</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb94"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"SOI"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>SOI_df <span class="ot">&lt;-</span> <span class="fu">select</span>(SOI, <span class="sc">-</span>Ann) <span class="sc">%&gt;%</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>          <span class="fu">gather</span>(Month, soi, <span class="sc">-</span>Year)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, we use <code>left_join</code> to merge the SOI data and the SST data.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>SST_df <span class="ot">&lt;-</span> <span class="fu">left_join</span>(SST_df, SOI_df,</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>                    <span class="at">by =</span> <span class="fu">c</span>(<span class="st">"Month"</span>, <span class="st">"Year"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="fitting-the-models-pixelwise" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="fitting-the-models-pixelwise">Fitting the Models Pixelwise</h4>
<p>In this section we fit linear time-series models to the SSTs in each pixel using data up to April 1997. We first create a data frame containing the SST data between January 1970 and April 1997.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>SST_pre_May <span class="ot">&lt;-</span> <span class="fu">filter</span>(SST_df, Year <span class="sc">&lt;=</span> <span class="dv">1997</span>) <span class="sc">%&gt;%</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>               <span class="fu">filter</span>(<span class="sc">!</span>(Year <span class="sc">==</span> <span class="dv">1997</span> <span class="sc">&amp;</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>                        Month <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"May"</span>, <span class="st">"Jun"</span>, <span class="st">"Jul"</span>,</span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>                                     <span class="st">"Aug"</span>, <span class="st">"Sep"</span>, <span class="st">"Oct"</span>,</span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>                                     <span class="st">"Nov"</span>, <span class="st">"Dec"</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, as in Lab 3.2, we use <strong>purrr</strong> and <strong>broom</strong> to construct a nested data frame that contains a linear model fitted to every pixel. We name the function that fits the linear model at a single pixel to the data over time as <code>fit_one_pixel</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>fit_one_pixel <span class="ot">&lt;-</span> <span class="cf">function</span>(data)</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>                 mod <span class="ot">&lt;-</span> <span class="fu">lm</span>(sst <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> soi, <span class="at">data =</span> data)</span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>pixel_lms <span class="ot">&lt;-</span> SST_pre_May <span class="sc">%&gt;%</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>             <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(sst)) <span class="sc">%&gt;%</span></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>             <span class="fu">group_by</span>(lon, lat) <span class="sc">%&gt;%</span></span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a>             <span class="fu">nest</span>() <span class="sc">%&gt;%</span></span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>             <span class="fu">mutate</span>(<span class="at">model =</span> <span class="fu">map</span>(data, fit_one_pixel)) <span class="sc">%&gt;%</span></span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a>             <span class="fu">mutate</span>(<span class="at">model_df =</span> <span class="fu">map</span>(model, tidy))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The string of commands above describes an operation that is practically identical to what we did in Lab 3.2. We take the data, filter them to remove missing data, group by pixel, create a nested data frame, fit a model to each pixel, and extract a data frame containing information on the linear fit by pixel. The first three records of the nested data frame are as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>pixel_lms <span class="sc">%&gt;%</span> <span class="fu">head</span>(<span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 3 × 5
# Groups:   lon, lat [3]
    lon   lat data               model  model_df
  &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt;             &lt;list&gt; &lt;list&gt;  
1   154   -29 &lt;tibble [328 × 6]&gt; &lt;lm&gt;   &lt;tibble&gt;
2   156   -29 &lt;tibble [328 × 6]&gt; &lt;lm&gt;   &lt;tibble&gt;
3   158   -29 &lt;tibble [328 × 6]&gt; &lt;lm&gt;   &lt;tibble&gt;</code></pre>
</div>
</div>
<p>To extract the model parameters from the linear-fit data frames, we use <code>unnest</code>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>lm_pars <span class="ot">&lt;-</span> pixel_lms <span class="sc">%&gt;%</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>           <span class="fu">unnest</span>(model_df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For each pixel, we now have an estimate of the intercept and the effect associated with the covariate <code>soi</code>, as well as other information such as the <span class="math inline">\(p\)</span>-values.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(lm_pars, <span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 3 × 9
# Groups:   lon, lat [2]
    lon   lat data               model  term        estimate
  &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt;             &lt;list&gt; &lt;chr&gt;          &lt;dbl&gt;
1   154   -29 &lt;tibble [328 × 6]&gt; &lt;lm&gt;   (Intercept)   0.132 
2   154   -29 &lt;tibble [328 × 6]&gt; &lt;lm&gt;   soi           0.0277
3   156   -29 &lt;tibble [328 × 6]&gt; &lt;lm&gt;   (Intercept)   0.0365
  std.error statistic    p.value
      &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
1    0.0266      4.96 0.00000113
2    0.0223      1.24 0.216     
3    0.0262      1.40 0.164     </code></pre>
</div>
</div>
<p>We can plot spatial maps of the intercept and the regression coefficient associated with <code>soi</code> directly. We first merge this data frame with the coordinates data frame using <code>left_join</code>, which also contains land pixels. In this way, regression coefficients over land pixels are marked as <code>NA</code>, which is appropriate.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>lm_pars <span class="ot">&lt;-</span> <span class="fu">left_join</span>(lonlatmask_df, lm_pars)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The following code plots the spatial intercept and the spatial regression coefficient associated with <code>soi</code>; see the top panels of <a href="#fig-SSTsoipred" class="quarto-xref">Figure&nbsp;<span>3.11</span></a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb104"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>g2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="fu">filter</span>(lm_pars, term <span class="sc">==</span> <span class="st">"(Intercept)"</span> <span class="sc">|</span> mask <span class="sc">==</span> <span class="dv">1</span>)) <span class="sc">+</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_tile</span>(<span class="fu">aes</span>(lon, lat, <span class="at">fill =</span> estimate)) <span class="sc">+</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fill_scale</span>() <span class="sc">+</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_bw</span>() <span class="sc">+</span> <span class="fu">coord_fixed</span>()</span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>g3 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="fu">filter</span>(lm_pars, term <span class="sc">==</span> <span class="st">"soi"</span> <span class="sc">|</span> mask <span class="sc">==</span> <span class="dv">1</span>)) <span class="sc">+</span></span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_tile</span>(<span class="fu">aes</span>(lon, lat, <span class="at">fill =</span> estimate)) <span class="sc">+</span></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fill_scale</span>() <span class="sc">+</span></span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_bw</span>() <span class="sc">+</span> <span class="fu">coord_fixed</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="predicting-sst-pixelwise" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="predicting-sst-pixelwise">Predicting SST Pixelwise</h3>
<p>We now use the linear models at the pixel level to predict the SST in October 1997 using the SOI index for that month. The SOI for that month is extracted from <code>SOI_df</code> as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>soi_pred <span class="ot">&lt;-</span> <span class="fu">filter</span>(SOI_df, Month <span class="sc">==</span> <span class="st">"Oct"</span> <span class="sc">&amp;</span> Year <span class="sc">==</span> <span class="st">"1997"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>            <span class="fu">select</span>(soi)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We next define the function that carries out the prediction at the pixel level. The function takes a linear model <code>lm</code> and the SOI at the prediction date <code>soi_pred</code>, runs the <code>predict</code> function for this date, and returns a data frame containing the prediction and the prediction standard error.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb106"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>predict_one_pixel <span class="ot">&lt;-</span> <span class="cf">function</span>(lm, soi_pred) {</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">predict</span>(lm,                           <span class="co"># linear model</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>            <span class="at">newdata =</span> soi_pred,           <span class="co"># pred. covariates</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>            <span class="at">interval =</span> <span class="st">"prediction"</span>) <span class="sc">%&gt;%</span>  <span class="co"># output intervals</span></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">data.frame</span>() <span class="sc">%&gt;%</span>                      <span class="co"># convert to df</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mutate</span>(<span class="at">se =</span> (upr<span class="sc">-</span>lwr)<span class="sc">/</span>(<span class="dv">2</span> <span class="sc">*</span> <span class="fl">1.96</span>)) <span class="sc">%&gt;%</span> <span class="co"># comp pred. se</span></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">select</span>(fit, se)                       <span class="co"># return fit &amp; se</span></span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a>  }</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Prediction proceeds at each pixel by calling <code>predict_one_pixel</code> on each row in our nested data frame <code>pixel_lms</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>SST_Oct_1997 <span class="ot">&lt;-</span> pixel_lms <span class="sc">%&gt;%</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>                <span class="fu">mutate</span>(<span class="at">preds =</span> <span class="fu">map</span>(model,</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>                                   predict_one_pixel,</span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">soi_pred =</span> soi_pred)) <span class="sc">%&gt;%</span></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>                <span class="fu">unnest</span>(preds)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We have unnested the <code>preds</code> data frame above to save the fit and prediction standard error as fields in the <code>SST_Oct_1997</code> data frame. You can type <code>SST_Oct_1997</code> %&gt;% <code>head(3)</code> to have a look at the first three records. It is straightforward to plot the prediction and prediction standard error from <code>SST_Oct_1997</code>; see the middle and bottom panels of <a href="#fig-SSTsoipred" class="quarto-xref">Figure&nbsp;<span>3.11</span></a>. This is left as an exercise for the reader.</p>
</section>
</section>
<section id="lab-3.4-generalized-linear-spatio-temporal-regression" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="lab-3.4-generalized-linear-spatio-temporal-regression">Lab 3.4: Generalized Linear Spatio-Temporal Regression</h2>
<p>In this Lab we fit a generalized linear spatio-temporal model to yearly counts of Carolina wren in and around the state of Missouri between 1994 and 2014. These counts are part of the BBS data set. We need <strong>gstat</strong>, <strong>sp</strong>, and <strong>spacetime</strong> for fitting an empirical semivariogram to the residuals, <strong>FRK</strong> to construct the basis functions (as in Lab 3.2), <strong>ape</strong> for running Moran’s <span class="math inline">\(I\)</span> test, and the usual packages for wrangling and plotting.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb108"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ape"</span>)</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"dplyr"</span>)</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"FRK"</span>)</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggplot2"</span>)</span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"gstat"</span>)</span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"sp"</span>)</span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"spacetime"</span>)</span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"STRbook"</span>)</span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"tidyr"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="fitting-the-model-1" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="fitting-the-model-1">Fitting the Model</h3>
<p>The Carolina wren counts in the BBS data set, in both wide and long format, are supplied with <strong>STRbook</strong>. Here we load the data directly in long format and remove any records that contain missing observations.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"MOcarolinawren_long"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>MOcarolinawren_long <span class="ot">&lt;-</span> MOcarolinawren_long <span class="sc">%&gt;%</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>                       <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(cnt))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We use the same covariates to fit these data as we did to fit the maximum temperature, <code>Tmax</code>, in Lab 3.2. Twelve of these covariates were basis functions constructed using <code>auto_basis</code> from the package <strong>FRK</strong>; see Lab 3.2 for details. The matrix <code>S</code> below then contains the basis functions evaluated at the Carolina wren observation locations.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb110"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>G <span class="ot">&lt;-</span> <span class="fu">auto_basis</span>(<span class="at">data =</span> MOcarolinawren_long[,<span class="fu">c</span>(<span class="st">"lon"</span>,<span class="st">"lat"</span>)] <span class="sc">%&gt;%</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>                       <span class="fu">SpatialPoints</span>(),           <span class="co"># To sp obj</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">nres =</span> <span class="dv">1</span>,                         <span class="co"># One resolution</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">type =</span> <span class="st">"Gaussian"</span>)                <span class="co"># Gaussian BFs</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>S <span class="ot">&lt;-</span> <span class="fu">eval_basis</span>(<span class="at">basis =</span> G,                       <span class="co"># basis functions</span></span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>                <span class="at">s =</span> MOcarolinawren_long[,<span class="fu">c</span>(<span class="st">"lon"</span>,<span class="st">"lat"</span>)] <span class="sc">%&gt;%</span></span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>                     <span class="fu">as.matrix</span>()) <span class="sc">%&gt;%</span>            <span class="co"># conv. to matrix</span></span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a>     <span class="fu">as.matrix</span>()                                 <span class="co"># conv. to matrix</span></span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(S) <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">"B"</span>, <span class="dv">1</span><span class="sc">:</span><span class="fu">ncol</span>(S)) <span class="co"># assign column names</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, we attach the basis-function covariate information to the data frame containing the counts, and remove the fields <code>loc.ID</code> and <code>t</code>, which we will not explicitly use when fitting the model. We list the first five columns of the first three records of our constructed data frame <code>Wren_df</code> as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a>Wren_df <span class="ot">&lt;-</span> <span class="fu">cbind</span>(MOcarolinawren_long,S) <span class="sc">%&gt;%</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">-</span>loc.ID, <span class="sc">-</span>t)</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>Wren_df[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  cnt  lat   lon year      B1
1   4 36.8 -89.2 1994 0.00258
2   2 36.6 -90.7 1994 0.03551
3   8 36.9 -91.7 1994 0.11588</code></pre>
</div>
</div>
<p>Generalized linear models (GLMs) are fitted in <code>R</code> using the function <code>glm</code>. The function works similarly to <code>lm</code>, but in addition it requires one to specify the exponential-family model that is used (in this first instance we consider the Poisson family), as well as the link function (here we use the log function, which is the canonical link). The <code>glm</code> function is called as follows (note that we have used the same formula as in Lab 3.2).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>Wren_GLM <span class="ot">&lt;-</span> <span class="fu">glm</span>(cnt <span class="sc">~</span> (lon <span class="sc">+</span> lat <span class="sc">+</span> year)<span class="sc">^</span><span class="dv">2</span> <span class="sc">+</span> ., <span class="co"># formula</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">family =</span> <span class="fu">poisson</span>(<span class="st">"log"</span>),     <span class="co"># Poisson + log link</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">data =</span> Wren_df)              <span class="co"># data set</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The mean and variance of a random variable that has a Poisson distribution are the same. In cases where the variance in the data is greater than that suggested by this model, the data are said to exhibit “over-dispersion.” An estimate of the dispersion is given by the ratio of the deviance to the total degrees of freedom (the number of data points minus the number of covariates). In this case the dispersion estimate is</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb114"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>Wren_GLM<span class="sc">$</span>deviance <span class="sc">/</span> Wren_GLM<span class="sc">$</span>df.residual</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3.78</code></pre>
</div>
</div>
<p>which is greater than 1, a sign of over-dispersion.</p>
<p>Another way to obtain an estimate of the dispersion parameter (and, to account for it if present) is to replace <code>poisson</code> with <code>quasipoisson</code> when calling <code>glm</code>, and then type <code>summary(Wren_GLM)</code>. The quasi-Poisson model assumes that the variance is proportional to the mean, and that the constant of the proportionality is the over-dispersion parameter. Note from the output of <code>summary</code> that the dispersion parameter is 3.9, which is close to what we estimated above.</p>
<p>It can be shown that under the null hypothesis of no over-dispersion, the deviance is approximately chi-squared distributed with degrees of freedom equal to <span class="math inline">\(m - p - 1\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb116"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>Wren_GLM<span class="sc">$</span>df.residual</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 764</code></pre>
</div>
</div>
<p>The observed deviance is</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb118"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>Wren_GLM<span class="sc">$</span>deviance</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2890</code></pre>
</div>
</div>
<p>The probability of observing such a large or larger deviance under the null hypothesis of no over-dispersion (i.e., the <span class="math inline">\(p\)</span>-value) is</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb120"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> <span class="sc">-</span> <span class="fu">pchisq</span>(<span class="at">q =</span> Wren_GLM<span class="sc">$</span>deviance, <span class="at">df =</span> Wren_GLM<span class="sc">$</span>df.residual)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0</code></pre>
</div>
</div>
<p>Therefore, we reject the null hypothesis of no over-dispersion at the usual levels of significance (10%, 5%, and 1%). One may use other models in the exponential family, such as the negative-binomial distribution, to account explicitly for the over-dispersion. For convenience, in this Lab we proceed with the Poisson family. We use the negative-binomial distribution in Lab 4.4.</p>
<section id="prediction" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="prediction">Prediction</h4>
<p>As in the other Labs, prediction proceeds through use of the function <code>predict</code>. We first generate our space-time prediction grid, which is an 80 <span class="math inline">\(\times\)</span> 80 <span class="math inline">\(\times\)</span> 21 grid in degrees <span class="math inline">\(\times\)</span> degrees <span class="math inline">\(\times\)</span> years, covering the observations in space and in time.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb122"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>pred_grid <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(<span class="at">lon =</span> <span class="fu">seq</span>(</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>                             <span class="fu">min</span>(MOcarolinawren_long<span class="sc">$</span>lon) <span class="sc">-</span> <span class="fl">0.2</span>,</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>                             <span class="fu">max</span>(MOcarolinawren_long<span class="sc">$</span>lon) <span class="sc">+</span> <span class="fl">0.2</span>,</span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>                             <span class="at">length.out =</span> <span class="dv">80</span>),</span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>                         <span class="at">lat =</span> <span class="fu">seq</span>(</span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a>                             <span class="fu">min</span>(MOcarolinawren_long<span class="sc">$</span>lat) <span class="sc">-</span> <span class="fl">0.2</span>,</span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a>                             <span class="fu">max</span>(MOcarolinawren_long<span class="sc">$</span>lat) <span class="sc">+</span> <span class="fl">0.2</span>,</span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a>                             <span class="at">length.out =</span> <span class="dv">80</span>),</span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a>                         <span class="at">year =</span> <span class="dv">1994</span><span class="sc">:</span><span class="dv">2014</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As in Lab 3.2, we now evaluate the basis functions at the prediction locations.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb123"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>S_pred <span class="ot">&lt;-</span> <span class="fu">eval_basis</span>(<span class="at">basis =</span> G,                    <span class="co"># basis functs</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">s =</span> pred_grid[,<span class="fu">c</span>(<span class="st">"lon"</span>,<span class="st">"lat"</span>)] <span class="sc">%&gt;%</span> <span class="co"># pred locs</span></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>                     <span class="fu">as.matrix</span>()) <span class="sc">%&gt;%</span>            <span class="co"># conv. to matrix</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>     <span class="fu">as.matrix</span>()                                 <span class="co"># as matrix</span></span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(S_pred) <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">"B"</span>, <span class="dv">1</span><span class="sc">:</span><span class="fu">ncol</span>(S_pred))  <span class="co"># assign  names</span></span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a>pred_grid <span class="ot">&lt;-</span> <span class="fu">cbind</span>(pred_grid,S_pred)             <span class="co"># attach to grid</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In the call to <code>predict</code> below, we specify <code>type = "link"</code> to indicate that we predict the link function of the response and not the response (analogous to the log-intensity of the process).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb124"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>wren_preds <span class="ot">&lt;-</span> <span class="fu">predict</span>(Wren_GLM,</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">newdata =</span> pred_grid,</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>                      <span class="at">type =</span> <span class="st">"link"</span>,</span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>                      <span class="at">se.fit =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The predictions and prediction standard errors of the link function of the response are then attached to our prediction grid for plotting; see <a href="#fig-GLMfit_Wren" class="quarto-xref">Figure&nbsp;<span>3.12</span></a>. Plotting to obtain <a href="#fig-GLMfit_Wren" class="quarto-xref">Figure&nbsp;<span>3.12</span></a> is left as an exercise for the reader.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb125"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>pred_grid <span class="ot">&lt;-</span> pred_grid <span class="sc">%&gt;%</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>             <span class="fu">mutate</span>(<span class="at">log_cnt =</span> wren_preds<span class="sc">$</span>fit,</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>                    <span class="at">se =</span> wren_preds<span class="sc">$</span>se.fit)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>When fitting GLMs, it is good practice to check the deviance residuals and inspect them for any residual correlation. The default GLM residuals returned by <code>residuals</code> are deviance residuals.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb126"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>Wren_df<span class="sc">$</span>residuals <span class="ot">&lt;-</span> <span class="fu">residuals</span>(Wren_GLM)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Interestingly, the plot of the deviance residuals in <a href="#fig-GLMresiduals_Wren" class="quarto-xref">Figure&nbsp;<span>3.14</span></a> is “noisy,” indicating a lack of spatial correlation.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb127"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>g2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(Wren_df) <span class="sc">+</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="fu">aes</span>(lon, lat, <span class="at">colour =</span> residuals)) <span class="sc">+</span></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">col_scale</span>(<span class="at">name =</span> <span class="st">"residuals"</span>) <span class="sc">+</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">facet_wrap</span>(<span class="sc">~</span>year, <span class="at">nrow =</span> <span class="dv">3</span>) <span class="sc">+</span> <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-GLMresiduals_Wren" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-GLMresiduals_Wren-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_3/GLMresiduals_Wren.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-GLMresiduals_Wren-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.14: The deviance residuals from the fitted GLM between <span class="math inline">\(t=1\)</span> (the year 1994) and <span class="math inline">\(t=21\)</span> (2014).
</figcaption>
</figure>
</div>
<p>We can test for spatial correlation of the deviance residuals by running Moran’s <span class="math inline">\(I\)</span> test on the spatial deviance residuals for each year. The code below follows closely that for Moran’s <span class="math inline">\(I\)</span> test in Lab 3.2 and then summarizes the <span class="math inline">\(p\)</span>-values obtained for each year.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb128"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>P <span class="ot">&lt;-</span> <span class="fu">list</span>()                                 <span class="co"># init list</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>years <span class="ot">&lt;-</span> <span class="dv">1994</span><span class="sc">:</span><span class="dv">2014</span></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="fu">seq_along</span>(years)) {                <span class="co"># for each day</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>  Wren_year <span class="ot">&lt;-</span> <span class="fu">filter</span>(Wren_df,</span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>                     year <span class="sc">==</span> years[i])      <span class="co"># filter by year</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a>  obs_dists <span class="ot">&lt;-</span> Wren_year <span class="sc">%&gt;%</span>                <span class="co"># take the data</span></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">select</span>(lon,lat) <span class="sc">%&gt;%</span>                     <span class="co"># extract coords.</span></span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">dist</span>() <span class="sc">%&gt;%</span>                              <span class="co"># comp. dists.</span></span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">as.matrix</span>()                             <span class="co"># conv. to matrix</span></span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a>  obs_dists.inv <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span>obs_dists              <span class="co"># weight matrix</span></span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">diag</span>(obs_dists.inv) <span class="ot">&lt;-</span> <span class="dv">0</span>                  <span class="co"># 0 on diag</span></span>
<span id="cb128-12"><a href="#cb128-12" aria-hidden="true" tabindex="-1"></a>  P[[i]] <span class="ot">&lt;-</span> <span class="fu">Moran.I</span>(Wren_year<span class="sc">$</span>residuals,    <span class="co"># run Moran's I</span></span>
<span id="cb128-13"><a href="#cb128-13" aria-hidden="true" tabindex="-1"></a>                    obs_dists.inv) <span class="sc">%&gt;%</span></span>
<span id="cb128-14"><a href="#cb128-14" aria-hidden="true" tabindex="-1"></a>            <span class="fu">do.call</span>(<span class="st">"cbind"</span>, .)             <span class="co"># conv. to df</span></span>
<span id="cb128-15"><a href="#cb128-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb128-16"><a href="#cb128-16" aria-hidden="true" tabindex="-1"></a><span class="fu">do.call</span>(<span class="st">"rbind"</span>,P) <span class="sc">%&gt;%</span> <span class="fu">summary</span>(<span class="at">digits =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    observed         expected            sd       
 Min.   :-0.084   Min.   :-0.040   Min.   :0.025  
 1st Qu.:-0.059   1st Qu.:-0.029   1st Qu.:0.028  
 Median :-0.044   Median :-0.029   Median :0.030  
 Mean   :-0.041   Mean   :-0.028   Mean   :0.031  
 3rd Qu.:-0.022   3rd Qu.:-0.025   3rd Qu.:0.033  
 Max.   : 0.010   Max.   :-0.023   Max.   :0.041  
    p.value    
 Min.   :0.06  
 1st Qu.:0.24  
 Median :0.42  
 Mean   :0.47  
 3rd Qu.:0.68  
 Max.   :0.94  </code></pre>
</div>
</div>
<p>Hence, at the 5% level of significance, the null hypothesis (of no spatial correlation in these deviance residuals) is not rejected. This was expected from the visualization in <a href="#fig-GLMresiduals_Wren" class="quarto-xref">Figure&nbsp;<span>3.14</span></a>.</p>
<p>More insight can be obtained by looking at the empirical semivariogram of the deviance residuals. To do this we first construct an <code>STIDF</code>, thereby casting the irregular space-time data into a <strong>spacetime</strong> object.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb130"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>Wren_STIDF <span class="ot">&lt;-</span> <span class="fu">STIDF</span>(<span class="at">sp =</span> <span class="fu">SpatialPoints</span>(</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>                            Wren_df[,<span class="fu">c</span>(<span class="st">"lon"</span>,<span class="st">"lat"</span>)],</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>                            <span class="at">proj4string =</span> <span class="fu">CRS</span>(<span class="st">"+proj=longlat"</span>)),</span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a>                    <span class="at">time =</span> <span class="fu">as.Date</span>(Wren_df[, <span class="st">"year"</span>] <span class="sc">%&gt;%</span></span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a>                                       <span class="fu">as.character</span>(),</span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">format =</span> <span class="st">"%Y"</span>),</span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a>                    <span class="at">data =</span> Wren_df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then we compute the empirical semivariogram using <code>variogram</code>. We consider time bins of width 1 year (i.e., of width 52.1429 weeks). Bins specified in units of weeks are required, as this is the largest temporal unit recognized by <code>variogram</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb131"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>tlags <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="fl">0.01</span>, <span class="fl">52.1429</span><span class="sc">*</span><span class="dv">6</span> <span class="sc">+</span> <span class="fl">0.01</span>, <span class="at">by =</span> <span class="fl">52.1429</span>)</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>vv <span class="ot">&lt;-</span> <span class="fu">variogram</span>(<span class="at">object =</span> residuals <span class="sc">~</span> <span class="dv">1</span>, <span class="co"># fixed effect component</span></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">data =</span> Wren_STIDF,      <span class="co"># data set</span></span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">tlags =</span> tlags,          <span class="co"># temp. bins</span></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a>                <span class="at">width =</span> <span class="dv">25</span>,             <span class="co"># spatial bin (25 km)</span></span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a>                <span class="at">cutoff =</span> <span class="dv">150</span>,           <span class="co"># use pts &lt; 150 km apart</span></span>
<span id="cb131-7"><a href="#cb131-7" aria-hidden="true" tabindex="-1"></a>                <span class="at">tunit =</span> <span class="st">"weeks"</span>)        <span class="co"># time unit</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The empirical semivariogram can be plotted using <code>plot(vv)</code>. Notice how there is little evidence of spatial correlation but ample evidence of temporal correlation in the residuals. (The variance of the differences over a large range of time lags at the same spatial location is small.) This is a clear sign that a more sophisticated spatio-temporal random-effects model should be considered for these data.</p>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" data-line-spacing="2" role="list" style="display: none">
<div id="ref-box1976science" class="csl-entry" role="listitem">
Box, G. E. P. (1976). Science and statistics. <em>Journal of the American Statistical Association</em>, <em>71</em>(356), 791–799.
</div>
<div id="ref-box1979robustness" class="csl-entry" role="listitem">
Box, G. E. P. (1979). Robustness in the strategy of scientific model building. In R. L. Launer &amp; G. L. Wilkinson (Eds.), <em>Robustness in statistics</em> (pp. 201–236). Academic Press.
</div>
<div id="ref-cressie1993statistics" class="csl-entry" role="listitem">
Cressie, N. (1993). <em>Statistics for spatial data</em> (revised). John Wiley &amp; Sons.
</div>
<div id="ref-cressie2011statistics" class="csl-entry" role="listitem">
Cressie, N., &amp; Wikle, C. K. (2011). <em>Statistics for spatio-temporal data</em>. John Wiley &amp; Sons.
</div>
<div id="ref-hastie2009elements" class="csl-entry" role="listitem">
Hastie, T., Tibshirani, R., &amp; Friedman, J. (2009). <em>The elements of statistical learning</em> (2nd ed.). Springer.
</div>
<div id="ref-henebry1995spatial" class="csl-entry" role="listitem">
Henebry, G. M. (1995). Spatial model error analysis using autocorrelation indices. <em>Ecological Modelling</em>, <em>82</em>(1), 75–91.
</div>
<div id="ref-james2013introduction" class="csl-entry" role="listitem">
James, G., Witten, D., Hastie, T., &amp; Tibshirani, R. (2013). <em>An introduction to statistical learning</em>. Springer.
</div>
<div id="ref-kutner2004applied" class="csl-entry" role="listitem">
Kutner, H., M, Nachtsheim, C. J., &amp; Neter, J. (2004). <em>Applied multiple regression models</em>. McGraw-Hill.
</div>
<div id="ref-mccullagh1989generalized" class="csl-entry" role="listitem">
McCullagh, P., &amp; Nelder, J. A. (1989). <em>Generalized linear models</em>. Cambridge University Press.
</div>
<div id="ref-mcculloch2001generalized" class="csl-entry" role="listitem">
McCulloch, C. E., &amp; Searle, S. R. (2001). <em>Generalized, linear, and mixed models</em>. John Wiley &amp; Sons.
</div>
<div id="ref-shumway2006time" class="csl-entry" role="listitem">
Shumway, R. H., &amp; Stoffer, D. S. (2006). <em>Time series analysis and its applications with r examples</em> (2nd ed.). Springer.
</div>
<div id="ref-waller2004applied" class="csl-entry" role="listitem">
Waller, L. A., &amp; Gotway, C. A. (2004). <em>Applied spatial statistics for public health data</em>. John Wiley &amp; Sons.
</div>
<div id="ref-R_mgcv" class="csl-entry" role="listitem">
Wood, S. N. (2017). <em>Generalized additive models: An introduction with r</em> (2nd ed.). Chapman &amp; Hall/CRC.
</div>
</div>
</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chapter2.html" class="pagination-link" aria-label="Exploring Spatio-Temporal Data">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Exploring Spatio-Temporal Data</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Chapter4.html" class="pagination-link" aria-label="Descriptive Spatio-Temporal Statistical Models">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Descriptive Spatio-Temporal Statistical Models</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>