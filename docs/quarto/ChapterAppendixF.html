<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.28">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Appendix F — Case Study: Quadratic Echo State Networks for Sea Surface Temperature Long-Lead Prediction – Spatio-Temporal Statistics with R (1st edition)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./ChapterRPackages.html" rel="next">
<link href="./ChapterAppendixE.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-b719d3d4935f2b08311a76135e2bf442.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-7d2e1f8220df954187ab24ed36a0da9c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/quarto-contrib/foldbox/foldbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
.Algorithm {
  --color1: #948bde;
  --color2: #584eab;
}
</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./ChapterAppendixA.html">Appendices</a></li><li class="breadcrumb-item"><a href="./ChapterAppendixF.html"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">Case Study: Quadratic Echo State Networks for Sea Surface Temperature Long-Lead Prediction</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Spatio-Temporal Statistics with R (1st edition)</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction to Spatio-Temporal Statistics</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Exploring Spatio-Temporal Data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Spatio-Temporal Statistical Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Descriptive Spatio-Temporal Statistical Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Dynamic Spatio-Temporal Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Evaluating Spatio-Temporal Statistical Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterPergimus.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Pergimus (Epilogue)</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixA.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Some Useful Matrix-Algebra Definitions and Properties</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixB.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">General Smoothing Kernels</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixC.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Estimation and Prediction for Dynamic Spatio-Temporal Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixD.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">D</span>&nbsp; <span class="chapter-title">Mechanistically Motivated Dynamic Spatio-Temporal Models</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixE.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">Case Study: Physical-Statistical Bayesian Hierarchical Model for Predicting Mediterranean Surface Winds</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendixF.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">Case Study: Quadratic Echo State Networks for Sea Surface Temperature Long-Lead Prediction</span></span></a>
  </div>
</li>
      </ul>
  </li>
  <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterRPackages.html" class="sidebar-item-text sidebar-link">
  <span class="menu-text">List of <code>R</code> packages</span></a>
  </div>
  </li>
  <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
  <span class="menu-text">References</span></a>
  </div>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#implementation-in-r" id="toc-implementation-in-r" class="nav-link active" data-scroll-target="#implementation-in-r">Implementation in R</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./ChapterAppendixA.html">Appendices</a></li><li class="breadcrumb-item"><a href="./ChapterAppendixF.html"><span class="chapter-number">F</span>&nbsp; <span class="chapter-title">Case Study: Quadratic Echo State Networks for Sea Surface Temperature Long-Lead Prediction</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-QESNapp" class="quarto-section-identifier">Appendix F — Case Study: Quadratic Echo State Networks for Sea Surface Temperature Long-Lead Prediction</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Recall from <a href="Chapter5.html#sec-nonlinearDSTMs" class="quarto-xref"><span>Section 5.4</span></a> that recurrent neural networks (RNNs) were developed in the engineering and machine-learning literature to accommodate time-dependent cycles and sequences as well as the concept of “memory” in a neural network. But, like the statistical GQN (also discussed in <a href="Chapter5.html#sec-nonlinearDSTMs" class="quarto-xref"><span>Section 5.4</span></a>), RNNs have an extremely high-dimensional parameter space and can be difficult to fit. In contrast, the echo state network (ESN) is a type of RNN that considers sparsely connected hidden layers that allow for sequential interactions, yet specifies (remarkably) most of the parameters (“weights”) to be randomly generated and then fixed, with only the parameters that connect the hidden layer to the response being estimated (see the overview in <span class="citation" data-cites="jaeger2007echo">Jaeger (<a href="references.html#ref-jaeger2007echo" role="doc-biblioref">2007</a>)</span>). We consider a modification of the ESN in this case study. Note that although the models presented here are relatively simple to implement, the notational burden and (especially) the machine-learning jargon can take some getting used to.</p>
<p>A simple representation of an ESN is given by the following hierarchical model for data vector <span class="math inline">\(\mathbf{Z}_t\)</span> (assumed to be <span class="math inline">\(m\)</span>-dimensional here):</p>
<p><span id="eq-ESNresp"><span class="math display">\[
\mathbf{Z}_t = g_o(\mathbf{V}\mathbf{h}_t),
\tag{F.1}\]</span></span></p>
<p><span id="eq-ESNhidden"><span class="math display">\[
\mathbf{h}_t = g_h(\mathbf{W}\mathbf{h}_{t-1} + \mathbf{U}\mathbf{x}_t).
\tag{F.2}\]</span></span></p>
<p>In the data model (<a href="#eq-ESNresp" class="quarto-xref">Equation&nbsp;<span>F.1</span></a>) and the process model (<a href="#eq-ESNhidden" class="quarto-xref">Equation&nbsp;<span>F.2</span></a>), <span class="math inline">\(\mathbf{h}_t\)</span> is an <span class="math inline">\(n\)</span>-dimensional vector of latent (“hidden”) states, <span class="math inline">\(\mathbf{x}_t\)</span> is a <span class="math inline">\(p\)</span>-dimensional input vector, <span class="math inline">\(\mathbf{V}\)</span> is an <span class="math inline">\(m \times n\)</span> output-parameter weight matrix, <span class="math inline">\(\mathbf{W}\)</span> is an <span class="math inline">\(n \times n\)</span> hidden-process-evolution-parameter weight matrix, <span class="math inline">\(\mathbf{U}\)</span> is an <span class="math inline">\(n \times p\)</span> input-parameter weight matrix, and <span class="math inline">\(g_o(\cdot)\)</span> and <span class="math inline">\(g_h(\cdot)\)</span> are so-called “activation functions” (e.g., identity, softmax, hyperbolic tangent). The hidden-state model <a href="#eq-ESNhidden" class="quarto-xref">Equation&nbsp;<span>F.2</span></a> is sometimes called a “reservoir.” This reservoir is key to this modeling framework in that the parameter weight matrices in <a href="#eq-ESNhidden" class="quarto-xref">Equation&nbsp;<span>F.2</span></a>, <span class="math inline">\(\mathbf{W}\)</span> and <span class="math inline">\(\mathbf{U}\)</span>, are sparse (only 1–10% of the parameters are non-zero) with non-zero elements <em>chosen at random</em> and fixed (for details, see the example that follows). This means that only the output weights (in <span class="math inline">\(\mathbf{V}\)</span>) are estimated, substantially reducing the estimation burden. In most applications, <span class="math inline">\(g_o(\cdot)\)</span> is the identity function, and <span class="math inline">\(\mathbf{V}\)</span> can be estimated with regression methods that include regularization, such as a ridge regression or a lasso penalty (see <a href="Chapter3.html#nte-technote-RidgeLassoReg" class="quarto-xref">Note&nbsp;<span>3.4</span></a>). These models work surprisingly well for forecasting central tendency and classification, but they are limited for inference and uncertainty quantification. Notice that there are no error terms in this model!</p>
<p><span class="citation" data-cites="mcdermott2017ensemble">McDermott &amp; Wikle (<a href="references.html#ref-mcdermott2017ensemble" role="doc-biblioref">2017</a>)</span> modified the basic ESN algorithm for use with spatio-temporal data to include quadratic nonlinear outputs, so-called “embedding inputs” (see below), and reservoir parameter uncertainty by considering an ensemble (bootstrap) sample of forecasts. Their quadratic echo state network (QESN), for <span class="math inline">\(t=1,\ldots,T\)</span>, is given by:</p>
<p>Response: <span id="eq-QESNresp"><span class="math display">\[
{\mathbf{Y}}_t = {\mathbf{V}}_1 {\mathbf{h}}_t + {\mathbf{V}}_2 {\mathbf{h}}^2_t + {\boldsymbol{\epsilon}}_t, \quad \textrm{for} \quad {\boldsymbol{\epsilon}}_t \; \sim \; Gau({\mathbf{0}},\sigma^2_\epsilon \mathbf{I});
\tag{F.3}\]</span></span></p>
<p>Hidden state: <span id="eq-QESNhidden"><span class="math display">\[
{\mathbf{h}}_t = g_h\left(\frac{\nu}{|\lambda_w|}{\mathbf{W}} {\mathbf{h}}_{t-1} + {\mathbf{U}}\tilde{\mathbf{x}}_t\right);
\tag{F.4}\]</span></span></p>
<p>Parameters: <span id="eq-QESNw"><span class="math display">\[
{\mathbf{W}} = [w_{i,\ell}]_{i,\ell}: w_{i,\ell} = \gamma^w_{i,\ell} \; Unif(-a_w,a_w) + (1 - \gamma^w_{i,\ell}) \; \delta_0,
\tag{F.5}\]</span></span></p>
<p><span id="eq-QESNu"><span class="math display">\[
{\mathbf{U}} = [u_{i,j}]_{i,j}: u_{i,j} = \gamma^u_{i,j} \; Unif(-a_u,a_u) + (1 - \gamma^u_{i,j}) \; \delta_0,
\tag{F.6}\]</span></span></p>
<p><span id="eq-piw"><span class="math display">\[
\gamma_{i,\ell}^w \; \sim \; Bern(\pi_w),
\tag{F.7}\]</span></span></p>
<p><span id="eq-piu"><span class="math display">\[
\gamma_{i,j}^u \; \sim \; Bern(\pi_u)
\tag{F.8}\]</span></span></p>
<p>where <span class="math inline">\({\mathbf{Y}}_t\)</span> is the <span class="math inline">\(n_y\)</span>-dimensional response vector at time <span class="math inline">\(t\)</span>; <span class="math inline">\({\mathbf{h}}_t\)</span> is the <span class="math inline">\(n_h\)</span>-dimensional hidden-state vector; <span class="math inline">\({\mathbf{h}}^2_t\)</span> is the <span class="math inline">\(n-h\)</span>-dimensional vector where the square operation is defined elementwise;</p>
<p><span id="eq-QEQNembed"><span class="math display">\[
\tilde{\mathbf{x}}_t = [\mathbf{x}'_t,\mathbf{x}'_{t-\tau*}, \mathbf{x}'_{t- 2 \tau*},\ldots,\mathbf{x}'_{t - m \tau*}]'
\tag{F.9}\]</span></span></p>
<p>is the <span class="math inline">\(n_{\tilde{x}} = (m+1) n_x\)</span>-dimensional “embedding input” vector, containing lagged values (embeddings) of the inputs <span class="math inline">\(\{\mathbf{x}_t\}\)</span> for time periods <span class="math inline">\(t- \tau*\)</span> through <span class="math inline">\(t - m \tau*\)</span>, where the quantity <span class="math inline">\(\tau*\)</span> is the embedding lag (a positive integer, often set equal to the forecast lead time); and <span class="math inline">\(Bern(\cdot)\)</span> denotes the Bernoulli distribution. As in the basic ESN above, <span class="math inline">\(\mathbf{W}\)</span> is the <span class="math inline">\(n \times n\)</span> hidden-process-evolution weight matrix, <span class="math inline">\(\mathbf{U}\)</span> is the <span class="math inline">\(n \times p\)</span> input weight matrix, and <span class="math inline">\(\mathbf{V}_1\)</span>, <span class="math inline">\(\mathbf{V}_2\)</span> are the <span class="math inline">\(n \times n_h\)</span> linear and quadratic output weight matrices, respectively. Furthermore, <span class="math inline">\(\delta_0\)</span> is a Kronecker delta function at zero, <span class="math inline">\(\lambda_w\)</span> corresponds to the largest eigenvalue of <span class="math inline">\({\mathbf{W}}\)</span> (i.e., the “spectral radius” of <span class="math inline">\(\mathbf{W}\)</span>), and <span class="math inline">\(\nu\)</span> is a spectral-radius control parameter. The “activation function” <span class="math inline">\(g_h(\cdot)\)</span> (a hyperbolic tangent function in our application below) controls the nonlinearity of the hidden-state evolution. The only parameters that are estimated in this model are <span class="math inline">\({\boldsymbol{V}}_1\)</span>, <span class="math inline">\({\mathbf{V}}_2\)</span>, and <span class="math inline">\(\sigma^2_\epsilon\)</span> from <a href="#eq-QESNresp" class="quarto-xref">Equation&nbsp;<span>F.3</span></a>, for which we require a ridge-regression penalty parameter, <span class="math inline">\(r_v\)</span> (see <a href="Chapter3.html#nte-technote-RidgeLassoReg" class="quarto-xref">Note&nbsp;<span>3.4</span></a>). Importantly, note that the matrices <span class="math inline">\({\mathbf{W}}\)</span> and <span class="math inline">\({\mathbf{U}}\)</span> are simulated from mixture distributions of small values (uniformly sampled in the range <span class="math inline">\((-a_w,a_w)\)</span> and <span class="math inline">\((-a_u,a_u)\)</span>, respectively) with, respectively, <span class="math inline">\((1-\pi_w)\)</span> and <span class="math inline">\((1-\pi_u)\)</span> elements set equal to zero on average. After being sampled, these parameters are assumed to be fixed and known. Typically, these weight matrices are very sparse (e.g., of the order of <span class="math inline">\(1\)</span>–<span class="math inline">\(10\%\)</span> non-zeros). The hyperparameters, <span class="math inline">\(\{\nu, n_h, r_v, \pi_w, \pi_u, a_w, a_u\}\)</span>, are usually chosen by cross-validation.</p>
<p>As is the case in most traditional ESN applications, the QESN model does not have an explicit mechanism to quantify uncertainty in the process or in the parameters. This is a bit troubling given that the reservoir weight matrices <span class="math inline">\(\mathbf{W}\)</span> and <span class="math inline">\(\mathbf{U}\)</span> are not estimated, but are chosen at random. We would expect that the model is likely to behave differently with a different set of weight matrices. This is especially true when the number of hidden units is fairly small. Although traditional ESN models typically have a very large number of hidden units, which tends to give more stable predictions, it can be desirable to have many different forecasts using a smaller number of hidden units. This provides flexibility in that it prevents overfitting, allows the various forecasts to behave as a “committee of relatively weak learners,” and gives a more realistic sense of the prediction uncertainty for out-of-sample forecasts. Thus, we could generate an ensemble or bootstrap sample of forecasts. As shown in <span class="citation" data-cites="mcdermott2017ensemble">McDermott &amp; Wikle (<a href="references.html#ref-mcdermott2017ensemble" role="doc-biblioref">2017</a>)</span>, this ensemble approach can be implemented straightforwardly with the QESN model using the algorithm in <a href="#nte-algorithm-E-QESN" class="quarto-xref">Note&nbsp;<span>F.1</span></a>.</p>
<div id="nte-algorithm-E-QESN" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;F.1: Ensemble QESN Algorithm
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Initialize</strong>: Select tuning parameters <span class="math inline">\(\{ν, n_h, r_v, π_w, π_u, a_w, a_u\}\)</span> (e.g., by cross-validation with a standalone QESN)</p>
<p><strong>for</strong> <span class="math inline">\(k = 1\)</span> to <span class="math inline">\(K\)</span> <strong>do</strong></p>
<ol type="1">
<li><p>Simulate <span class="math inline">\(\mathbf{W}^{(k)}\)</span>, <span class="math inline">\(\mathbf{U}^{(k)}\)</span> using <a href="#eq-QESNw" class="quarto-xref">Equation&nbsp;<span>F.5</span></a> and <a href="#eq-QESNu" class="quarto-xref">Equation&nbsp;<span>F.6</span></a> and initialize <span class="math inline">\({\mathbf{h}}_1^{(k)}\)</span></p></li>
<li><p>Calculate <span class="math inline">\(\{{\mathbf{h}}_t^{(k)}: t=2,...,T\}\)</span> using <a href="#eq-QESNhidden" class="quarto-xref">Equation&nbsp;<span>F.4</span></a></p></li>
<li><p>Use ridge regression to estimate <span class="math inline">\(\mathbf{V}^{(k)}_1, \mathbf{V}^{(k)}_2\)</span>, and <span class="math inline">\(\sigma^2_\epsilon\)</span></p></li>
<li><p>Calculate out-of-sample forecasts <span class="math inline">\(\{\widehat{\mathbf{Y}}^{(k)}_t: t=T+1,...,T+\tau\}\)</span>, where <span class="math inline">\(\tau\)</span> is the forecast lead time (requires calculating <span class="math inline">\(\{\widehat{{\mathbf{h}}}^{(k)}_t: t=T+1,...,T+\tau\}\)</span> from <a href="#eq-QESNhidden" class="quarto-xref">Equation&nbsp;<span>F.4</span></a>)</p></li>
</ol>
<p><strong>end for</strong></p>
<p>Use ensemble of forecasts <span class="math inline">\(\{\widehat{\mathbf{Y}}^{(k)}_t: t=T+1,...,T+\tau; k = 1,...,K\}\)</span> to calculate moments, prediction intervals, etc.</p>
</div>
</div>
<section id="implementation-in-r" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="implementation-in-r">Implementation in R</h3>
<p>In what follows, we provide a demonstration of the ensemble QESN model applied to long-lead forecasting of sea-surface temperature using the SST data set.</p>
<section id="ensemble-qesn-model-data-preparation" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="ensemble-qesn-model-data-preparation">Ensemble QESN Model Data Preparation</h4>
<p>To prepare the data, we need <strong>ggplot2</strong>, <strong>dplyr</strong>, <strong>STRbook</strong>, and <strong>tidyr</strong>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggplot2"</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"dplyr"</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"STRbook"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"tidyr"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The functions needed for this case study are provided with <strong>STRbook</strong>. Our purpose here is to show that this nonlinear DSTM can be implemented in <code>R</code> fairly easily. If readers are interested in adapting these functions to their own applications, it is worth browsing through the functions to see how the code is implemented (visit <a href="https://github.com/andrewzm/STRbook">https://github.com/andrewzm/STRbook</a>).</p>
<p>We first load the SST data set. This time we shall use the data up to October 1996 as training data and perform out-of-sample six-month forecasts from April 1997 to July 1999.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"SSTlandmask"</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"SSTlonlat"</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"SSTdata"</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>delete_rows <span class="ot">&lt;-</span> <span class="fu">which</span>(SSTlandmask <span class="sc">==</span> <span class="dv">1</span>)   <span class="co"># find land values</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>SSTdataA <span class="ot">&lt;-</span> SSTdata[<span class="sc">-</span>delete_rows, ]      <span class="co"># remove land values</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In this application, we shall evaluate the forecast in terms of the time series corresponding to the average of the SST anomalies in the so-called Niño 3.4 region (defined to be the region of the tropical Pacific Ocean contained by <span class="math inline">\(5^\circ\)</span>S–<span class="math inline">\(5^\circ\)</span>N, <span class="math inline">\(170^\circ\)</span>W–<span class="math inline">\(120^\circ\)</span>W).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="do">## find grid locations corresponding to Nino 3.4 region;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="do">## note, 190 - 240 deg E longitude corresponds</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="do">## to 170 - 120 deg W longitude</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>nino34Index <span class="ot">&lt;-</span> <span class="fu">which</span>(SSTlonlat[,<span class="dv">2</span>] <span class="sc">&lt;=</span> <span class="dv">5</span> <span class="sc">&amp;</span> SSTlonlat[, <span class="dv">2</span>] <span class="sc">&gt;=</span> <span class="sc">-</span><span class="dv">5</span> <span class="sc">&amp;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>                       SSTlonlat[,<span class="dv">1</span>] <span class="sc">&gt;=</span> <span class="dv">190</span> <span class="sc">&amp;</span> SSTlonlat[, <span class="dv">1</span>] <span class="sc">&lt;=</span> <span class="dv">240</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The object <code>SSTdataA</code> is a 2261 × 399 matrix in time-wide format. In the code below, we save the number of spatial locations in the variable <code>nspatial</code>. Of the 399 time points, we only need 322 for training, the number of months between (and including) January 1970 and October 1996. We define a six-month-ahead forecast by specifying <code>tau = 6</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>nspatial <span class="ot">&lt;-</span> <span class="fu">nrow</span>(SSTdataA)    <span class="co"># number of spat. locations</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>TrainLen <span class="ot">&lt;-</span> <span class="dv">322</span>               <span class="co"># no. of months to Oct 1996</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>tau <span class="ot">&lt;-</span> <span class="dv">6</span>                      <span class="co"># forecast lead time (months)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We train the ESN on time series associated with the first ten EOFs extracted from the SST (training) data. The following code follows closely what was done in Labs 2.3 and 5.3.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">10</span>                               <span class="co"># number of EOFs to retain</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>Z <span class="ot">&lt;-</span> <span class="fu">t</span>(SSTdataA[, <span class="dv">1</span><span class="sc">:</span>TrainLen])        <span class="co"># data matrix</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>spat_mean <span class="ot">&lt;-</span> <span class="fu">apply</span>(SSTdataA, <span class="dv">1</span>, mean)        <span class="co"># spatial mean</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>Zspat_detrend <span class="ot">&lt;-</span> Z <span class="sc">-</span> <span class="fu">outer</span>(<span class="fu">rep</span>(<span class="dv">1</span>, TrainLen), <span class="co"># detrend data</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>                           spat_mean)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>Zt <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span><span class="fu">sqrt</span>(TrainLen <span class="sc">-</span> <span class="dv">1</span>)<span class="sc">*</span>Zspat_detrend     <span class="co"># normalize</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>E <span class="ot">&lt;-</span> <span class="fu">svd</span>(Zt)                   <span class="co"># SVD</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>PHI <span class="ot">&lt;-</span> E<span class="sc">$</span>v[, <span class="dv">1</span><span class="sc">:</span>n]              <span class="co"># 10 EOF spatial basis functions</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>TS <span class="ot">&lt;-</span> <span class="fu">t</span>(SSTdataA) <span class="sc">%*%</span> PHI      <span class="co"># project data onto basis functions</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>                               <span class="co"># for PC time series</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we need to create the training and validation data sets. Both data sets will need input data and output data. Since we are setting up the ESN for six-months-ahead forecasting, as input we use the PC time series (see <a href="Chapter2.html#sec-EOFs" class="quarto-xref"><span>Section 2.4.3</span></a>) lagged by six months with respect to the output. For example, the PC time-series values at January 1970 are inputs (<span class="math inline">\(\mathbf{x}_t\)</span>) to forecast the SST (output) in July 1970. For prediction, we consider forecasting at ten three-month intervals starting from October 1996 (we chose three-month intervals to improve the visualization, but one can forecast each month if desired).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="do">## training set</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>xTrainIndex <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span>(TrainLen <span class="sc">-</span> tau) <span class="co"># training period ind. for input</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>yTrainIndex <span class="ot">&lt;-</span> (tau<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>(TrainLen) <span class="co"># shifted period ind. for output</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>xTrain <span class="ot">&lt;-</span> TS[xTrainIndex, ]       <span class="co"># training input time series</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>yTrain <span class="ot">&lt;-</span> TS[yTrainIndex, ]       <span class="co"># training output time series</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="do">## test set: forecast every three months</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>xTestIndex <span class="ot">&lt;-</span> <span class="fu">seq</span>(TrainLen, <span class="at">by =</span> <span class="dv">3</span>, <span class="at">length.out =</span> <span class="dv">10</span>)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>yTestIndex <span class="ot">&lt;-</span> xTestIndex<span class="sc">+</span>tau       <span class="co"># test output indices</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>xTest <span class="ot">&lt;-</span> TS[xTestIndex,]           <span class="co"># test input data</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>yTest <span class="ot">&lt;-</span> TS[yTestIndex,]           <span class="co"># test output data</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>testLen <span class="ot">&lt;-</span> <span class="fu">nrow</span>(xTest)             <span class="co"># number of test cases</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="ensemble-qesn-model-implementation" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="ensemble-qesn-model-implementation">Ensemble QESN Model Implementation</h4>
<p>We first have to make some model choices and set some parameters to run the ensemble QESN model. For model details and terminology, see the description above.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>quadInd <span class="ot">&lt;-</span> <span class="cn">TRUE</span>  <span class="co"># include both quadratic and linear output terms</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co"># if FALSE, then include only linear terms</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>ensembleLen <span class="ot">&lt;-</span> <span class="dv">500</span>  <span class="co"># number of ensemble members (i.e., QESN runs)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The next set of parameters can be trained by cross-validation or out-of-sample validation <span class="citation" data-cites="mcdermott2017ensemble">(see <a href="references.html#ref-mcdermott2017ensemble" role="doc-biblioref">McDermott &amp; Wikle, 2017</a>)</span>. For simplicity, we use the values obtained in that paper (which considered a similar long-lead SST forecasting application) here. The model arguments required as input are: <code>wWidth</code>, which corresponds to the parameter <span class="math inline">\(a_w\)</span> that specifies the range of the uniform distribution for the <span class="math inline">\(\mathbf{W}\)</span> weight matrix parameters in <a href="#eq-QESNw" class="quarto-xref">Equation&nbsp;<span>F.5</span></a>; similarly, <code>uWidth</code>, which corresponds to the parameter <span class="math inline">\(a_u\)</span> that specifies the range of the uniform distribution for the <span class="math inline">\(\mathbf{U}\)</span> matrix in <a href="#eq-QESNu" class="quarto-xref">Equation&nbsp;<span>F.6</span></a>; <code>piW</code>, which corresponds to <span class="math inline">\(\pi_w\)</span> in <a href="#eq-piw" class="quarto-xref">Equation&nbsp;<span>F.7</span></a>, the probability of a non-zero <span class="math inline">\(\mathbf{W}\)</span> weight; <code>piU</code>, which corresponds to <span class="math inline">\(\pi_u\)</span>, the probability of non-zero <span class="math inline">\(\mathbf{U}\)</span> weight parameter in <a href="#eq-piu" class="quarto-xref">Equation&nbsp;<span>F.8</span></a>; <code>curNh</code>, which corresponds to <span class="math inline">\(n_h\)</span>, the number of hidden units; <code>curNu</code>, which corresponds to <span class="math inline">\(\nu\)</span>, the spectral radius of the <span class="math inline">\(\mathbf{W}\)</span> matrix; <code>curM</code>, which corresponds to <span class="math inline">\(m\)</span>, the number of lags (embeddings) of input vectors to use; <code>tauEMB</code>, which corresponds to the embedding lag (<span class="math inline">\(\tau*\)</span> in <a href="#eq-QEQNembed" class="quarto-xref">Equation&nbsp;<span>F.9</span></a>); and <code>curRV</code>, which corresponds to <span class="math inline">\(r_v\)</span>, the ridge-regression parameter associated with the estimation of the output matrices, <span class="math inline">\(\mathbf{V}_1\)</span> and <span class="math inline">\(\mathbf{V}_2\)</span> in <a href="#eq-QESNresp" class="quarto-xref">Equation&nbsp;<span>F.3</span></a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>wWidth <span class="ot">&lt;-</span> .<span class="dv">10</span>      <span class="co"># W-weight matrix, uniform dist "width" param.</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>uWidth <span class="ot">&lt;-</span> .<span class="dv">10</span>      <span class="co"># U-weight matrix, uniform dist "width" param.</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>piW <span class="ot">&lt;-</span> .<span class="dv">10</span>         <span class="co"># sparseness parameter for W-weight matrix</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>piU <span class="ot">&lt;-</span> .<span class="dv">10</span>         <span class="co"># sparseness parameter for U-weight matrix</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>curNh <span class="ot">&lt;-</span> <span class="dv">120</span>       <span class="co"># number of hidden units</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>curNu <span class="ot">&lt;-</span> .<span class="dv">35</span>       <span class="co"># scaling parameter for W-weight matrix</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>curM <span class="ot">&lt;-</span> <span class="dv">4</span>          <span class="co"># number of embeddings</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>tauEMB <span class="ot">&lt;-</span> <span class="dv">6</span>        <span class="co"># embedding lag</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>curRV <span class="ot">&lt;-</span> .<span class="dv">01</span>       <span class="co"># output ridge regression parameter</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we use the function <code>createEmbedRNNData</code> to create a data object containing responses and embedding matrix inputs (see <a href="#eq-QEQNembed" class="quarto-xref">Equation&nbsp;<span>F.9</span></a>) for the training and prediction data sets (note that the responses and inputs are scaled by their respective standard deviations, as is common in the ESN literature). The function takes as inputs variables defined above: <code>curM</code>, the number of embedding lags; <code>tauEMB</code>, the embedding lag; <code>tau</code>, the forecast lead time; <code>yTrain</code>, the training output time series; <code>TS</code>, the input time series associated with the projection of the data onto the EOFs; and <code>xTestIndex</code>, which identifies the indices for the input data corresponding to the test periods.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="do">## standardize and create embedding matrices</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>DataObj <span class="ot">&lt;-</span> <span class="fu">createEmbedRNNData</span>(curM, tauEMB, tau, yTrain, TS,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                              xTestIndex)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The returned object, <code>DataObj</code>, is a list containing inputs and training data in the format required to train the ESN. We now need to create a parameter object that contains the parameters to be used in constructing the ESN. The function we use initializes the vectors associated with: the embedding matrix <span class="math inline">\(\tilde{\mathbf{x}}_t\)</span> in <a href="#eq-QEQNembed" class="quarto-xref">Equation&nbsp;<span>F.9</span></a>; the hidden state <span class="math inline">\(\mathbf{h}_t\)</span> in <a href="#eq-QESNhidden" class="quarto-xref">Equation&nbsp;<span>F.4</span></a>; and the ridge-regression matrix, <span class="math inline">\(r_v {\mathbf{I}}\)</span> (as defined in <a href="Chapter3.html#nte-technote-RidgeLassoReg" class="quarto-xref">Note&nbsp;<span>3.4</span></a>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>setParObj <span class="ot">&lt;-</span> <span class="fu">setParsEESN</span>(curRV ,curNh, n, curM, quadInd)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We save the forecasts in a three-dimensional array, with the first dimension indexing the ensemble number, the second dimension indexing the forecast time point, and the third dimension indexing the EOF number. We also create a second three-dimensional array with the first two dimensions the same, and the third dimension indexing spatial location.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>fmatESNFin <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="fu">c</span>(ensembleLen, testLen, n))</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>fmatESNFinFull <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="cn">NA</span>,<span class="fu">c</span>(ensembleLen, testLen, nspatial))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We are now ready to run the ensemble of QESN models to obtain forecasts. For each ensemble, we run the function <code>genResR</code>, which takes arguments defined previously as input: <code>curNh</code>, the number of hidden units; <code>wWidth</code> and <code>uWidth</code>, the uniform distribution sampling range for <span class="math inline">\(\mathbf{W}\)</span> and <span class="math inline">\(\mathbf{U}\)</span>, respectively; <code>piW</code> and <code>piU</code>, the probabilities of non-zeros in <span class="math inline">\(\mathbf{W}\)</span> and <span class="math inline">\(\mathbf{U}\)</span>, respectively; <code>curNu</code>, the spectral-radius parameter; <code>quadInd</code>, the indicator on whether to include the quadratic output weights or not; <code>DataObj</code>, the embedding input matrices; <code>setParObj</code>, the initializations corresponding to the hidden state vectors and the ridge-regression matrices; and <code>testLen</code>, the number of test cases.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(iEnsem <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>ensembleLen) {</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Run the QESN model for a single ensemble</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  QESNOutObj <span class="ot">=</span> <span class="fu">genResR</span>(<span class="at">nh =</span> curNh,</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>                       <span class="at">wWidth =</span> wWidth,</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>                       <span class="at">uWidth =</span> uWidth,</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>                       <span class="at">piW =</span> piW,</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>                       <span class="at">piU =</span> piU,</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>                       <span class="at">nuESN =</span> curNu,</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>                       <span class="at">quadInd =</span> quadInd,</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>                       <span class="at">DataObj =</span> DataObj,</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>                       <span class="at">setParObj =</span> setParObj,</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>                       <span class="at">testLen =</span> testLen)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>  <span class="do">## save forecasts for the reduced dimension output</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>  fmatESNFin[iEnsem, , ] <span class="ot">&lt;-</span> <span class="fu">t</span>(QESNOutObj<span class="sc">$</span>unScaledForecasts)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>  <span class="do">## forecasts for the full spatial field</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>  fmatESNFinFull[iEnsem, , ] <span class="ot">&lt;-</span> fmatESNFin[iEnsem, , ] <span class="sc">%*%</span> <span class="fu">t</span>(PHI)</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="post-processing-the-ensemble-qesn-output" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="post-processing-the-ensemble-qesn-output">Post-Processing the Ensemble QESN Output</h4>
<p>In this section, we focus on post-processing the ensemble QESN output for the Niño 3.4 region. To assess whether or not we have the correct coverage of the prediction intervals, we consider 95% (pointwise) prediction intervals.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>alpha <span class="ot">&lt;-</span> .<span class="dv">05</span>   <span class="co"># alpha-level of 1-alpha pred. intervals (P.I.s)</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>lwPI <span class="ot">&lt;-</span> alpha<span class="sc">/</span><span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In the following code, we calculate the mean and the lower/upper boundaries of the 95% prediction interval for the Niño 3.4 region (across the whole ensemble of realizations from the predictive distribution).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>nino34AvgPreds <span class="ot">&lt;-</span> nino34LwPI <span class="ot">&lt;-</span> nino34UpPI <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, testLen)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>testLen){</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  nino34AvgPreds[i] <span class="ot">&lt;-</span> fmatESNFinFull[,i,nino34Index] <span class="sc">%&gt;%</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mean</span>()</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  nino34LwPI[i] <span class="ot">&lt;-</span> fmatESNFinFull[, i, nino34Index] <span class="sc">%&gt;%</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rowMeans</span>() <span class="sc">%&gt;%</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">quantile</span>(lwPI)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  nino34UpPI[i] <span class="ot">&lt;-</span> fmatESNFinFull[,i,nino34Index] <span class="sc">%&gt;%</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rowMeans</span>() <span class="sc">%&gt;%</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">quantile</span>(<span class="dv">1</span> <span class="sc">-</span> lwPI)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>nino34_results <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">AvgPres =</span> nino34AvgPreds,</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>                             <span class="at">LwPI =</span> nino34LwPI,</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>                             <span class="at">UpPI =</span> nino34UpPI)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>These predictive-distribution summaries can be compared to the average SST at the prediction month, which we calculate as follows:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>nino34_results<span class="sc">$</span>AvgObs <span class="ot">&lt;-</span> SSTdata[nino34Index, yTestIndex] <span class="sc">%&gt;%</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colMeans</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, we allocate the prediction-month labels to the data frame which, for this example, is achieved as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>nino34_results<span class="sc">$</span>date <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="fu">as.Date</span>(<span class="st">"1997-04-01"</span>),</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>                           <span class="at">length.out =</span> <span class="dv">10</span>, <span class="at">by =</span> <span class="st">"3 months"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="plotting-results-for-forecasts-in-the-niño-3.4-region" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="plotting-results-for-forecasts-in-the-niño-3.4-region">Plotting Results for Forecasts in the Niño 3.4 Region</h4>
<p>In this last section, we focus our plots on the results for spatially averaged SST anomalies over the Niño 3.4 region for every third month (to make the plot less cluttered). Although we skip months and present the spatial average for ease of visualization, we note that the full spatial fields could easily be plotted for any of the forecast months, as shown in Lab 5.3. In <a href="#fig-QESN_N34_Forecasts" class="quarto-xref">Figure&nbsp;<span>F.1</span></a>, we plot the prediction and prediction intervals for the spatial average alongside the spatial average of the observations by month. The following code produces this figure.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>gresults <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(nino34_results) <span class="sc">+</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">x =</span> date, <span class="at">y =</span> AvgObs)) <span class="sc">+</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_ribbon</span>(<span class="fu">aes</span>(<span class="at">x =</span> date, <span class="at">ymin =</span> LwPI, <span class="at">ymax =</span> UpPI),</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>              <span class="at">alpha =</span> <span class="fl">0.1</span>, <span class="at">fill =</span> <span class="st">"black"</span>) <span class="sc">+</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">x =</span> date, <span class="at">y =</span> AvgPres), <span class="at">col =</span> <span class="st">"red"</span>) <span class="sc">+</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="fu">expression</span>(<span class="fu">paste</span>(<span class="st">"Ni"</span>, <span class="fu">tilde</span>(n), <span class="st">"o 3.4 Index"</span>))) <span class="sc">+</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"Month"</span>) <span class="sc">+</span> <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-QESN_N34_Forecasts" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-QESN_N34_Forecasts-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_5/ESN_N34_Forecast2.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-QESN_N34_Forecasts-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;F.1: Out-of-sample six-month forecasts of SST anomalies averaged over the Niño 3.4 region from April 1997 to July 1999 (every three months). The black line shows the truth and the red line shows the average of the ensemble of QESN forecasts. The point-wise 95% prediction intervals from the ensemble of QESN forecasts is shown with light-gray shading.
</figcaption>
</figure>
</div>
<p>Although pointwise prediction intervals are informative, it can also be helpful to plot the trajectories of individual forecasts from the QESN model. This can be done by first assigning a number (say, the first 15) of ensemble trajectories to the data frame and then putting the data frame into long format using <code>gather</code>. The following code produces <a href="#fig-QESN_N34_ForecastsENS" class="quarto-xref">Figure&nbsp;<span>F.2</span></a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Compute the spatial average over Nino3.4 for each ensemble</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">15</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  nino34_results[<span class="fu">paste0</span>(<span class="st">"Sim"</span>, i)] <span class="ot">&lt;-</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rowMeans</span>(fmatESNFinFull[i, , nino34Index])</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="do">## Convert to long data frame</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>nino34_results_long <span class="ot">&lt;-</span> nino34_results <span class="sc">%&gt;%</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span>AvgPres, <span class="sc">-</span>LwPI,</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>                <span class="sc">-</span>UpPI, <span class="sc">-</span>AvgObs) <span class="sc">%&gt;%</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">gather</span>(SimNum, SSTindex, <span class="sc">-</span>date)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="do">## Plot</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>gresults2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(nino34_results_long) <span class="sc">+</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> nino34_results, <span class="fu">aes</span>(<span class="at">x =</span> date, <span class="at">y =</span> AvgObs)) <span class="sc">+</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">x =</span> date, <span class="at">y =</span> SSTindex, <span class="at">group =</span> SimNum,</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>                <span class="at">linetype =</span> SimNum, <span class="at">colour =</span> SimNum)) <span class="sc">+</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="fu">expression</span>(<span class="fu">paste</span>(<span class="st">"Ni"</span>, <span class="fu">tilde</span>(n), <span class="st">"o 3.4 Index"</span>))) <span class="sc">+</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"Month"</span>) <span class="sc">+</span> <span class="fu">theme_bw</span>() <span class="sc">+</span> <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">"none"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-QESN_N34_ForecastsENS" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-QESN_N34_ForecastsENS-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_5/ESN_N34_ForecastENS2.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-QESN_N34_ForecastsENS-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;F.2: Out-of-sample six-month forecasts of SST anomalies averaged over the Niño 3.4 region from April 1997 through July 1999 (every three months). The black line shows the truth, and other lines show the first 15 ensemble members from the ensemble of QESN model forecasts.
</figcaption>
</figure>
</div>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" data-line-spacing="2" role="list" style="display: none">
<div id="ref-jaeger2007echo" class="csl-entry" role="listitem">
Jaeger, H. (2007). Echo state network. <em>Scholarpedia</em>, <em>2</em>(9), 2330.
</div>
<div id="ref-mcdermott2017ensemble" class="csl-entry" role="listitem">
McDermott, P. L., &amp; Wikle, C. K. (2017). An ensemble quadratic echo state network for non-linear spatio-temporal forecasting. <em>Stat</em>, <em>6</em>(1), 315–330.
</div>
</div>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./ChapterAppendixE.html" class="pagination-link" aria-label="Case Study: Physical-Statistical Bayesian Hierarchical Model for Predicting Mediterranean Surface Winds">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">E</span>&nbsp; <span class="chapter-title">Case Study: Physical-Statistical Bayesian Hierarchical Model for Predicting Mediterranean Surface Winds</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./ChapterRPackages.html" class="pagination-link" aria-label="List of `R` packages">
        <span class="nav-page-text">List of <code>R</code> packages</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>