<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.28">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>8&nbsp; Appendices – Spatio-Temporal Statistics with R (1st edition)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./references.html" rel="next">
<link href="./ChapterPergimus.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-b719d3d4935f2b08311a76135e2bf442.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-7d2e1f8220df954187ab24ed36a0da9c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./ChapterAppendices.html"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Appendices</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Spatio-Temporal Statistics with R (1st edition)</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction to Spatio-Temporal Statistics</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Exploring Spatio-Temporal Data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Spatio-Temporal Statistical Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Descriptive Spatio-Temporal Statistical Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Dynamic Spatio-Temporal Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Evaluating Spatio-Temporal Statistical Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterPergimus.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Pergimus (Epilogue)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendices.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Appendices</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterRPackages.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">List of <code>R</code> packages</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-matrixalgebra" id="toc-sec-matrixalgebra" class="nav-link active" data-scroll-target="#sec-matrixalgebra"><span class="header-section-number">8.1</span> Some Useful Matrix-Algebra Definitions and Properties</a></li>
  <li><a href="#sec-AppendSmooth" id="toc-sec-AppendSmooth" class="nav-link" data-scroll-target="#sec-AppendSmooth"><span class="header-section-number">8.2</span> General Smoothing Kernels</a></li>
  <li><a href="#sec-Appendix5a" id="toc-sec-Appendix5a" class="nav-link" data-scroll-target="#sec-Appendix5a"><span class="header-section-number">8.3</span> Estimation and Prediction for Dynamic Spatio-Temporal Models</a>
  <ul class="collapse">
  <li><a href="#sec-estimationMoM" id="toc-sec-estimationMoM" class="nav-link" data-scroll-target="#sec-estimationMoM"><span class="header-section-number">8.3.1</span> Estimation in Vector Autoregressive Spatio-Temporal Models via the Method of Moments</a></li>
  <li><a href="#sec-estimationLDSTM" id="toc-sec-estimationLDSTM" class="nav-link" data-scroll-target="#sec-estimationLDSTM"><span class="header-section-number">8.3.2</span> Prediction and Estimation in Fully Parameterized Linear DSTMs</a></li>
  <li><a href="#sec-Est_and_pred" id="toc-sec-Est_and_pred" class="nav-link" data-scroll-target="#sec-Est_and_pred"><span class="header-section-number">8.3.3</span> Estimation for Non-Gaussian and Nonlinear DSTMs</a></li>
  </ul></li>
  <li><a href="#sec-Appendix5b" id="toc-sec-Appendix5b" class="nav-link" data-scroll-target="#sec-Appendix5b"><span class="header-section-number">8.4</span> Mechanistically Motivated Dynamic Spatio-Temporal Models</a>
  <ul class="collapse">
  <li><a href="#sec-PDEdecomp1" id="toc-sec-PDEdecomp1" class="nav-link" data-scroll-target="#sec-PDEdecomp1"><span class="header-section-number">8.4.1</span> Example of a Process Model Motivated by a PDE: Finite Differences</a></li>
  <li><a href="#sec-PDEdecomp" id="toc-sec-PDEdecomp" class="nav-link" data-scroll-target="#sec-PDEdecomp"><span class="header-section-number">8.4.2</span> Example of a Process Model Motivated by a PDE: Spectral</a></li>
  <li><a href="#sec-IDEdecomp" id="toc-sec-IDEdecomp" class="nav-link" data-scroll-target="#sec-IDEdecomp"><span class="header-section-number">8.4.3</span> Example of a Process Model Motivated by an IDE</a></li>
  </ul></li>
  <li><a href="#sec-PDEdecomp_MedWinds" id="toc-sec-PDEdecomp_MedWinds" class="nav-link" data-scroll-target="#sec-PDEdecomp_MedWinds"><span class="header-section-number">8.5</span> Case Study: Physical-Statistical Bayesian Hierarchical Model for Predicting Mediterranean Surface Winds</a>
  <ul class="collapse">
  <li><a href="#implementation-in-r" id="toc-implementation-in-r" class="nav-link" data-scroll-target="#implementation-in-r">Implementation in <code>R</code></a></li>
  </ul></li>
  <li><a href="#sec-QESNapp" id="toc-sec-QESNapp" class="nav-link" data-scroll-target="#sec-QESNapp"><span class="header-section-number">8.6</span> Case Study: Quadratic Echo State Networks for Sea Surface Temperature Long-Lead Prediction</a>
  <ul class="collapse">
  <li><a href="#implementation-in-r-1" id="toc-implementation-in-r-1" class="nav-link" data-scroll-target="#implementation-in-r-1">Implementation in R</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Appendices</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="sec-matrixalgebra" class="level2" data-number="8.1">
<h2 data-number="8.1" class="anchored" data-anchor-id="sec-matrixalgebra"><span class="header-section-number">8.1</span> Some Useful Matrix-Algebra Definitions and Properties</h2>
<p>For the sake of completeness, we provide some definitions and properties of vectors and matrices that are needed to understand many of the formulas and equations in this book. Readers who are already familiar with matrix algebra can skip this section. Readers who would like more detail than the bare minimum presented here can find them in books on matrix algebra or multivariate statistics (e.g., <span class="citation" data-cites="johnson1992applied">Johnson and Wichern (<a href="references.html#ref-johnson1992applied" role="doc-biblioref">1992</a>)</span>, <span class="citation" data-cites="schott2016matrix">Schott (<a href="references.html#ref-schott2016matrix" role="doc-biblioref">2017</a>)</span>).</p>
<p><strong>Vectors and matrices</strong>. In this book we denote a <em>vector</em> (a column of numbers) by a bold letter (Latin or Greek); for example,</p>
<p><span class="math display">\[
{\mathbf{a}} = \left[\begin{array}{c} a_1 \\ a_2\\ \vdots \\ a_p \end{array} \right]
\]</span></p>
<p>represents a <span class="math inline">\(p\)</span>-dimensional vector, and <span class="math inline">\({\mathbf{a}}' = [a_1, a_2, \ldots, a_p]\)</span> or <span class="math inline">\((a_1, a_2,\ldots,a_p)\)</span> is its <span class="math inline">\(p\)</span>-dimensional transpose.</p>
<p>We also denote a <em>matrix</em> (an array of numbers) by bold upper-case letters (Latin or Greek); for example,</p>
<p><span class="math display">\[
{\mathbf{A}} = \left[ \begin{array}{cccc}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\
\vdots &amp; \vdots &amp; \; &amp; \vdots \\
a_{p1} &amp; a_{p2} &amp; \cdots &amp; a_{pn} \\
\end{array}\right]
\]</span></p>
<p>is a <span class="math inline">\(p \times n\)</span> matrix, and <span class="math inline">\(a_{k \ell}\)</span> corresponds to the element in the <span class="math inline">\(k\)</span>th row and <span class="math inline">\(\ell\)</span>th column; sometimes it is also written as <span class="math inline">\(\{a_{k \ell}\}\)</span>. The matrix transpose, <span class="math inline">\(\mathbf{A}'\)</span>, is then an <span class="math inline">\(n \times p\)</span> matrix given by</p>
<p><span class="math display">\[
{\mathbf{A}}' = \left[ \begin{array}{cccc}
a_{11} &amp; a_{21} &amp; \cdots &amp; a_{p1} \\
a_{12} &amp; a_{22} &amp; \cdots &amp; a_{p2} \\
\vdots &amp; \vdots &amp; \; &amp; \vdots \\
a_{1n} &amp; a_{2n} &amp; \cdots &amp; a_{pn} \\
\end{array}\right].
\]</span></p>
<p>We often consider a special matrix known as the <em>identity matrix</em>, denoted <span class="math inline">\(\mathbf{I}_n\)</span>, which is an <span class="math inline">\(n \times n\)</span> diagonal matrix with ones along the main diagonal (i.e., <span class="math inline">\(a_{ii}=1\)</span> for <span class="math inline">\(i=1,\ldots,n\)</span>) and zeros for all of the off-diagonal elements (i.e., <span class="math inline">\(a_{ij} = 0, \mbox{for } i \neq j\)</span>). It is sometimes the case that the dimensional subscript (in this case, <span class="math inline">\(n\)</span>) is left off if the context is clear.</p>
<p>Finally, note that a vector can be thought of as a special case of a <span class="math inline">\(p \times n\)</span> matrix, where either <span class="math inline">\(p=1\)</span> or <span class="math inline">\(n=1\)</span>.</p>
<p><strong>Matrix addition</strong>. Matrix addition is defined for two matrices that have the same dimension. Then, given <span class="math inline">\(p \times n\)</span> matrices <span class="math inline">\(\mathbf{A}\)</span> and <span class="math inline">\(\mathbf{B}\)</span>, with elements <span class="math inline">\(\{a_{k \ell}\}\)</span> and <span class="math inline">\(\{b_{k \ell}\}\)</span> for <span class="math inline">\(k=1,\ldots,p\)</span> and <span class="math inline">\(\ell = 1,\ldots,n\)</span>, respectively, the elements of the matrix sum, <span class="math inline">\(\mathbf{C}= \{c_{k \ell}\} = \mathbf{A}+ \mathbf{B}\)</span>, are given by</p>
<p><span class="math display">\[
c_{k \ell} = a_{k \ell} + b_{k \ell}, \quad k=1,\ldots,p;\ \ell = 1,\ldots,n.
\]</span></p>
<p><strong>Scalar multiplication</strong>. Consider an arbitrary scalar, <span class="math inline">\(c\)</span>, and the <span class="math inline">\(p \times n\)</span> matrix <span class="math inline">\(\mathbf{A}\)</span>. Scalar multiplication by a matrix then gives a new matrix in which each element of the matrix <span class="math inline">\(\mathbf{A}\)</span> is multiplied individually by the scalar <span class="math inline">\(c\)</span>. Specifically, <span class="math inline">\(c \mathbf{A}= \mathbf{A}c = \mathbf{G}\)</span>, where each element of <span class="math inline">\(\mathbf{G}= \{g_{k \ell}\}\)</span> is given by <span class="math inline">\(g_{k \ell} = c a_{k \ell}\)</span>, for <span class="math inline">\(k=1,\ldots,p\)</span> and <span class="math inline">\(\ell = 1,\ldots,n\)</span>.</p>
<p><strong>Matrix subtraction</strong>. As with matrix addition, matrix subtraction is defined for two matrices that have the same dimension. Consider the two <span class="math inline">\(p \times n\)</span> matrices <span class="math inline">\(\mathbf{A}\)</span> and <span class="math inline">\(\mathbf{B}\)</span>, with elements <span class="math inline">\(\{a_{k \ell}\}\)</span> and <span class="math inline">\(\{b_{k \ell}\}\)</span>, for <span class="math inline">\(k=1,\ldots,p\)</span> and <span class="math inline">\(\ell = 1,\ldots,n\)</span>, respectively. The matrix difference between <span class="math inline">\(\mathbf{A}\)</span> and <span class="math inline">\(\mathbf{B}\)</span> is then given by <span class="math display">\[
\mathbf{C}= \{c_{k \ell}\} = \mathbf{A}- \mathbf{B}= \mathbf{A}+ (-1)\mathbf{B},
\]</span> where it can be seen that the elements of <span class="math inline">\(\mathbf{C}\)</span> are given by <span class="math inline">\(c_{k \ell} = a_{k \ell} - b_{k \ell}\)</span>, for <span class="math inline">\(k=1,\ldots,p\)</span> and <span class="math inline">\(\ell = 1,\ldots,n\)</span>. Thus, matrix subtraction is just a combination of matrix addition and scalar multiplication (by <span class="math inline">\(- 1\)</span>).</p>
<p><strong>Matrix multiplication</strong>. The product of the <span class="math inline">\(p \times n\)</span> matrix <span class="math inline">\(\mathbf{A}\)</span> and <span class="math inline">\(n \times m\)</span> matrix <span class="math inline">\(\mathbf{B}\)</span> is given by the <span class="math inline">\(p \times m\)</span> matrix <span class="math inline">\(\mathbf{C}\)</span>, where <span class="math inline">\(\mathbf{C}= \{c_{kj}\} = \mathbf{A}\mathbf{B}\)</span>, with <span class="math display">\[
c_{kj} = \sum_{\ell = 1}^n a_{k \ell} b_{\ell j}, \quad k=1,\ldots,p;\ j=1,\ldots,m.
\]</span> Thus, for the matrix product <span class="math inline">\(\mathbf{A}\mathbf{B}\)</span> to exist, the number of columns in <span class="math inline">\(\mathbf{A}\)</span> must equal the number of rows in <span class="math inline">\(\mathbf{B}\)</span>; so <span class="math inline">\(\mathbf{C}\)</span> always has the number of rows that are in <span class="math inline">\(\mathbf{A}\)</span> and the number of columns that are in <span class="math inline">\(\mathbf{B}\)</span>.</p>
<p><strong>Orthogonal matrix</strong>. A square <span class="math inline">\(p \times p\)</span> matrix <span class="math inline">\(\mathbf{A}\)</span> is said to be <em>orthogonal</em> if <span class="math inline">\(\mathbf{A}\mathbf{A}' = \mathbf{A}' \mathbf{A}= \mathbf{I}_p\)</span>.</p>
<p><strong>Vector inner product</strong>. As a special case of matrix multiplication, consider two vectors, <span class="math inline">\(\mathbf{a}\)</span> and <span class="math inline">\(\mathbf{b}\)</span>, both of length <span class="math inline">\(p\)</span>. The <em>inner product</em> of <span class="math inline">\(\mathbf{a}\)</span> and <span class="math inline">\(\mathbf{b}\)</span> is given by the scalar <span class="math inline">\(\mathbf{a}' \mathbf{b}= \mathbf{b}' \mathbf{a}\equiv \sum_{k=1}^p a_k b_k\)</span>.</p>
<p><strong>Vector outer product</strong>. For another special case of matrix multiplication, consider a <span class="math inline">\(p\)</span>-dimensional vector <span class="math inline">\(\mathbf{a}\)</span> and a <span class="math inline">\(q\)</span>-dimensional vector <span class="math inline">\(\mathbf{b}\)</span>. The <em>outer product</em> <span class="math inline">\(\mathbf{a}\mathbf{b}'\)</span> is given by the <span class="math inline">\(p \times q\)</span> matrix <span class="math display">\[
\mathbf{a}\mathbf{b}' \equiv
\left[ \begin{array}{cccc}
a_{1} b_{1} &amp; a_{1} b_2 &amp; \cdots &amp; a_1 b_q \\
a_{2} b_1 &amp; a_{2} b_2 &amp; \cdots &amp; a_2 b_q \\
\vdots &amp; \vdots &amp; \; &amp; \vdots \\
a_{p} b_1 &amp; a_{p} b_2 &amp; \cdots &amp; a_{p} b_q \\
\end{array}\right].
\]</span> Note that (in general) <span class="math inline">\(\mathbf{a}\mathbf{b}' \neq \mathbf{b}' \mathbf{a}\)</span>.</p>
<p><strong>Kronecker product</strong>. Consider two matrices, an <span class="math inline">\(n_a \times m_a\)</span> matrix, <span class="math inline">\(\mathbf{A}\)</span>, and an <span class="math inline">\(n_b \times m_b\)</span> matrix, <span class="math inline">\(\mathbf{B}\)</span>. The Kronecker product of <span class="math inline">\(\mathbf{A}\)</span> and <span class="math inline">\(\mathbf{B}\)</span> is given by the <span class="math inline">\(n_a n_b \times m_a m_b\)</span> matrix <span class="math inline">\(\mathbf{A}\otimes \mathbf{B}\)</span> defined as <span class="math display">\[
\mathbf{A}\otimes \mathbf{B}\equiv \left[\begin{array}{ccc}
a_{11} \mathbf{B}&amp; \cdots &amp; a_{1 m_a} \mathbf{B}\\
\vdots &amp; \vdots &amp; \vdots \\
a_{n_a 1} \mathbf{B}&amp; \cdots &amp; a_{n_a m_a} \mathbf{B}
\end{array}\right].
\]</span> If <span class="math inline">\(\mathbf{A}\)</span> is <span class="math inline">\(n_a \times n_a\)</span> and <span class="math inline">\(\mathbf{B}\)</span> is <span class="math inline">\(n_b \times n_b\)</span>, the inverse and determinant of the Kronecker product can be expressed in terms of the Kronecker product of the inverses and determinants of the individual matrices, respectively: <span class="math display">\[
(\mathbf{A}\otimes \mathbf{B})^{-1} = \mathbf{A}^{-1} \otimes \mathbf{B}^{-1},
\]</span> <span class="math display">\[
|\mathbf{A}\otimes \mathbf{B}| = |\mathbf{A}|^{n_b} \;  |\mathbf{B}|^{n_a}.
\]</span></p>
<p><strong>Euclidean norm</strong>. Consider the <span class="math inline">\(p\)</span>-dimensional real-valued vector <span class="math inline">\(\mathbf{a}= [a_1,a_2,\ldots,a_p]'\)</span>. The Euclidean norm is simply the Euclidean distance in <span class="math inline">\(p\)</span>-dimensional space, given by</p>
<p><span class="math display">\[
||\mathbf{a}|| \equiv  \sqrt{\mathbf{a}' \mathbf{a}} \equiv \sqrt{\sum_{k=1}^p a^2_{k}}.
\]</span></p>
<p><strong>Symmetric matrix</strong>. A matrix <span class="math inline">\(\mathbf{A}\)</span> is said to be <em>symmetric</em> if <span class="math inline">\(\mathbf{A}' = \mathbf{A}\)</span>.</p>
<p><strong>Diagonal matrix</strong>. Consider the <span class="math inline">\(p \times p\)</span> matrix <span class="math inline">\(\mathbf{A}\)</span>. The (main) diagonal elements of this matrix are given by the vector <span class="math inline">\([a_{11},a_{22},\ldots,a_{pp}]'\)</span>. Sometimes it is helpful to use a shorthand notation to construct a matrix with specific elements of a vector on the main diagonal and zeros for all other elements. For example,</p>
<p><span class="math display">\[
\textrm{diag}(b_1,b_2,\ldots,b_q) \equiv
\left[ \begin{array}{ccccc}
b_{1}  &amp; 0  &amp; 0 &amp; \cdots &amp; 0\\
  0 &amp; b_2 &amp; 0 &amp;\cdots &amp; 0 \\
  \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
   0 &amp; 0 &amp; 0 &amp;\cdots &amp;  b_q \\
\end{array}\right].
\]</span></p>
<p><strong>Trace of a matrix</strong>. Let <span class="math inline">\(\mathbf{A}\)</span> be a <span class="math inline">\(p \times p\)</span> square matrix. We then define the <em>trace</em> of this matrix, denoted <span class="math inline">\(\textrm{trace}(\mathbf{A})\)</span> (or <span class="math inline">\(\text{tr}(\mathbf{A})\)</span>) as the sum of the diagonal elements of <span class="math inline">\(\mathbf{A}\)</span>; that is,</p>
<p><span class="math display">\[
\textrm{trace}(\mathbf{A}) = \sum_{k=1}^p a_{kk}.
\]</span></p>
<p><strong>Non-negative-definite and positive-definite matrices</strong>. Consider a <span class="math inline">\(p \times p\)</span> symmetric and real-valued matrix, <span class="math inline">\(\mathbf{A}\)</span>. If, for any non-zero real-valued vector <span class="math inline">\(\mathbf{x}\)</span>, the scalar given by the <em>quadratic form</em> <span class="math inline">\(\mathbf{x}' \mathbf{A}\mathbf{x}\)</span> is non-negative, we say <span class="math inline">\(\mathbf{A}\)</span> is a <em>non-negative-definite</em> matrix. Similarly, if <span class="math inline">\(\mathbf{x}' \mathbf{A}\mathbf{x}\)</span> is strictly positive for any <span class="math inline">\(\mathbf{x}\neq {\mathbf{0}}\)</span>, we say that <span class="math inline">\(\mathbf{A}\)</span> is a <em>positive-definite</em> matrix.</p>
<p><strong>Matrix inverse</strong>. Consider the <span class="math inline">\(p \times p\)</span> square matrix, <span class="math inline">\(\mathbf{A}\)</span>. If it exists, the matrix <span class="math inline">\(\mathbf{B}\)</span> such that <span class="math inline">\(\mathbf{A}\mathbf{B}= \mathbf{B}\mathbf{A}= \mathbf{I}_p\)</span> is known as the <em>inverse matrix</em> of <span class="math inline">\(\mathbf{A}\)</span>, and it is denoted by <span class="math inline">\(\mathbf{A}^{-1}\)</span>. Thus, <span class="math inline">\(\mathbf{A}^{-1} \mathbf{A}= \mathbf{A}\mathbf{A}^{-1} = \mathbf{I}_p\)</span>. If the inverse exists, we say that the matrix is <em>invertible</em>. Not every square matrix has an inverse, but every positive-definite matrix is invertible (and, the inverse matrix is also positive-definite).</p>
<p><strong>Matrix square root</strong>. Let <span class="math inline">\(\mathbf{A}\)</span> be a <span class="math inline">\(p \times p\)</span> positive-definite matrix. Then there exists a matrix <span class="math inline">\(\mathbf{B}\)</span> such that <span class="math inline">\(\mathbf{A}= \mathbf{B}\mathbf{B}\equiv \mathbf{B}^2\)</span> and we say that <span class="math inline">\(\mathbf{B}\)</span> is the <em>matrix square root</em> of <span class="math inline">\(\mathbf{A}\)</span> and denote it by <span class="math inline">\(\mathbf{A}^{1/2}\)</span>. The matrix square root of a positive-definite matrix is also positive-definite and we can write the inverse matrix as <span class="math inline">\(\mathbf{A}^{-1} = \mathbf{A}^{-1/2} \mathbf{A}^{-1/2}\)</span>, where <span class="math inline">\(\mathbf{A}^{-1/2}\)</span> is the inverse of <span class="math inline">\(\mathbf{A}^{1/2}\)</span>.</p>
<p><strong>Spectral decomposition</strong>. Let <span class="math inline">\(\mathbf{A}\)</span> be a <span class="math inline">\(p \times p\)</span> symmetric matrix of real values. This matrix can be decomposed as <span class="math display">\[
\mathbf{A}= \sum_{k=1}^p \lambda_k \boldsymbol{\phi}_k \boldsymbol{\phi}_k' = \boldsymbol{\Phi}\boldsymbol{\Lambda}\boldsymbol{\Phi}',
\]</span> where <span class="math inline">\(\boldsymbol{\Lambda}= \textrm{diag}(\lambda_1,\ldots,\lambda_p)\)</span>, <span class="math inline">\(\boldsymbol{\Phi}= [\boldsymbol{\phi}_1,\ldots,\boldsymbol{\phi}_p]\)</span>, and <span class="math inline">\(\{\lambda_k\}\)</span> are called the <em>eigenvalues</em> that are associated with the <em>eigenvectors</em>, <span class="math inline">\(\{\boldsymbol{\phi}_k\}\)</span>, <span class="math inline">\(k=1,\ldots,p\)</span>, which are orthogonal (i.e., <span class="math inline">\(\boldsymbol{\Phi}\boldsymbol{\Phi}' = \boldsymbol{\Phi}' \boldsymbol{\Phi}= \mathbf{I}_p\)</span>). Note that for a symmetric non-negative-definite matrix <span class="math inline">\(\mathbf{A}\)</span>, <span class="math inline">\(\lambda_k \ge 0\)</span>, and for a symmetric positive-definite matrix <span class="math inline">\(\mathbf{A}\)</span>, <span class="math inline">\(\lambda_k &gt; 0\)</span>, for all <span class="math inline">\(k = 1,\ldots,p\)</span>. The matrix square root and its inverse can be written as <span class="math inline">\(\mathbf{A}^{1/2} = \boldsymbol{\Phi}\textrm{diag}(\lambda_1^{1/2},\ldots,\lambda_p^{1/2}) \boldsymbol{\Phi}'\)</span> and <span class="math inline">\(\mathbf{A}^{-1/2} = \boldsymbol{\Phi}\textrm{diag}(\lambda_1^{-1/2},\ldots,\lambda_p^{-1/2}) \boldsymbol{\Phi}'\)</span>, respectively.</p>
<p><strong>Singular value decomposition</strong> (SVD). Let <span class="math inline">\(\mathbf{A}\)</span> be a <span class="math inline">\(p \times n\)</span> matrix of real values. Then the matrix <span class="math inline">\(\mathbf{A}\)</span> can be decomposed as <span class="math inline">\(\mathbf{A}= \mathbf{U}\mathbf{D}\mathbf{V}'\)</span>, where <span class="math inline">\(\mathbf{U}\)</span> and <span class="math inline">\(\mathbf{V}\)</span> are <span class="math inline">\(p \times p\)</span> and <span class="math inline">\(n \times n\)</span> orthogonal matrices, respectively. In addition, the <span class="math inline">\(p \times n\)</span> matrix <span class="math inline">\(\mathbf{D}\)</span> contains all zeros except for the <span class="math inline">\((k,k)\)</span>th non-negative elements, <span class="math inline">\(\{d_k: \; k=1,2,\ldots,\min(p,n)\}\)</span>, which are known as <em>singular values</em>.</p>
</section>
<section id="sec-AppendSmooth" class="level2" data-number="8.2">
<h2 data-number="8.2" class="anchored" data-anchor-id="sec-AppendSmooth"><span class="header-section-number">8.2</span> General Smoothing Kernels</h2>
<p>Consider data <span class="math inline">\(\{Z_i: i=1,\ldots,m\}\)</span>, which we can write as a vector, <span class="math inline">\(\mathbf{Z}= (Z_1,\dots,Z_m)'\)</span>. Now, a homogeneously linear (smoothing) predictor for <span class="math inline">\(\mathbf{Z}\)</span> can always be written as <span class="math inline">\(\widehat{\mathbf{Z}} = \mathbf{H}\mathbf{Z}\)</span>, where the <span class="math inline">\(i\)</span>th row of the <span class="math inline">\(m \times m\)</span> matrix <span class="math inline">\(\mathbf{H}\)</span>, sometimes referred to as the influence matrix, corresponds to smoothing weights for the prediction, <span class="math inline">\(\widehat{Z_i}\)</span>; that is,</p>
<p><span class="math display">\[
\widehat{Z}_i = \sum_{j=1}^m h_{ij} Z_j,
\]</span></p>
<p>where <span class="math inline">\(h_{ij}\)</span> corresponds to the <span class="math inline">\((i,j)\)</span>th element of <span class="math inline">\(\mathbf{H}\)</span> and, by definition, the elements of <span class="math inline">\(\mathbf{H}\)</span> do <em>not</em> depend on <span class="math inline">\(\mathbf{Z}\)</span>. Note that both the kernel and regression predictors given in <a href="Chapter3.html#sec-determ_pred" class="quarto-xref"><span>Section 3.1</span></a> and <a href="Chapter3.html#sec-reg_pred" class="quarto-xref"><span>Section 3.2</span></a>, respectively, are linear predictors of this form. In the case of the kernel predictors, <span class="math inline">\(h_{ij}\)</span> corresponds to the kernel evaluated at location <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>. For the regression case, <span class="math inline">\(\mathbf{H}= \mathbf{X}(\mathbf{X}' \mathbf{X})^{-1} \mathbf{X}'\)</span> (sometimes called the “hat” matrix in books on regression). The difference is that, in general, under a kernel model, <span class="math inline">\(\mathbf{H}\)</span> gives more weight to locations that are near to each other, whereas standard regression matrices do not necessarily do so, although so-called local linear regression approaches do (see, for example, <span class="citation" data-cites="james2013introduction">James et al. (<a href="references.html#ref-james2013introduction" role="doc-biblioref">2013</a>)</span>).</p>
<p>There are several useful properties of the general linear smoothing matrix, <span class="math inline">\(\mathbf{H}\)</span>, used in the linear predictor. First, as we have noted, if one has <span class="math inline">\(m\)</span> observations but they are statistically dependent, then there are effectively fewer than <span class="math inline">\(m\)</span> degrees of freedom (e.g., some of the information is redundant due to the dependence). Specifically, the <em>effective degrees of freedom</em> in the sample of <span class="math inline">\(m\)</span> observations are given by the trace of the matrix <span class="math inline">\(\mathbf{H}\)</span>,</p>
<p><span class="math display">\[
df_{\mathrm{eff}} = \textrm{tr}(\mathbf{H}) = \sum_{i=1}^m h_{ii}.
\]</span></p>
<p>Another important property of linear predictors of this form is that we can obtain the LOOCV estimate (see <a href="Chapter3.html#nte-technote-CV" class="quarto-xref">Note&nbsp;<span>3.1</span></a>) without actually having to refit the model. That is, in the case of evaluating the MSPE, the LOOCV statistic is given by</p>
<p><span id="eq-CVnHat"><span class="math display">\[
CV_{(m)} = \frac{1}{m} \sum_{i=1}^m (Z_i - \widehat{Z}_i^{(-i)})^2 = \frac{1}{m} \sum_{i=1}^m \left(\frac{Z_i - \widehat{Z}_i}{1 - h_{ii}}  \right)^2,
\tag{8.1}\]</span></span></p>
<p>and the so-called <em>generalized cross-validation</em> statistic is given by replacing the denominator in the right-hand side of <a href="#eq-CVnHat" class="quarto-xref">Equation&nbsp;<span>8.1</span></a> by <span class="math inline">\((1 - \textrm{tr}(\mathbf{H})/m)\)</span>.</p>
<p>In cases where <em>regularization</em> is considered in the context of the linear predictor (e.g., when we wish to shrink the parameters toward zero by using, for example, a <em>ridge regression</em> (<span class="math inline">\(L_2\)</span>-norm) penalty; see <a href="Chapter3.html#nte-technote-RidgeLassoReg" class="quarto-xref">Note&nbsp;<span>3.4</span></a>), we can write <span class="math inline">\(\mathbf{H}= \mathbf{X}(\mathbf{X}' \mathbf{X}+ \mathbf{R})^{-1} \mathbf{X}'\)</span> (with <span class="math inline">\(\mathbf{R}= \lambda \mathbf{I}\)</span> in the ridge-regression case), and the effective degrees of freedom and LOOCV properties are still valid <span class="citation" data-cites="james2013introduction">(see <a href="references.html#ref-james2013introduction" role="doc-biblioref">James et al. 2013</a>)</span>. As discussed in <a href="Chapter3.html#nte-technote-RidgeLassoReg" class="quarto-xref">Note&nbsp;<span>3.4</span></a>, a lasso (<span class="math inline">\(L_1\)</span>-norm) penalty can also be used for regularization, but the smoothing kernel has no closed form in this case.</p>
</section>
<section id="sec-Appendix5a" class="level2" data-number="8.3">
<h2 data-number="8.3" class="anchored" data-anchor-id="sec-Appendix5a"><span class="header-section-number">8.3</span> Estimation and Prediction for Dynamic Spatio-Temporal Models</h2>
<p>Estimation and prediction for linear dynamic spatio-temporal models (DSTMs) with Gaussian errors can sometimes be done using methods developed for state-space models (when there are many more temporal observations than spatial locations). In particular, after conditioning on parameter estimates, the hidden (state) process can be predicted using a Kalman filter or smoother, and the parameters might be estimated using an expectation-maximization (EM) algorithm or a Markov chain Monte Carlo (MCMC) algorithm. This appendix illustrates, first, a method-of-moments estimation approach that is common in vector autoregression modeling in time series, and second, a detailed description of parameter estimation and prediction of the process in linear DSTMs with Gaussian errors using the Kalman filter, Kalman smoother, and the EM algorithm.</p>
<section id="sec-estimationMoM" class="level3" data-number="8.3.1">
<h3 data-number="8.3.1" class="anchored" data-anchor-id="sec-estimationMoM"><span class="header-section-number">8.3.1</span> Estimation in Vector Autoregressive Spatio-Temporal Models via the Method of Moments</h3>
<p>In traditional vector autoregressive (VAR) time-series applications, the autoregressive process is assumed to correspond directly to the data-generating process (i.e., there is no separate data model and process model). In the spatio-temporal context this implies a model such as</p>
<p><span id="eq-linearVAR"><span class="math display">\[
\mathbf{Z}_t = \mathbf{M}\mathbf{Z}_{t-1} + \boldsymbol{\eta}_t,\quad \boldsymbol{\eta}_t \sim \; Gau(\mathbf{0},\mathbf{C}_{\eta}),
\tag{8.2}\]</span></span></p>
<p>for <span class="math inline">\(t=1,\ldots,T\)</span>, where we assume that <span class="math inline">\(\mathbf{Z}_0\)</span> is known and recall that <span class="math inline">\(\mathbf{Z}_t = (Z_t(\mathbf{s}_1),\ldots,Z_t(\mathbf{s}_m))'\)</span>. Estimation of the matrices <span class="math inline">\(\mathbf{M}\)</span> and <span class="math inline">\(\mathbf{C}_{\eta}\)</span> can be obtained via maximum likelihood, least squares, or the method of moments . We illustrate the latter here.</p>
<p>For simplicity, we assume <span class="math inline">\(\{\mathbf{Z}_t\}\)</span> has mean zero and is second-order stationary in time. If we post-multiply both sides of <a href="#eq-linearVAR" class="quarto-xref">Equation&nbsp;<span>8.2</span></a> by <span class="math inline">\(\mathbf{Z}'_{t-1}\)</span> and take the expectation, we get,</p>
<p><span class="math display">\[
E(\mathbf{Z}_t \mathbf{Z}'_{t-1}) =  \mathbf{M}E(\mathbf{Z}_{t-1} \mathbf{Z}'_{t-1}),
\]</span></p>
<p>which we write as</p>
<p><span id="eq-CovVAR"><span class="math display">\[
\mathbf{C}_z^{(1)}  =  \mathbf{M}\mathbf{C}_z^{(0)}.
\tag{8.3}\]</span></span></p>
<p>Recall from Chapter 2 that <span class="math inline">\(\mathbf{C}_z^{(\tau)}\)</span> is the lag-<span class="math inline">\(\tau\)</span> spatial covariance matrix for <span class="math inline">\(\{\mathbf{Z}_t\}\)</span>. Now, <a href="#eq-CovVAR" class="quarto-xref">Equation&nbsp;<span>8.3</span></a> implies that</p>
<p><span id="eq-MfromMoM"><span class="math display">\[
\mathbf{M}= \mathbf{C}_z^{(1)} (\mathbf{C}_z^{(0)})^{-1}.
\tag{8.4}\]</span></span></p>
<p>Similarly, if we post-multiply <a href="#eq-linearVAR" class="quarto-xref">Equation&nbsp;<span>8.2</span></a> by <span class="math inline">\(\mathbf{Z}'_t\)</span> and take expectations, we can show that</p>
<p><span id="eq-CetafromMoM"><span class="math display">\[
\mathbf{C}_{\eta} = \mathbf{C}_z^{(0)} - \mathbf{M}\mathbf{C}_z^{(1)'} = \mathbf{C}_z^{(0)} - \mathbf{C}_z^{(1)} (\mathbf{C}_z^{(0)})^{-1} \mathbf{C}_z^{(1)'}.
\tag{8.5}\]</span></span></p>
<p>It follows that the method-of-moments estimators (where empirical moments are equated with theoretical moments) of <a href="#eq-MfromMoM" class="quarto-xref">Equation&nbsp;<span>8.4</span></a> and <a href="#eq-CetafromMoM" class="quarto-xref">Equation&nbsp;<span>8.5</span></a> are given by</p>
<p><span id="eq-MestMoM"><span class="math display">\[
\widehat{\mathbf{M}} =  \widehat{\mathbf{C}}_z^{(1)} (\widehat{\mathbf{C}}_z^{(0)})^{-1},
\tag{8.6}\]</span></span></p>
<p><span id="eq-CetaestMoM"><span class="math display">\[
\widehat{\mathbf{C}}_\eta =  \widehat{\mathbf{C}}_z^{(0)} - \widehat{\mathbf{C}}_z^{(1)} (\widehat{\mathbf{C}}_z^{(0)})^{-1} \widehat{\mathbf{C}}_z^{(1)'}.
\tag{8.7}\]</span></span></p>
<p>In <a href="#eq-CetaestMoM" class="quarto-xref">Equation&nbsp;<span>8.7</span></a>, the empirical lag-<span class="math inline">\(\tau\)</span> covariance matrices, <span class="math inline">\(\widehat{\mathbf{C}}_z^{(\tau)}\)</span>, are calculated as shown in <a href="Chapter2.html#eq-emp_cov" class="quarto-xref">Equation&nbsp;<span>2.4</span></a>. Note that <span class="math inline">\(T\)</span> needs to be larger than the dimension of <span class="math inline">\(\mathbf{Z}_t\)</span> to ensure that <span class="math inline">\(\widehat{\mathbf{C}}_z^{(0)}\)</span> is invertible.</p>
<p>As we have said throughout this book, we prefer to consider DSTMs that have a separate data and process model. Estimation for these models is described below in <a href="#sec-estimationLDSTM" class="quarto-xref"><span>Section 8.3.2</span></a>. So, what is the benefit of the method-of-moments approach in the context of DSTMs? In cases where the signal-to-noise ratio is high, the estimates given by <a href="#eq-MestMoM" class="quarto-xref">Equation&nbsp;<span>8.6</span></a> and <a href="#eq-CetaestMoM" class="quarto-xref">Equation&nbsp;<span>8.7</span></a> can provide reasonable estimates for exploratory data analysis. We illustrate an example using method-of-moments estimation in Lab 5.3. Specifically, assume that we project the spatial-mean-centered data onto orthogonal basis functions, <span class="math inline">\(\boldsymbol{\Phi}\)</span>: <span class="math inline">\(\boldsymbol{\alpha}_t = \boldsymbol{\Phi}' (\mathbf{Z}_t - \widehat{\boldsymbol{\mu}})\)</span>. We then assume that the projected data come from the model, <span class="math inline">\(\boldsymbol{\alpha}_t = \mathbf{M}\boldsymbol{\alpha}_{t-\tau} + \boldsymbol{\eta}_t\)</span>, and we obtain estimates <span class="math inline">\(\widehat{\mathbf{M}}\)</span> and <span class="math inline">\(\widehat{\mathbf{C}}_\eta\)</span> based on the projected data. One can then produce forecasts such as <span class="math inline">\(\widehat{\boldsymbol{\alpha}}_{T+\tau} = \widehat{\mathbf{M}} \widehat{\boldsymbol{\alpha}}_T\)</span>, with estimated forecast covariance matrix, <span class="math inline">\(\widehat{\mathbf{C}}_{\alpha} = \widehat{\mathbf{M}} \widehat{\mathbf{C}}_\alpha^{(0)} \widehat{\mathbf{M}}' + \widehat{\mathbf{C}}_\eta\)</span>, where <span class="math inline">\(\widehat{\mathbf{C}}_\alpha^{(0)}\)</span> is the empirical estimate of <span class="math inline">\(E(\boldsymbol{\alpha}_t \boldsymbol{\alpha}_t')\)</span>. To obtain a forecast for <span class="math inline">\(\widehat{\mathbf{Z}}_{T+\tau}\)</span>, one would have to multiply the forecast <span class="math inline">\(\widehat{\boldsymbol{\alpha}}_{T+\tau}\)</span> by the basis-function matrix and add back the spatial mean: <span class="math inline">\(\widehat{\mathbf{Z}}_{T+\tau} = \widehat{\boldsymbol{\mu}} + \boldsymbol{\Phi}\widehat{\boldsymbol{\alpha}}_{T+\tau}\)</span>. The forecast covariance matrix is then approximated by <span class="math inline">\(\widehat{\mathbf{C}}_{Z} = \boldsymbol{\Phi}\widehat{\mathbf{C}}_{\alpha} \boldsymbol{\Phi}'\)</span>, where we have ignored the truncation and measurement error when projecting onto the basis functions. Although this procedure is somewhat <em>ad hoc</em>, it is simple and can give a quick forecast. More importantly, the parameter estimates in this procedure would be used as starting values in the state-space EM algorithm described in <a href="#sec-estimationLDSTM" class="quarto-xref"><span>Section 8.3.2</span></a>. This is demonstrated in the second portion of Lab 5.3.</p>
<p>For completeness, note that when one makes the assumption that the initial spatial data vector <span class="math inline">\(\mathbf{Z}_0\)</span> is known, it can be shown that, conditional on <span class="math inline">\(\mathbf{Z}_0\)</span>, maximum likelihood, least squares, and method-of-moments estimation all give equivalent estimates, <span class="math inline">\(\widehat{\mathbf{M}}\)</span> and <span class="math inline">\(\widehat{\mathbf{C}}_\eta\)</span> <span class="citation" data-cites="harvey1993time">(see, for example, <a href="references.html#ref-harvey1993time" role="doc-biblioref">Harvey 1993, sec. 7.4</a>)</span>.</p>
</section>
<section id="sec-estimationLDSTM" class="level3" data-number="8.3.2">
<h3 data-number="8.3.2" class="anchored" data-anchor-id="sec-estimationLDSTM"><span class="header-section-number">8.3.2</span> Prediction and Estimation in Fully Parameterized Linear DSTMs</h3>
<p>Traditionally, from the data model,</p>
<p><span id="eq-ZlinearGaunobias"><span class="math display">\[
\mathbf{Z}_t =  \mathbf{H}_t \mathbf{Y}_t + \boldsymbol{\varepsilon}_t,\quad \boldsymbol{\varepsilon}_t \sim \; Gau(\mathbf{0},\mathbf{C}_{\epsilon,t}),
\tag{8.8}\]</span></span></p>
<p>and from the process model,</p>
<p><span id="eq-linearDSTMVARb"><span class="math display">\[
\mathbf{Y}_t = \mathbf{M}\mathbf{Y}_{t-1} + \boldsymbol{\eta}_t,\quad \boldsymbol{\eta}_t \sim \; Gau(\mathbf{0},\mathbf{C}_{\eta}),
\tag{8.9}\]</span></span></p>
<p>we obtain a hierarchical model (HM). Note that we have assumed here that there is no additive offset in the data model and that the process has mean zero to simplify the exposition. Next, we can perform prediction on the hidden process via the Kalman filter and Kalman smoother if the parameter matrices are all known. In practice, these are not known, and estimates are sometimes used in their place, which is an empirical hierarchical model (EHM) approach. Note that although in general <span class="math inline">\(\mathbf{M}\)</span> could depend on time (and hence would be written as <span class="math inline">\(\mathbf{M}_t\)</span>), we consider the simpler time-invariant case here.</p>
<section id="sequential-prediction-of-the-process-via-kalman-filtering-and-smoothing" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="sequential-prediction-of-the-process-via-kalman-filtering-and-smoothing">Sequential Prediction of the Process via Kalman Filtering and Smoothing</h4>
<p>In Chapter 1 we discussed the notions of smoothing, filtering, and forecasting. Before we show the filtering and smoothing distributions and algorithms, we need to define some notation and terms. In particular, let <span class="math inline">\(\mathbf{w}_{c:d} \equiv \{\mathbf{w}_c,\ldots,\mathbf{w}_d\}\)</span>, for the generic vector <span class="math inline">\(\mathbf{w}_t\)</span> at times <span class="math inline">\(t \in \{c, c+1,\ldots,d-1,d\}\)</span>. Then we define the <em>forecasting distribution</em> to be the distribution of <span class="math inline">\(\mathbf{Y}_t\)</span> given all of the observations that occur before time <span class="math inline">\(t\)</span>, namely, <span class="math inline">\([\mathbf{Y}_t | \mathbf{Z}_{1:t-1}]\)</span>. We also define the <em>filtering distribution</em> to be the distribution of <span class="math inline">\(\mathbf{Y}_t\)</span> given all of the observations up to and including time <span class="math inline">\(t\)</span>, namely, <span class="math inline">\([\mathbf{Y}_t | \mathbf{Z}_{1:t}]\)</span>. Finally, we define the <em>smoothing distribution</em> to be the distribution of <span class="math inline">\(\mathbf{Y}_t\)</span> given all the observations before, including, and after time <span class="math inline">\(t\)</span>, namely, <span class="math inline">\([\mathbf{Y}_t | \mathbf{Z}_{1:T}]\)</span>, for <span class="math inline">\(1 \leq t \leq T\)</span>.</p>
<p>The forecasting distribution is of most interest when one would like to predict the process one time step into the future; the filtering distribution is typically most useful when one seeks to “filter out” observation error from the true process as data come along sequentially (e.g., in real time); and the smoothing distribution is most useful when one retrospectively wants to smooth out the observation errors for any time in the entire observation period. Now, consider the following notation for the conditional expectations of the forecast and filtering distributions, respectively: <span class="math inline">\(\mathbf{Y}_{t | t-1} \equiv E[\mathbf{Y}_t | \mathbf{Z}_{1:t-1}]\)</span> and <span class="math inline">\(\mathbf{Y}_{t:t} \equiv E[\mathbf{Y}_t | \mathbf{Z}_{1:t}]\)</span>. Similarly, define the conditional covariance matrices for the forecast error and filtering error distributions, respectively, as: <span class="math inline">\(\mathbf{P}_{t|t-1} \equiv E[(\mathbf{Y}_t - \mathbf{Y}_{t|t-1})(\mathbf{Y}_t - \mathbf{Y}_{t|t-1})' | \mathbf{Z}_{1:t-1}]\)</span> and <span class="math inline">\(\mathbf{P}_{t|t} \equiv E[(\mathbf{Y}_t - \mathbf{Y}_{t|t})(\mathbf{Y}_t - \mathbf{Y}_{t|t})' | \mathbf{Z}_{1:t}]\)</span>.</p>
<p>In the case of linear Gaussian data models and process models given by <a href="#eq-ZlinearGaunobias" class="quarto-xref">Equation&nbsp;<span>8.8</span></a> and <a href="#eq-linearDSTMVARb" class="quarto-xref">Equation&nbsp;<span>8.9</span></a>, the forecast and filtering distributions can be found analytically by using standard conditional expectation/variance relationships and Bayes’ Rule, respectively. In particular, the forecast and filtering distributions are denoted, respectively, by</p>
<p><span class="math display">\[
\mathbf{Y}_t | \mathbf{Z}_{1:t-1} \sim \; Gau(\mathbf{Y}_{t | t-1},\mathbf{P}_{t | t-1}),
\]</span></p>
<p>and</p>
<p><span class="math display">\[
\mathbf{Y}_t | \mathbf{Z}_{1:t} \sim \; Gau(\mathbf{Y}_{t | t},\mathbf{P}_{t | t}),
\]</span></p>
<p>and they can be found through the famous <em>Kalman filter algorithm</em> given in <a href="#nte-algorithm-KalmanFilter" class="quarto-xref">Note&nbsp;<span>8.1</span></a>. Thus, given the initial conditions <span class="math inline">\(\mathbf{Y}_{0 | 0} \equiv \boldsymbol{\mu}_0\)</span> and <span class="math inline">\(\mathbf{P}_{0 | 0} \equiv \mathbf{C}_0\)</span> and the parameter matrices, <span class="math inline">\(\{\mathbf{H}_t\}_{t=1}^T\)</span>, <span class="math inline">\(\{\mathbf{C}_{\epsilon,t}\}_{t=1}^T\)</span>, <span class="math inline">\(\mathbf{M}\)</span>, and <span class="math inline">\(\mathbf{C}_{\eta}\)</span>, one can iterate sequentially between the forecast and filtering steps to obtain these distributions for all times <span class="math inline">\(t=1,\ldots,T\)</span>.</p>
<div id="nte-algorithm-KalmanFilter" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;8.1: Kalman Filter
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Set initial conditions: <span class="math inline">\(\mathbf{Y}_{0 | 0} = \boldsymbol{\mu}_0\)</span> and <span class="math inline">\(\mathbf{P}_{0 | 0} = \mathbf{C}_0\)</span></li>
<li><strong>for</strong> <span class="math inline">\(t = 1\)</span> to <span class="math inline">\(T\)</span> <strong>do</strong>
<ol type="1">
<li>Forecast distribution step:
<ol type="a">
<li>Obtain <span class="math inline">\(\mathbf{Y}_{t | t-1} =  \mathbf{M}\mathbf{Y}_{t-1 | t-1}\)</span></li>
<li>Obtain <span class="math inline">\(\mathbf{P}_{t | t-1} = \mathbf{C}_{\eta} + \mathbf{M}\mathbf{P}_{t-1 | t-1} \mathbf{M}'\)</span></li>
</ol></li>
<li>Filtering distribution step:
<ol type="a">
<li>Obtain the Kalman gain, <span class="math inline">\(\mathbf{K}_t \equiv \mathbf{P}_{t | t-1} \mathbf{H}'_t (\mathbf{H}_t \mathbf{P}_{t | t-1} \mathbf{H}'_t + \mathbf{C}_{\epsilon,t})^{-1}\)</span></li>
<li>Obtain <span class="math inline">\(\mathbf{Y}_{t|t} = \mathbf{Y}_{t | t-1} + \mathbf{K}_t (\mathbf{Z}_t - \mathbf{H}_t \mathbf{Y}_{t | t-1})\)</span></li>
<li>Obtain <span class="math inline">\(\mathbf{P}_{t | t} = (\mathbf{I}- \mathbf{K}_t \mathbf{H}_t)\mathbf{P}_{t | t-1}\)</span></li>
</ol></li>
</ol>
<strong>end for</strong></li>
</ul>
</div>
</div>
<p>Recall that the smoothing distribution considers the distribution of the process at time <span class="math inline">\(t\)</span> given <em>all</em> of the observations regardless of whether they come before, during, or after time <span class="math inline">\(t\)</span>. This smoothing distribution is denoted by</p>
<p><span class="math display">\[
\mathbf{Y}_t | \mathbf{Z}_{1:T} \sim \; Gau(\mathbf{Y}_{t | T}, \mathbf{P}_{t | T})
\]</span></p>
<p>and, if one saves the results from the Kalman filter, this can be obtained for all <span class="math inline">\(t\)</span> by the <em>Kalman smoother algorithm</em> (also known as the Rauch–Tung–Striebel smoother) given in <a href="#nte-algorithm-KalmanSmoother" class="quarto-xref">Note&nbsp;<span>8.2</span></a>.</p>
<div id="nte-algorithm-KalmanSmoother" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;8.2: Kalman Smoother
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Obtain <span class="math inline">\(\{\mathbf{Y}_{t|t-1}, \mathbf{P}_{t|t-1}\}_{t=1}^T\)</span> and <span class="math inline">\(\{\mathbf{Y}_{t|t}, \mathbf{P}_{t|t}\}_{t=0}^T\)</span> from the Kalman filter algorithm (<a href="#nte-algorithm-KalmanFilter" class="quarto-xref">Note&nbsp;<span>8.1</span></a>).</li>
<li><strong>for</strong> <span class="math inline">\(t = T-1\)</span> down to <span class="math inline">\(0\)</span> <strong>do</strong>
<ol type="1">
<li>Obtain <span class="math inline">\(\mathbf{J}_t \equiv \mathbf{P}_{t|t} \; \mathbf{M}' \; \mathbf{P}_{t+1|t}^{-1}\)</span>.</li>
<li>Obtain <span class="math inline">\(\mathbf{Y}_{t|T} = \mathbf{Y}_{t|t} + \mathbf{J}_t (\mathbf{Y}_{t+1|T} - \mathbf{Y}_{t+1|t})\)</span>.</li>
<li>Obtain <span class="math inline">\(\mathbf{P}_{t|T} = \mathbf{P}_{t|t} + \mathbf{J}_t (\mathbf{P}_{t+1|T} - \mathbf{P}_{t+1 | t})\mathbf{J}'_t\)</span>.</li>
</ol>
<strong>end for</strong></li>
</ul>
</div>
</div>
</section>
<section id="parameter-estimation-via-the-em-algorithm" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="parameter-estimation-via-the-em-algorithm">Parameter Estimation via the EM Algorithm</h4>
<p>The state-space approach discussed above in terms of the Kalman filter and smoother makes the assumption that the parameter matrices in the data and process models are known. This is unrealistic in most cases, and one must use the data to estimate these parameters; that is, the HM being used is an EHM. One of the most popular (and effective) ways to do this in the state-space time-series case is through the EM algorithm (recall the general EM algorithm presented in <a href="Chapter4.html#nte-algorithm-EMbasic" class="quarto-xref">Note&nbsp;<span>4.4</span></a>).</p>
<p>The state-space version of the EM algorithm, originally developed by <span class="citation" data-cites="shumway1982approach">Shumway and Stoffer (<a href="references.html#ref-shumway1982approach" role="doc-biblioref">1982</a>)</span>, denotes by <span class="math inline">\(\mathbf{Z}_{1:T}\)</span> the observations and the unobservable latent process, and by <span class="math inline">\(\mathbf{Y}_{0:T}\)</span> the “missing data.” Denote the parameters by <span class="math inline">\(\boldsymbol{\Theta}\equiv \{\boldsymbol{\mu}_0, \mathbf{C}_0, \mathbf{C}_\eta, \mathbf{C}_{\epsilon},\mathbf{M}\}\)</span>, where we assume typically that the observation matrices, <span class="math inline">\(\{\mathbf{H}_t\}\)</span>, are all known. We assume that the initial distribution is given by <span class="math inline">\(\mathbf{Y}_{0|0} \sim \; Gau(\boldsymbol{\mu}_0, \mathbf{C}_0)\)</span>, and we further assume here (for simplicity) that <span class="math inline">\(\mathbf{C}_{\epsilon}\)</span> corresponds to the <span class="math inline">\(m \times m\)</span> measurement-error covariance matrix for all possible observation locations (thus, <span class="math inline">\(\mathbf{C}_{\epsilon,t} = \mathbf{C}_{\epsilon}\)</span>, for all <span class="math inline">\(t\)</span>, so <span class="math inline">\(m_t = m\)</span> and we assume no missing observations at each time point). The EM algorithm is then based on the complete-data likelihood given by <span class="math inline">\([\mathbf{Z}_{1:T}, \mathbf{Y}_{0:T} | \boldsymbol{\Theta}] = \left(\prod_{t=1}^T [\mathbf{Z}_t | \mathbf{Y}_t]\right) \left(\prod_{t=1}^T [\mathbf{Y}_t | \mathbf{Y}_{t-1}]\right) [\mathbf{Y}_0]\)</span>, which again makes use of the conditional independencies in the data model and the Markov property of the process model. The EM algorithm for a linear DSTM, presented in <a href="#nte-algorithm-DSTMEM" class="quarto-xref">Note&nbsp;<span>8.3</span></a>, makes use of the Kalman smoother algorithm to evaluate both the E-step and the M-step. Note that, in addition to running the Kalman smoother at each iteration of the algorithm, we also have to obtain the so-called “lagged-one smoother” variance-covariance matrix, <span class="math inline">\(\mathbf{P}_{t,t-1|T} \equiv E((\mathbf{Y}_t - \mathbf{Y}_{t|T})(\mathbf{Y}_{t-1} - \mathbf{Y}_{t-1|T})' | \mathbf{Z}_{1:T})\)</span>, for <span class="math inline">\(t=T,T-1,\ldots.\)</span> This is accomplished by the so-called <em>lag-one covariance smoother</em>, which is part of the algorithm in <a href="#nte-algorithm-DSTMEM" class="quarto-xref">Note&nbsp;<span>8.3</span></a>. Convergence can be assessed by considering parameter changes and/or changes to the log complete-data likelihood (i.e., see <a href="#eq-EMlogL" class="quarto-xref">Equation&nbsp;<span>8.10</span></a> in <a href="#nte-algorithm-DSTMEM" class="quarto-xref">Note&nbsp;<span>8.3</span></a>). Typically, in the linear DSTM case, one considers the latter because there are a large number of parameters. An example of using the EM algorithm for a linear DSTM is given in Lab 5.3.</p>
<div id="nte-algorithm-DSTMEM" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;8.3: Linear DSTM EM Algorithm
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Choose initial condition covariance matrix, <span class="math inline">\(\mathbf{C}_0\)</span></li>
<li>Choose starting values: <span class="math inline">\(\widehat{\boldsymbol{\Theta}}^{(0)} =\{\widehat{\boldsymbol{\mu}}_0^{(0)}, \widehat{\mathbf{C}}_{\eta}^{(0)}, \widehat{\mathbf{C}}_{\epsilon}^{(0)}, \widehat{\mathbf{M}}^{(0)} \}\)</span></li>
<li><strong>repeat</strong> <span class="math inline">\(i=1,2,\ldots\)</span></li>
</ul>
<ol type="1">
<li>E-step:
<ul>
<li><p>Use <span class="math inline">\(\widehat{\boldsymbol{\Theta}}^{(i-1)}\)</span> in the Kalman smoother (<a href="#nte-algorithm-KalmanSmoother" class="quarto-xref">Note&nbsp;<span>8.2</span></a>) to obtain <span class="math inline">\(\{\mathbf{Y}_{t|T}^{(i-1)}, \mathbf{P}_{t|T}^{(i-1)}\}\)</span></p></li>
<li><p>Use Kalman smoother output to obtain the lag-one covariance smoother estimates</p></li>
<li><p>Calculate <span class="math inline">\(\mathbf{P}^{(i-1)}_{T,T-1|T} = (\mathbf{I}- \mathbf{K}^{(i-1)}_T \mathbf{H}_T)\mathbf{M}^{(i-1)} \mathbf{P}^{(i-1)}_{T-1|T-1}\)</span></p></li>
<li><p><strong>for</strong> <span class="math inline">\(t=T,T-1,\ldots,2\)</span> <strong>do</strong> <span class="math display">\[
\mathbf{P}^{(i-1)}_{t-1,t-2|T}  =  \mathbf{P}^{(i-1)}_{t-1|t-1} \mathbf{J}^{(i-1)'}_{t-2} + \mathbf{J}^{(i-1)'}_{t-1}(\mathbf{P}^{(i-1)}_{t,t-1|T} - \mathbf{M}^{(i-1)} \mathbf{P}^{(i-1)}_{t-1|t-1})\mathbf{J}^{(i-1)'}_{t-2}
\]</span></p>
<p><strong>end for</strong></p></li>
<li><p>Calculate <span class="math inline">\(\mathbf{S}_{00} \equiv \sum_{t=1}^T (\mathbf{P}^{(i-1)}_{t-1 | T} + \mathbf{Y}^{(i-1)}_{t-1|T} \mathbf{Y}^{(i-1)'}_{t-1|T})\)</span></p></li>
<li><p>Calculate <span class="math inline">\(\mathbf{S}_{11} \equiv \sum_{t=1}^T (\mathbf{P}^{(i-1)}_{t | T} + \mathbf{Y}^{(i-1)}_{t|T} \mathbf{Y}^{(i-1)'}_{t|T})\)</span></p></li>
<li><p>Calculate <span class="math inline">\(\mathbf{S}_{10} \equiv \sum_{t=1}^T (\mathbf{P}^{(i-1)}_{t,t-1 | T} + \mathbf{Y}^{(i-1)}_{t|T} \mathbf{Y}^{(i-1)'}_{t-1|T})\)</span></p></li>
</ul></li>
<li>M-step:
<ul>
<li>Update: <span class="math inline">\(\widehat{\boldsymbol{\mu}}_0^{(i)} = \mathbf{Y}^{(i-1)}_{0|T}\)</span></li>
<li>Update: <span class="math inline">\(\widehat{\mathbf{M}}^{(i)} = \mathbf{S}_{10}\mathbf{S}_{00}^{-1}\)</span></li>
<li>Update: <span class="math inline">\(\widehat{\mathbf{C}}_{\eta}^{(i)} = (1/T)(\mathbf{S}_{11} - \mathbf{S}_{10}\mathbf{S}_{00}^{-1} \mathbf{S}_{10}')\)</span></li>
<li>Update: <span class="math display">\[
\widehat{\mathbf{C}}_{\epsilon}^{(i)}  =  \frac1T \sum_{t=1}^T ((\mathbf{Z}_t - \mathbf{H}_t \mathbf{Y}^{(i-1)}_{t|T})(\mathbf{Z}_t - \mathbf{H}_t \mathbf{Y}^{(i-1)}_{t|T})' + \mathbf{H}_t \mathbf{P}^{(i-1)}_{t|T} \mathbf{H}'_t)
\]</span></li>
</ul>
<strong>until</strong> convergence (typically, based on differences in <span class="math inline">\(-2\ln(L(\boldsymbol{\Theta}| \mathbf{Z}_{1:T},\mathbf{Y}_{0:T}))\)</span> as calculated in <a href="#eq-EMlogL" class="quarto-xref">Equation&nbsp;<span>8.10</span></a>:</li>
</ol>
<p><span id="eq-EMlogL"><span class="math display">\[
\small
\begin{aligned}
-2 \ln(L(\boldsymbol{\Theta}^{(i)} | \mathbf{Z}_{1:T},\mathbf{Y}^{(i)}_{0:T}))  =  \ln(|\widehat{\mathbf{C}}^{(i)}_0|) + (\mathbf{Y}^{(i)}_{0|T} - \widehat{\boldsymbol{\mu}}^{(i)}_0)'\widehat{\mathbf{C}}_0^{-1{(i)}}(\mathbf{Y}^{(i)}_{0|T} - \widehat{\boldsymbol{\mu}}^{(i)}_0) \\
+  T \ln(|\widehat{\mathbf{C}}^{(i)}_{\eta}|) + \sum_{t=1}^T (\mathbf{Y}^{(i)}_{t|T} - \widehat{\mathbf{M}}^{(i)} \mathbf{Y}^{(i)}_{t-1|T})'\widehat{\mathbf{C}}_{\eta}^{-1{(i)}}(\mathbf{Y}^{(i)}_{t|T} - \widehat{\mathbf{M}}^{(i)} \mathbf{Y}^{(i)}_{t-1|T}) \\
  +   T \ln(|\widehat{\mathbf{C}}^{(i)}_{\epsilon}|) + \sum_{t=1}^T (\mathbf{Z}_t - \mathbf{H}_t \mathbf{Y}^{(i)}_{t|T})'\widehat{\mathbf{C}}_{\epsilon}^{-1{(i)}}(\mathbf{Z}_t - \mathbf{H}_t \mathbf{Y}^{(i)}_{t|T}).
\end{aligned}
\tag{8.10}\]</span></span></p>
</div>
</div>
<p>Uncertainty estimates are less easily obtained for the parameter estimates than they are for the state-process estimates, but they can be obtained through considering the inverse of the associated asymptotic information matrix or by parametric bootstrap methods. Unfortunately, obtaining uncertainty estimates even for the state-process estimates is not often done in practice and, as discussed in the comments motivating DSTMs in <a href="Chapter5.html#sec-LinGaussProcess" class="quarto-xref"><span>Section 5.2.3</span></a>, it can be problematic because of the potential for explosive behavior by some of the transition matrices whose parameters are within the joint confidence region.</p>
<p>More flexible inference for DSTMs can be accomplished by the fully hierarchical Bayesian hierarchical model (BHM); see <a href="Chapter4.html#sec-BHMest" class="quarto-xref"><span>Section 4.5.2</span></a> as well as <span class="citation" data-cites="cressie2011statistics">(<a href="references.html#ref-cressie2011statistics" role="doc-biblioref">Cressie and Wikle 2011, chap. 8</a>)</span>. These BHM implementations are often problem-specific, and they are often best implemented directly in <code>R</code> or in a so-called probabilistic programming language (e.g., Stan, WinBugs, JAGS). For an example, see the Gibbs sampler MCMC algorithm (corresponding to a BHM) to predict Mediterranean surface winds implemented in <a href="#sec-PDEdecomp_MedWinds" class="quarto-xref"><span>Section 8.5</span></a>.</p>
</section>
</section>
<section id="sec-Est_and_pred" class="level3" data-number="8.3.3">
<h3 data-number="8.3.3" class="anchored" data-anchor-id="sec-Est_and_pred"><span class="header-section-number">8.3.3</span> Estimation for Non-Gaussian and Nonlinear DSTMs</h3>
<p>In principle, the filtering and smoothing methods presented in <a href="#sec-estimationLDSTM" class="quarto-xref"><span>Section 8.3.2</span></a> can be generalized to the setting of non-Gaussian and nonlinear DSTMs (e.g., particle filters and smoothers, ensemble Kalman filters; see Chapter 8 of <span class="citation" data-cites="cressie2011statistics">Cressie and Wikle (<a href="references.html#ref-cressie2011statistics" role="doc-biblioref">2011</a>)</span>). However, in the high-dimensional settings with deep BHMs with complicated parameter-dependence structures, one typically has to consider fully Bayesian implementations. As mentioned above, these implementations are often programmed “from scratch” rather than from particular <code>R</code> packages. As an example, see the BHM based on a linear DSTM with Gaussian error given in <a href="#sec-PDEdecomp_MedWinds" class="quarto-xref"><span>Section 8.5</span></a>.</p>
</section>
</section>
<section id="sec-Appendix5b" class="level2" data-number="8.4">
<h2 data-number="8.4" class="anchored" data-anchor-id="sec-Appendix5b"><span class="header-section-number">8.4</span> Mechanistically Motivated Dynamic Spatio-Temporal Models</h2>
<p>As discussed in <a href="Chapter5.html#sec-ProcParamRed" class="quarto-xref"><span>Section 5.3</span></a>, it can be quite useful to parameterize DSTMs by considering transition matrices that are motivated by a mechanistic model. Here, we show the details of how one can do this with a partial differential equation (PDE) and an integro-difference equation (IDE).</p>
<section id="sec-PDEdecomp1" class="level3" data-number="8.4.1">
<h3 data-number="8.4.1" class="anchored" data-anchor-id="sec-PDEdecomp1"><span class="header-section-number">8.4.1</span> Example of a Process Model Motivated by a PDE: Finite Differences</h3>
<p>Consider the case where the parameters <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(u\)</span>, and <span class="math inline">\(v\)</span> in <a href="Chapter5.html#eq-Fickdiffadv" class="quarto-xref">Equation&nbsp;<span>5.14</span></a> vary with space and denote the two-dimensional spatial location by the vector <span class="math inline">\(\mathbf{s}= (x,y)'\)</span>. Then the PDE is</p>
<p><span id="eq-Diffdetail"><span class="math display">\[
\small
\frac{\partial Y}{\partial t} = \frac{\partial}{\partial x}\left(a(x,y) \frac{\partial Y}{\partial x}\right) + \frac{\partial}{\partial y}\left(b(x,y) \frac{\partial Y}{\partial y}\right) + u(x,y) \frac{\partial Y}{\partial x} + v(x,y) \frac{\partial Y}{\partial y}.
\tag{8.11}\]</span></span></p>
<p>If we consider this process on a regular two-dimensional grid and employ a standard centered finite difference in space and a forward difference in time for <a href="#eq-Diffdetail" class="quarto-xref">Equation&nbsp;<span>8.11</span></a>, we obtain a lagged nearest-neighbor relationship given by</p>
<p><span id="eq-numAdvDiff"><span class="math display">\[
\small
\begin{aligned}
Y_t(x,y) =~~  &amp;\theta_{p,1}(x,y) Y_{t-\Delta_t}(x,y) + \theta_{p,2}(x,y) Y_{t-\Delta_t}(x+\Delta_x,y) \nonumber \\
&amp;\; + \; \theta_{p,3}(x,y) Y_{t-\Delta_t}(x-\Delta_x,y)   + \theta_{p,4}(x,y) Y_{t-\Delta_t}(x,y + \Delta_y) \nonumber \\
&amp;\; + \; \theta_{p,5}(x,y) Y_{t-\Delta_t}(x,y-\Delta_y),
\end{aligned}
\tag{8.12}\]</span></span></p>
<p>where <span class="math inline">\(\Delta_t\)</span> is a time-discretization constant, <span class="math inline">\(\Delta_x\)</span> and <span class="math inline">\(\Delta_y\)</span> are spatial-discretization constants, and the <span class="math inline">\(\theta\)</span>s are defined as</p>
<p><span class="math display">\[
\small
\begin{align*}
\theta_{p,1}(x,y) &amp;= \left[\frac{-2 a(x,y) \Delta_t}{\Delta^2_x} + \frac{-2 b(x,y) \Delta_t}{\Delta^2_y}\right] + 1,  \\
\theta_{p,2}(x,y) &amp;= \frac{a(x+\Delta_x,y) \Delta_t}{4 \Delta_x^2} - \frac{a(x-\Delta_x,y) \Delta_t}{4 \Delta_x^2} +  \frac{a(x,y) \Delta_t}{ \Delta_x^2} + \frac{u(x,y) \Delta_t}{2 \Delta_x}, \\
\theta_{p,3}(x,y) &amp;= \frac{-a(x+\Delta_x,y) \Delta_t}{4 \Delta_x^2} + \frac{a(x-\Delta_x,y) \Delta_t}{4 \Delta_x^2} +  \frac{a(x,y) \Delta_t}{ \Delta_x^2} - \frac{u(x,y) \Delta_t}{2 \Delta_x}, \\
\theta_{p,4}(x,y) &amp;= \frac{b(x,y+\Delta_y) \Delta_t}{4 \Delta_y^2} - \frac{b(x,y-\Delta_y) \Delta_t}{4 \Delta_y^2} +  \frac{b(x,y) \Delta_t}{ \Delta_y^2} + \frac{v(x,y) \Delta_t}{2 \Delta_y}, \\
\theta_{p,5}(x,y) &amp;= \frac{-b(x,y+\Delta_y) \Delta_t}{4 \Delta_y^2} + \frac{b(x,y-\Delta_y) \Delta_t}{4 \Delta_y^2} +  \frac{b(x,y) \Delta_t}{ \Delta_y^2} - \frac{v(x,y) \Delta_t}{2 \Delta_y}.
\end{align*}
\]</span></p>
<p>Thus, we see that the finite differences suggest that the neighbors of location <span class="math inline">\((x,y)\)</span> at the previous time (i.e., locations <span class="math inline">\((x-\Delta_x,y)\)</span>, <span class="math inline">\((x+\Delta_x,y)\)</span>, <span class="math inline">\((x,y-\Delta_y)\)</span>, and <span class="math inline">\((x, y + \Delta_y)\)</span>), as well as the location <span class="math inline">\((x,y)\)</span> itself, play a role in the transition from one time to the next. Note the role of the spatially varying parameters. Let <span class="math inline">\(\mathbf{Y}_t\)</span> be the process evaluated at all interior grid points at time <span class="math inline">\(t\)</span>, and assume the process is defined to be 0 on the boundary (for ease of presentation). Then one can write <a href="#eq-numAdvDiff" class="quarto-xref">Equation&nbsp;<span>8.12</span></a> as <span class="math inline">\(\mathbf{Y}_t = \mathbf{M}\mathbf{Y}_{t-\Delta_t}\)</span>, where <span class="math inline">\(\mathbf{M}\)</span> is parameterized with the elements of <span class="math inline">\(\{\theta_{p,i}(x,y),\ i=1,\ldots,5\}\)</span>. Assume first for simplicity that there is no advection (i.e., <span class="math inline">\(u(x,y) = 0\)</span>, <span class="math inline">\(v(x,y) = 0\)</span> for all locations) and the diffusion coefficients in the <span class="math inline">\(x\)</span>- and <span class="math inline">\(y\)</span>-directions are equal (i.e., <span class="math inline">\(a(x,y) = b(x,y)\)</span>). Then, it can be shown that the transition operator <span class="math inline">\(\mathbf{M}\)</span> is still asymmetric if the diffusion coefficients vary with space. If the diffusion coefficients are constant in space and equal (i.e., <span class="math inline">\(a=b\)</span>), then transition-operator asymmetry is only due to the advection component.</p>
<p>The type of diffusion represented in <a href="#eq-Diffdetail" class="quarto-xref">Equation&nbsp;<span>8.11</span></a> is typically called “Fickian” diffusion. Similar finite-difference discretizations of other diffusion representations (e.g., so-called “ecological diffusion,” <span class="math inline">\(\nabla^2 (a(x,y) Y)\)</span>) lead to different formulations of the parameters <span class="math inline">\(\boldsymbol{\theta}_p\)</span> (in terms of the coefficients <span class="math inline">\(a(x,y)\)</span>), but they still correspond to a five-diagonal sparse transition operator <span class="math inline">\(\mathbf{M}\)</span>. Thus, in the context of a linear DSTM process model, we typically allow the parameters <span class="math inline">\(\boldsymbol{\theta}_p\)</span> to be spatially explicit random processes with the possible addition of covariates, rather than model the specific diffusion equation coefficients (e.g., <span class="math inline">\(a(x,y)\)</span>, <span class="math inline">\(b(x,y)\)</span>, <span class="math inline">\(u(x,y)\)</span>, and <span class="math inline">\(v(x,y)\)</span> in <a href="#eq-Diffdetail" class="quarto-xref">Equation&nbsp;<span>8.11</span></a>) directly. (Although, one can certainly do this, and the different diffusions correspond to different scientific interpretations.) A last point to make is that different types of finite-difference discretizations lead to different parameterizations (e.g., a higher-order spatial discretization leads to larger neighborhoods, and higher-order temporal differences lead to higher-order Markov models.)</p>
</section>
<section id="sec-PDEdecomp" class="level3" data-number="8.4.2">
<h3 data-number="8.4.2" class="anchored" data-anchor-id="sec-PDEdecomp"><span class="header-section-number">8.4.2</span> Example of a Process Model Motivated by a PDE: Spectral</h3>
<p>This section considers a natural basis-function (i.e., spectral) approach to motivating a DSTM from a mechanistic model.</p>
<p>Consider a simple one-dimensional spatial version of the advection-diffusion PDE in <a href="Chapter5.html#eq-Fickdiffadv" class="quarto-xref">Equation&nbsp;<span>5.14</span></a>, and denote the spatial index by <span class="math inline">\(x\)</span>,</p>
<p><span id="eq-1DspatAdvDif"><span class="math display">\[
\frac{\partial Y(x,t)}{\partial t} =   a \frac{\partial^2 Y(x,t)}{\partial x^2} + b \frac{\partial Y(x,t)}{\partial x},
\tag{8.13}\]</span></span></p>
<p>where in this example the advection and diffusion coefficients (<span class="math inline">\(b\)</span> and <span class="math inline">\(a\)</span>, respectively) are assumed to be constant. Now consider the solution as a superposition of Fourier functions (i.e., sines and cosines),</p>
<p><span id="eq-Ysincosexp"><span class="math display">\[
Y_t(x) = \sum_{j=1}^J [\alpha_{j,t}(1) \cos(\omega_j x) +\alpha_{j,t}(2) \sin(\omega_j x)],
\tag{8.14}\]</span></span></p>
<p>where <span class="math inline">\(\omega_j = 2 \pi j/\vert D_x\vert\)</span> is the spatial frequency of a sinusoid with spatial wave number <span class="math inline">\(j=1,\dots ,J\)</span> in the spatial domain <span class="math inline">\({D_x}\)</span> (and <span class="math inline">\(|D_x|\)</span> corresponds to the length of the spatial domain). For simplicity of exposition, we do not include a constant term in the expansion <a href="#eq-Ysincosexp" class="quarto-xref">Equation&nbsp;<span>8.14</span></a>. For the <span class="math inline">\(n\)</span> spatial locations of interest and <span class="math inline">\(n_\alpha\)</span> Fourier basis functions, we let <span class="math inline">\(\mathbf{Y}_t = \boldsymbol{\Phi}\boldsymbol{\alpha}_t\)</span>, where <span class="math inline">\(\mathbf{Y}_t\)</span> is an <span class="math inline">\(n\)</span>-dimensional vector, <span class="math inline">\(\boldsymbol{\Phi}\)</span> is an <span class="math inline">\(n \times n_\alpha\)</span> matrix consisting of Fourier basis functions, and <span class="math inline">\(\boldsymbol{\alpha}_t\)</span> contains the associated <span class="math inline">\(n_\alpha\)</span> expansion coefficients, where <span class="math inline">\(n_\alpha = 2 J\)</span>.</p>
<p>The deterministic solution of <a href="#eq-1DspatAdvDif" class="quarto-xref">Equation&nbsp;<span>8.13</span></a> gives formulas for <span class="math inline">\(\{\alpha_{j,t}(1), \alpha_{j,t}(2)\}\)</span>, which are exponentially decaying sinusoids in time:</p>
<p><span class="math display">\[
\begin{aligned}
\alpha_{j,t}(1) &amp; =  \exp(-a \omega_j^2 t) \sin(b \omega_j t), \\
\alpha_{j,t}(2) &amp; =  \exp(-a \omega_j^2 t) \cos(b \omega_j t),\quad j=1,\dots ,J.
\end{aligned}
\]</span></p>
<p>In this case, the time evolution is given by,</p>
<p><span class="math display">\[
{\boldsymbol{\alpha}}_{j,t+\Delta_t} = {\mathbf{M}}_j {\boldsymbol{\alpha}}_{j,t},\quad j=1,\dots ,J,
\]</span></p>
<p>where <span class="math inline">\(\boldsymbol{\alpha}_{j,t} \equiv (\alpha_{j,t}(1) \; \alpha_{j,t}(2))'\)</span> and</p>
<p><span class="math display">\[
{\mathbf{M}}_j = \left[ \begin{array}{rr} e^{-a \omega_j^2 \Delta_t}\cos \{\omega_j \Delta_t\} &amp; e^{-a \omega_j^2 \Delta_t}\sin\{\omega_j \Delta_t\} \\
-e^{-a \omega_j^2 \Delta_t}\sin\{\omega_j \Delta_t\} &amp; e^{-a \omega_j^2 \Delta_t}\cos\{\omega_j \Delta_t\} \end{array} \right].
\]</span></p>
<p>This motivates the <span class="math inline">\(2J\)</span>-dimensional linear DSTM process model,</p>
<p><span class="math display">\[
{\boldsymbol{\alpha}}_{t} = \mathbf{M}_\alpha {\boldsymbol{\alpha}}_{t-1} + {\boldsymbol{\eta}}_{t}\,,
\]</span></p>
<p>where <span class="math inline">\({\boldsymbol{\alpha}}_t \equiv ({\boldsymbol{\alpha}}'_{1,t} \; \ldots \; {\boldsymbol{\alpha}}'_{J,t})'\)</span> for <span class="math inline">\(\boldsymbol{\alpha}_{j,t} = (\alpha_{j,t}(1),a_{j,t}(2))'\)</span>, <span class="math inline">\(\boldsymbol{\eta}_t = (\boldsymbol{\eta}'_{1,t},\ldots,\boldsymbol{\eta}'_{J,t})'\)</span> for <span class="math inline">\(\boldsymbol{\eta}_{j,t} = (\eta_{j,t}(1),\eta_{j,t}(2))'\)</span>, <span class="math inline">\(\mathbf{M}_\alpha\)</span> is a <span class="math inline">\(2J \times 2J\)</span> block diagonal matrix with blocks <span class="math inline">\(\{{\mathbf{M}}_j\)</span>, <span class="math inline">\(j=1,\ldots,J\}\)</span>, and we have assumed that <span class="math inline">\(\Delta_t=1\)</span>. This then suggests block-diagonal parameterizations where the <span class="math inline">\(2 \times 2\)</span> coefficients associated with each set of Fourier functions are unknown and must be estimated (e.g., via a Bayesian hierarchical model). The result is a very sparse representation for the transition matrix, <span class="math inline">\(\mathbf{M}_\alpha\)</span>, when <span class="math inline">\(J\)</span> is large.</p>
</section>
<section id="sec-IDEdecomp" class="level3" data-number="8.4.3">
<h3 data-number="8.4.3" class="anchored" data-anchor-id="sec-IDEdecomp"><span class="header-section-number">8.4.3</span> Example of a Process Model Motivated by an IDE</h3>
<p>The stochastic IDE framework discussed in Chapter 5 naturally motivates a DSTM process model. Consider a decomposition similar to <a href="Chapter5.html#eq-YtildeLab" class="quarto-xref">Equation&nbsp;<span>5.24</span></a>, where we let the process <span class="math inline">\(\{ \widetilde{Y}_t(\mathbf{s}): \mathbf{s}\in D_s\}\)</span> be decomposed as</p>
<p><span class="math display">\[
\widetilde{Y}_t(\mathbf{s})=\mathbf{x}_t(\mathbf{s})' \boldsymbol{\beta}+ Y_t(\mathbf{s})+\nu_t(\mathbf{s})\,,
\]</span></p>
<p>where <span class="math inline">\(\{Y_t(\mathbf{s}): \mathbf{s}\in D_s\}\)</span> is assumed to be a dynamical process, and <span class="math inline">\(\nu_t (\mathbf{s})\)</span> is a non-dynamical process in the sense that it does not exhibit Markovian temporal dependence. Now, we assume that <span class="math inline">\(\{ Y_t(\mathbf{s})\}\)</span> follows a stochastic IDE model as in <a href="Chapter5.html#eq-linearIDE" class="quarto-xref">Equation&nbsp;<span>5.9</span></a>. That is, for <span class="math inline">\(\mathbf{s}\in D_s\)</span>,</p>
<p><span id="eq-YPtbs"><span class="math display">\[
Y_t(\mathbf{s}) = \int_{D_s} m(\mathbf{s},\mathbf{x}; \boldsymbol{\theta}_p) \; Y_{t-1}(\mathbf{x}) \textrm{d}\mathbf{x}+\eta_t (\mathbf{s})\,,
\tag{8.15}\]</span></span></p>
<p>where <span class="math inline">\(m(\mathbf{s},\mathbf{x}; \boldsymbol{\theta}_p)\)</span> is the transition kernel over the domain <span class="math inline">\(D_s\)</span>, and <span class="math inline">\(\boldsymbol{\theta}_p\)</span> are kernel parameters.</p>
<p>As in <a href="Chapter5.html#eq-DSTMmixedeffects" class="quarto-xref">Equation&nbsp;<span>5.15</span></a>, we assume that the dynamical process can be expanded in terms of <span class="math inline">\(n_\alpha\)</span> basis functions, <span class="math inline">\(\{\phi_i (\mathbf{s})\colon i=1,\dots ,n_\alpha\}\)</span>. That is,</p>
<p><span id="eq-YPts"><span class="math display">\[
Y_t (\mathbf{s}) = \sum^{n_\alpha}_{i=1} \phi_i(\mathbf{s})  \alpha_{i,t} \,.
\tag{8.16}\]</span></span></p>
<p>Now, we can also expand the transition kernel in terms of these basis functions (although we could use different basis functions in general; see, for example, <span class="citation" data-cites="cressie2011statistics">Cressie and Wikle (<a href="references.html#ref-cressie2011statistics" role="doc-biblioref">2011</a>)</span>, Chapter 7):</p>
<p><span id="eq-mbsbx"><span class="math display">\[
m(\mathbf{s},\mathbf{x}; \boldsymbol{\theta}_p) = \sum^{n_\alpha}_{j=1}  \phi_j(\mathbf{x}) b_j(\mathbf{s}; \boldsymbol{\theta}_p).
\tag{8.17}\]</span></span></p>
<p>Substituting <a href="#eq-YPts" class="quarto-xref">Equation&nbsp;<span>8.16</span></a> and <a href="#eq-mbsbx" class="quarto-xref">Equation&nbsp;<span>8.17</span></a> into <a href="#eq-YPtbs" class="quarto-xref">Equation&nbsp;<span>8.15</span></a> and, for the sake of simplicity, adding the assumption that the basis functions are orthonormal,</p>
<p><span class="math display">\[
\int_{D_s}\phi_i (\mathbf{x})\phi_j(\mathbf{x}) \textrm{d}\mathbf{x}= \left\{ \begin{array}{ll}
1,&amp;i=j,\\
0,&amp;i\not= j, \end{array}\right.
\]</span></p>
<p>we can show that</p>
<p><span class="math display">\[
\begin{aligned}
Y_{t}(\mathbf{s}) &amp;=  \sum^{n_\alpha}_{i=1} b_i(\mathbf{s}; \boldsymbol{\theta}_p)\alpha_{i,t-1} + \eta_t
(\mathbf{s})\\
&amp;=   \; \mathbf{b}'(\mathbf{s}; \boldsymbol{\theta}_p)\boldsymbol{\alpha}_{t-1} +\eta_t(\mathbf{s})\,,
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(\mathbf{b}(\mathbf{s}; \boldsymbol{\theta}_p)\equiv (b_1(\mathbf{s}; \boldsymbol{\theta}_p),\dots ,b_{n_\alpha}(\mathbf{s}; \boldsymbol{\theta}_p))'\)</span> and <span class="math inline">\(\boldsymbol{\alpha}_t \equiv (\alpha_{1,t},\ldots ,\alpha_{n_\alpha,t})'\)</span>. Note also that <span class="math inline">\(\mathbf{Y}_t = \boldsymbol{\Phi}\boldsymbol{\alpha}_t\)</span>, where <span class="math inline">\(\boldsymbol{\Phi}\)</span> is an <span class="math inline">\(n \times n_\alpha\)</span> basis-function matrix,</p>
<p><span class="math display">\[
\boldsymbol{\Phi}\equiv\left(\begin{array}{c}
\boldsymbol{\phi}(\mathbf{s}_1)'\\ \vdots\\ \boldsymbol{\phi}(\mathbf{s}_n)'\end{array}\right)\,,
\]</span></p>
<p>and <span class="math inline">\(\boldsymbol{\phi}(\mathbf{s}_i) \equiv (\phi_1(\mathbf{s}_i),\dots ,\phi_{n_\alpha}(\mathbf{s}_i))'\)</span>, for <span class="math inline">\(i=1,\dots ,n\)</span>. Now, define the <span class="math inline">\(n\times n_\alpha\)</span> matrix</p>
<p><span class="math display">\[
\mathbf{B}\equiv \left(\begin{array}{c}
\mathbf{b}(\mathbf{s}_1;\boldsymbol{\theta}_p)'\\ \vdots\\ \mathbf{b}(\mathbf{s}_n;\boldsymbol{\theta}_p)'\end{array}\right)\,.
\]</span></p>
<p>Then, for all <span class="math inline">\(n\)</span> process locations, we can write</p>
<p><span class="math display">\[
\begin{aligned}
\boldsymbol{\alpha}_t &amp;= (\boldsymbol{\Phi}'\boldsymbol{\Phi})^{-1}\boldsymbol{\Phi}'\mathbf{B}\boldsymbol{\alpha}_{t-1} +
(\boldsymbol{\Phi}'\boldsymbol{\Phi})^{-1}\boldsymbol{\Phi}'\boldsymbol{\eta}_t \\
&amp;= \boldsymbol{\Phi}'\mathbf{B}\boldsymbol{\alpha}_{t-1} +
\boldsymbol{\Phi}'\boldsymbol{\eta}_t\\
&amp;\equiv \mathbf{M}_\alpha\boldsymbol{\alpha}_{t-1} +\tilde{\boldsymbol{\eta}}_t,
\end{aligned}
\]</span></p>
<p>where the second equality is due to orthonormality (i.e., <span class="math inline">\(\boldsymbol{\Phi}' \boldsymbol{\Phi}= \mathbf{I}\)</span>), <span class="math inline">\(\tilde{\boldsymbol{\eta}}_t \equiv \boldsymbol{\Phi}' {\boldsymbol{\eta}}_t\)</span> is the <span class="math inline">\(n_\alpha\)</span>-dimensional noise process, and the <span class="math inline">\(n_\alpha \times n_\alpha\)</span> propagator matrix is given by <span class="math inline">\(\mathbf{M}_\alpha \equiv \boldsymbol{\Phi}'\mathbf{B}\)</span>.</p>
<p>The truncated expansion <a href="#eq-YPts" class="quarto-xref">Equation&nbsp;<span>8.16</span></a> leads to a lower-dimensional dynamical process (since <span class="math inline">\(n_\alpha \ll n\)</span>). In principle, we still have to estimate the <span class="math inline">\(n \times n_\alpha\)</span> matrix <span class="math inline">\(\mathbf{B}\)</span> and the covariance matrix associated with <span class="math inline">\(\tilde{\boldsymbol{\eta}}_t\)</span>. However, the IDE formulation allows the kernel <span class="math inline">\(m(\mathbf{s},\mathbf{x}; \boldsymbol{\theta}_p)\)</span> to be parameterized parsimoniously. In some cases, one can select <span class="math inline">\(\{\phi_j(\mathbf{s})\}\)</span> to ensure that the expansion coefficients for the kernel can be specified analytically in terms of its parameters. For example, letting <span class="math inline">\(\{\phi_j(\cdot)\}\)</span> in <a href="#eq-mbsbx" class="quarto-xref">Equation&nbsp;<span>8.17</span></a> be Fourier basis functions allows one to parameterize the kernel in terms of its characteristic function. This can facilitate a BHM parameterization that allows kernel asymmetry and scale parameters to vary in space.</p>
<p>Lab 5.1 gives an introduction to the implementation of the IDE in one-dimensional space. Lab 5.2 then gives an implementation of a DSTM motivated by the stochastic IDE model to generate nowcasts for weather radar images.</p>
</section>
</section>
<section id="sec-PDEdecomp_MedWinds" class="level2" data-number="8.5">
<h2 data-number="8.5" class="anchored" data-anchor-id="sec-PDEdecomp_MedWinds"><span class="header-section-number">8.5</span> Case Study: Physical-Statistical Bayesian Hierarchical Model for Predicting Mediterranean Surface Winds</h2>
<p>In this section we present a specific and detailed example of how to develop a physically motivated bivariate spatio-temporal model for the purpose of predicting near-surface wind fields in the Mediterranean Sea. The implementation of this model in <code>R</code> is given below.</p>
<p>Consider a simple analytical model for the surface wind known as the <em>Rayleigh friction equations</em> <span class="citation" data-cites="stevens2002entrainment">(e.g., <a href="references.html#ref-stevens2002entrainment" role="doc-biblioref">Stevens et al. 2002</a>)</span>:</p>
<p><span class="math display">\[
\begin{align*}
\frac{\partial u}{\partial t} &amp;= f v - \frac{1}{\rho_0} \frac{\partial P}{\partial x} - \gamma u, \\
\frac{\partial v}{\partial t} &amp;= - f u - \frac{1}{\rho_0} \frac{\partial P}{\partial y} - \gamma v,
\end{align*}
\]</span></p>
<p>where <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> are the east–west and north–south components of the wind, respectively (recall that winds are vectors with a magnitude and direction that can be decomposed into <span class="math inline">\(x\)</span> (east–west) and <span class="math inline">\(y\)</span> (north–south) coordinates); <span class="math inline">\(f\)</span> is the Coriolis parameter; <span class="math inline">\(\rho_0\)</span> is a reference atmospheric density; <span class="math inline">\(P\)</span> is the sea-level pressure; and <span class="math inline">\(\gamma\)</span> is the Rayleigh friction parameter. Note that <span class="math inline">\(u\)</span>, <span class="math inline">\(v\)</span>, and <span class="math inline">\(P\)</span> are functions of time and space. As in <a href="#sec-PDEdecomp1" class="quarto-xref"><span>Section 8.4.1</span></a>, simple forward differencing in time with <span class="math inline">\(\Delta_t = 1\)</span>, and centered differencing in space, give the analogous discretized form of these equations:</p>
<p><span id="eq-DRFEu1"><span class="math display">\[
\small
u_{t+1}(i,j) =  u_t(i,j) + \Delta_t \left\{ f v_t(i,j) -  \frac{1}{\rho_0}\left(\frac{P_t(i+1,j) - P_t(i-1,j)}{2 \Delta_x}\right) - \gamma u_t(i,j)\right\},
\tag{8.18}\]</span></span></p>
<p><span id="eq-DRFEv1"><span class="math display">\[
\small
v_{t+1}(i,j) = v_t(i,j) +   \Delta_t\left\{  - f u_t(i,j) -
  \frac{1}{\rho_0}\left(\frac{P_t(i,j+1) - P_t(i,j-1)}{2 \Delta_y}\right) - \gamma v_t(i,j)\right\},  
\tag{8.19}\]</span></span></p>
<p>where <span class="math inline">\(u_t(i,j)\)</span>, <span class="math inline">\(v_t(i,j)\)</span>, and <span class="math inline">\(P_t(i,j)\)</span> are discretized wind components and pressure, respectively, at grid location <span class="math inline">\((i,j)\)</span> and time <span class="math inline">\(t\)</span>, and <span class="math inline">\(\Delta_x\)</span>, and <span class="math inline">\(\Delta_y\)</span> are the <span class="math inline">\(x\)</span>-, and <span class="math inline">\(y\)</span>-discretization constants, respectively. Note that this is a multivariate linear system, with each component of the wind conditioned on the past values of that component, the other component, and the difference (gradient) in pressure.</p>
<p>Now a simple <em>statistical</em> process model based on these equations can be written in vector form as:</p>
<p><span id="eq-Ueq1"><span class="math display">\[
\mathbf{u}_{t+1} = \theta_{uu} \mathbf{u}_t + \theta_{uv} \mathbf{v}_t + \theta_{up} \mathbf{D}_x \mathbf{P}_t  + \boldsymbol{\eta}_{u,t},
\tag{8.20}\]</span></span></p>
<p><span id="eq-Veq1"><span class="math display">\[
\mathbf{v}_{t+1} = \theta_{vv} \mathbf{v}_t + \theta_{vu} \mathbf{u}_t + \theta_{vp} \mathbf{D}_y \mathbf{P}_t  + \boldsymbol{\eta}_{v,t},  \tag{8.21}\]</span></span></p>
<p>for <span class="math inline">\(t=1,\ldots,T-1\)</span>, where <span class="math inline">\(\mathbf{v}_t\)</span> and <span class="math inline">\(\mathbf{u}_t\)</span> are <span class="math inline">\(n_g\)</span>-dimensional <span class="math inline">\((n_g = n_x \times n_y)\)</span> vectors of the discretized <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> components, <span class="math inline">\(n_x\)</span> and <span class="math inline">\(n_y\)</span> being the number of grid locations in the <span class="math inline">\(x\)</span>- and <span class="math inline">\(y\)</span>-directions on the prediction grid; <span class="math inline">\(\mathbf{P}_t\)</span> is an <span class="math inline">\(n_e = (n_x + 2) \times (n_y + 2)\)</span>-dimensional vector of surface pressure values on an expanded grid (which in our example will come from data); <span class="math inline">\(\mathbf{D}_x\)</span> and <span class="math inline">\(\mathbf{D}_y\)</span> are <span class="math inline">\(n_g \times n_e\)</span> matrix operators that give the centered difference in the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> directions, respectively; and <span class="math inline">\(\boldsymbol{\eta}_{u,t} \sim iid \; Gau(0,\sigma^2_u \mathbf{I})\)</span> and <span class="math inline">\(\boldsymbol{\eta}_{v,t} \sim  iid \; Gau(0, \sigma^2_v \mathbf{I})\)</span> are residual error processes. Although we could specify the <span class="math inline">\(\theta\)</span>-values in <a href="#eq-Ueq1" class="quarto-xref">Equation&nbsp;<span>8.20</span></a> and <a href="#eq-Veq1" class="quarto-xref">Equation&nbsp;<span>8.21</span></a> according to the discretization constants and <span class="math inline">\(f\)</span> and <span class="math inline">\(\gamma\)</span> in <a href="#eq-DRFEu1" class="quarto-xref">Equation&nbsp;<span>8.18</span></a> and <a href="#eq-DRFEv1" class="quarto-xref">Equation&nbsp;<span>8.19</span></a>, we instead allow them to be unknown and random here (see below) and include the additive error terms to adapt to the data and to reflect the fact that the Rayleigh friction equations are a pretty rough approximation for reality. More complicated versions of this model are given in <span class="citation" data-cites="milliff2011ocean">Milliff et al. (<a href="references.html#ref-milliff2011ocean" role="doc-biblioref">2011</a>)</span> and <span class="citation" data-cites="cressie2011statistics">Cressie and Wikle (<a href="references.html#ref-cressie2011statistics" role="doc-biblioref">2011, chap. 9</a>)</span> to account for spatio-temporal dependent errors as well as a random pressure process.</p>
<p>We have two sources of data on Mediterranean surface winds (as described in <a href="Chapter2.html#sec-STdata" class="quarto-xref"><span>Section 2.1</span></a>): gridded analysis wind and pressure data from the European Center for Medium Range Weather Forecasting (ECMWF) (these observations are complete in space and time); and higher-resolution satellite observations of near-surface winds over the ocean from the polar-orbiting QuikSCAT scatterometer (these observations are irregular in space and time). The BHM is given by a data model, a process model, and a parameter model. For modeling the Mediterranean wind data, these are defined as follows.</p>
<p><strong>Data model</strong>. For <span class="math inline">\(t=1,\ldots,T\)</span>, assume <span id="eq-Eu2"><span class="math display">\[
\mathbf{E}_{u,t} | \mathbf{u}_t, \sigma^2_e \sim indep. \; Gau(\mathbf{H}_{e} \mathbf{u}_t, \sigma^2_e \mathbf{I}),
\tag{8.22}\]</span></span> <span id="eq-Ev2"><span class="math display">\[
\mathbf{E}_{v,t} | \mathbf{v}_t, \sigma^2_e \sim indep. \; Gau(\mathbf{H}_{e} \mathbf{v}_t, \sigma^2_e \mathbf{I}),
\tag{8.23}\]</span></span> <span id="eq-Su2"><span class="math display">\[
\mathbf{S}_{u,t} | \mathbf{u}_t, \sigma^2_s \sim indep. \; Gau(\mathbf{H}_{s,t} \mathbf{u}_t, \sigma^2_s \mathbf{I}),
\tag{8.24}\]</span></span> <span id="eq-Sv2"><span class="math display">\[
\mathbf{S}_{v,t} | \mathbf{v}_t, \sigma^2_s \sim indep. \; Gau(\mathbf{H}_{s,t} \mathbf{v}_t, \sigma^2_s \mathbf{I}),
\tag{8.25}\]</span></span> where <span class="math inline">\(\mathbf{E}_{u,t}, \mathbf{E}_{v,t}\)</span> are <span class="math inline">\(n_e\)</span>-vectors of ECMWF observations at time <span class="math inline">\(t\)</span>, with associated <span class="math inline">\(n_e \times n_g\)</span> incidence matrix <span class="math inline">\(\mathbf{H}_e\)</span>; and <span class="math inline">\(\mathbf{S}_{u,t}, \mathbf{S}_{v,t}\)</span> are <span class="math inline">\(n_{s,t}\)</span>-dimensional vectors of QuikSCAT observations at time <span class="math inline">\(t\)</span>, with associated <span class="math inline">\(n_{s,t} \times n_g\)</span> incidence matrices, <span class="math inline">\(\mathbf{H}_{s,t}\)</span>. (Note that there are different numbers of QuikSCAT observations at each time, and there can be times for which there are no QuikSCAT observations.)</p>
<p><strong>Process model</strong>. For <span class="math inline">\(t=1,\ldots,T-1\)</span>, assume</p>
<p><span id="eq-uproc2"><span class="math display">\[
\mathbf{u}_{t+1} | \mathbf{u}_t, \mathbf{v}_t, \mathbf{P}_t, \theta_{uu}, \theta_{uv}, \theta_{up}, \sigma^2_u \sim {indep.} \; {Gau}(\theta_{uu} \mathbf{u}_t + \theta_{uv} \mathbf{v}_t + \theta_{up} \mathbf{D}_x \mathbf{P}_t , \sigma^2_u \mathbf{I}),~~~~~
\tag{8.26}\]</span></span></p>
<p><span id="eq-vproc2"><span class="math display">\[
\mathbf{v}_{t+1} | \mathbf{v}_t, \mathbf{u}_t, \mathbf{P}_t, \theta_{vv}, \theta_{vu}, \theta_{vp}, \sigma^2_v \sim {indep.} \; {Gau}(\theta_{vv} \mathbf{v}_t + \theta_{vu} \mathbf{u}_t + \theta_{vp} \mathbf{D}_y \mathbf{P}_t , \sigma^2_v \mathbf{I}),~~~~~
\tag{8.27}\]</span></span></p>
<p>where we have pressure observations, <span class="math inline">\(\mathbf{P}_t\)</span>, from the ECMWF data within the Mediterranean wind data. We also need to specify the process’s initial conditions at time <span class="math inline">\(t=1\)</span>. Assume</p>
<p><span id="eq-u12"><span class="math display">\[
\mathbf{u}_1 | \boldsymbol{\mu}_{u,1}, \sigma^2_{u,1} \sim \; {Gau}(\boldsymbol{\mu}_{u,1},\sigma^2_{u,1} \mathbf{I}),
\tag{8.28}\]</span></span></p>
<p><span id="eq-v12"><span class="math display">\[
\mathbf{v}_1 | \boldsymbol{\mu}_{v,1}, \sigma^2_{v,1} \sim \; {Gau}(\boldsymbol{\mu}_{v,1},\sigma^2_{v,1} \mathbf{I}).
\tag{8.29}\]</span></span></p>
<p><strong>Parameter model</strong>. All of the process-model parameters are assumed to be independent and their distributions are given by</p>
<p><span id="eq-theta_ab2"><span class="math display">\[
\theta_{ab} | \mu_{ab}, \sigma^2_{ab} \sim \; {Gau}(\mu_{ab}, \sigma^2_{ab}),
\tag{8.30}\]</span></span></p>
<p>for <span class="math inline">\(ab = \{uu,vv,uv,vu,up,vp\}\)</span>. Further,</p>
<p><span id="eq-sig2a2"><span class="math display">\[
\sigma^2_a | q_a, r_a \sim \; {IG}(q_a,r_a),
\tag{8.31}\]</span></span></p>
<p>for <span class="math inline">\(a = \{u, v\}\)</span> (where <span class="math inline">\({IG}(q_a, r_a)\)</span> is the <em>inverse gamma</em> distribution with shape parameter <span class="math inline">\(q_a\)</span> and rate parameter <span class="math inline">\(r_a\)</span>).</p>
<p><strong>Hyperparameters (fixed and specified)</strong>. The following hyperparameters are specified based on scientific assumptions or to correspond to “vague” prior distributions: <span class="math inline">\(\sigma^2_e,\)</span> <span class="math inline">\(\sigma^2_s,\)</span> <span class="math inline">\(\{\mu_{ab},\)</span> <span class="math inline">\(\sigma^2_{ab}:ab = uu,vv,uv,vu,up,vp\}\)</span>, <span class="math inline">\(\{q_a, r_a: a= u,v\}\)</span>, <span class="math inline">\(\boldsymbol{\mu}_{u,1}\)</span>, <span class="math inline">\(\boldsymbol{\mu}_{v,1}\)</span>, <span class="math inline">\(\sigma^2_{u,1}\)</span>, <span class="math inline">\(\sigma^2_{v,1}\)</span>. Specific values are given in the <code>R</code> example that follows.</p>
<p><strong>Gibbs sampler</strong>. The BHM presented above is amenable to a Gibbs sampler MCMC implementation because all the full conditional distributions are available in closed form <span class="citation" data-cites="cressie2011statistics">(see <a href="references.html#ref-cressie2011statistics" role="doc-biblioref">Cressie and Wikle 2011, chap. 8</a>, for details on how to derive full conditional distributions for spatio-temporal models)</span>. Recall from <a href="Chapter4.html#nte-algorithm-GibbsSampler" class="quarto-xref">Note&nbsp;<span>4.5</span></a> that the Gibbs sampler simply cycles through the full conditional distributions, sampling each variable given the most recent samples. The Gibbs sampler for the BHM of the Mediterranean winds data is outlined in <a href="#nte-algorithm-MedWindGibbsSampler" class="quarto-xref">Note&nbsp;<span>8.4</span></a>, where the equation numbers correspond to the full conditional distributions presented in the next section.</p>
<div id="nte-algorithm-MedWindGibbsSampler" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;8.4: Gibbs Sampler for BHM of Mediterranean winds data set
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Select hyperparameters:</strong> <span class="math inline">\(\sigma^2_e\)</span>, <span class="math inline">\(\sigma^2_s\)</span>, <span class="math inline">\(\{\mu_{ab}, \sigma^2_{ab}:ab = uu,vv,uv,vu,up,vp \}\)</span>, <span class="math inline">\(\{q_a, r_a: a=u,v\}\)</span>, <span class="math inline">\(\boldsymbol{\mu}_{u,1}\)</span>, <span class="math inline">\(\boldsymbol{\mu}_{v,1}\)</span>, <span class="math inline">\(\sigma^2_{u,1}\)</span>, <span class="math inline">\(\sigma^2_{v,1}\)</span></p>
<p><strong>Select initial values:</strong> <span class="math inline">\(\{\mathbf{u}^{(0)}_t: \, t=2,\ldots,T \}\)</span>, <span class="math inline">\(\{\mathbf{v}^{(0)}_t: \, t=1,\ldots,T \}\)</span>, <span class="math inline">\(\theta_{uu}^{(0)}\)</span>, <span class="math inline">\(\theta_{vv}^{(0)}\)</span>, <span class="math inline">\(\theta_{uv}^{(0)}\)</span>, <span class="math inline">\(\theta_{vu}^{(0)}\)</span>, <span class="math inline">\(\theta_{up}^{(0)}\)</span>, <span class="math inline">\(\theta_{vp}^{(0)}\)</span>, <span class="math inline">\(\sigma_u^{2(0)}\)</span>, <span class="math inline">\(\sigma_v^{2(0)}\)</span></p>
<p><strong>for</strong> <span class="math inline">\(\; \; i=1,2,\ldots, N_{\mathrm{gibbs}}\)</span> <strong>do</strong></p>
<ol type="1">
<li><p>using <a href="#eq-FCu12" class="quarto-xref">Equation&nbsp;<span>8.32</span></a>, <strong>sample from</strong></p>
<p><span class="math display">\[
\small
\mathbf{u}^{(i)}_1 | \mathbf{v}^{(i-1)}_1, \mathbf{u}^{(i-1)}_2, \mathbf{v}^{(i-1)}_2, \theta_{vu}^{(i-1)}, \theta_{uu}^{(i-1)}, \theta_{uv}^{(i-1)}, \theta_{vv}^{(i-1)}, \theta_{vp}^{(i-1)}, \theta_{up}^{(i-1)}, \sigma_u^{2(i-1)}, \sigma_v^{2(i-1)}
\]</span></p></li>
<li><p>using <a href="#eq-FCut2" class="quarto-xref">Equation&nbsp;<span>8.33</span></a> for <span class="math inline">\(t=2,\ldots,T-1\)</span>, <strong>sample from</strong></p>
<p><span class="math display">\[\begin{eqnarray*}
\; &amp; \; &amp; \; \mathbf{u}^{(i)}_t | \mathbf{u}^{(i)}_{t-1}, \mathbf{u}^{(i-1)}_{t+1}, \mathbf{v}^{(i-1)}_{t-1}, \mathbf{v}^{(i-1)}_t, \mathbf{v}^{(i-1)}_{t+1}, \theta_{vu}^{(i-1)}, \theta_{uu}^{(i-1)}, \theta_{uv}^{(i-1)}, \theta_{vv}^{(i-1)}, \nonumber \\
\; &amp; \; &amp; \;\;\;\;\;\;\;\;\;\;\;\;  \theta_{vp}^{(i-1)}, \theta_{up}^{(i-1)},  \sigma_u^{2(i-1)}, \sigma_v^{2(i-1)}
\end{eqnarray*}\]</span></p></li>
<li><p>using <a href="#eq-FCuT2" class="quarto-xref">Equation&nbsp;<span>8.34</span></a>, <strong>sample from</strong></p>
<p><span class="math display">\[
\mathbf{u}^{(i)}_T | \mathbf{u}^{(i)}_{T-1}, \mathbf{v}^{(i-1)}_{T-1},  \theta_{uu}^{(i-1)}, \theta_{uv}^{(i-1)},  \theta_{up}^{(i-1)},  \sigma_u^{2(i-1)}
\]</span></p></li>
<li><p>using <a href="#eq-FCv12" class="quarto-xref">Equation&nbsp;<span>8.35</span></a>, <strong>sample from</strong></p>
<p><span class="math display">\[\small
\mathbf{v}^{(i)}_1 | \mathbf{u}^{(i)}_1, \mathbf{u}^{(i)}_2, \mathbf{v}^{(i-1)}_2, \theta_{uv}^{(i-1)}, \theta_{uu}^{(i-1)}, \theta_{vu}^{(i-1)}, \theta_{vv}^{(i-1)}, \theta_{up}^{(i-1)}, \theta_{vp}^{(i-1)}, \sigma_u^{2(i-1)}, \sigma_v^{2(i-1)}
\]</span></p></li>
<li><p>using <a href="#eq-FCvt2" class="quarto-xref">Equation&nbsp;<span>8.36</span></a> for <span class="math inline">\(t=2,\ldots,T-1\)</span>, <strong>sample from</strong></p>
<p><span class="math display">\[\small
\mathbf{v}^{(i)}_t | \mathbf{u}^{(i)}_t, \mathbf{u}^{(i)}_{t-1}, \mathbf{u}^{(i)}_{t+1}, \mathbf{v}^{(i)}_{t-1},  \mathbf{v}^{(i-1)}_{t+1}, \theta_{vu}^{(i-1)}, \theta_{uu}^{(i-1)}, \theta_{uv}^{(i-1)}, \theta_{vv}^{(i-1)}, \theta_{vp}^{(i-1)}, \theta_{up}^{(i-1)},  \sigma_u^{2(i-1)}, \sigma_v^{2(i-1)}
\]</span></p></li>
<li><p>using <a href="#eq-FCvT2" class="quarto-xref">Equation&nbsp;<span>8.37</span></a>, <strong>sample from</strong></p>
<p><span class="math display">\[
\mathbf{v}^{(i)}_T | \mathbf{u}^{(i)}_{T-1}, \mathbf{v}^{(i)}_{T-1},  \theta_{vv}^{(i-1)}, \theta_{vu}^{(i-1)},  \theta_{vp}^{(i-1)},  \sigma_v^{2(i-1)}
\]</span></p></li>
<li><p>using <a href="#eq-FCthuu2" class="quarto-xref">Equation&nbsp;<span>8.38</span></a>, <strong>sample from</strong></p>
<p><span class="math display">\[
\theta_{uu}^{(i)} | \{\mathbf{u}^{(i)}_t: t=1,\ldots,T\}, \{\mathbf{v}^{(i)}_t: t=1,\ldots,T\}, \theta_{uv}^{(i-1)}, \theta_{up}^{(i-1)}, \sigma_u^{2(i-1)}
\]</span></p></li>
<li><p>using <a href="#eq-FCthvv2" class="quarto-xref">Equation&nbsp;<span>8.39</span></a>, <strong>sample from</strong></p>
<p><span class="math display">\[
\theta_{vv}^{(i)} | \{\mathbf{u}^{(i)}_t: t=1,\ldots,T\}, \{\mathbf{v}^{(i)}_t: t=1,\ldots,T\}, \theta_{vu}^{(i-1)}, \theta_{vp}^{(i-1)}, \sigma_v^{2(i-1)}
\]</span></p></li>
<li><p>using <a href="#eq-FCthuv2" class="quarto-xref">Equation&nbsp;<span>8.40</span></a>, <strong>sample from</strong></p>
<p><span class="math display">\[
\theta_{uv}^{(i)} | \{\mathbf{u}^{(i)}_t: t=1,\ldots,T\}, \{\mathbf{v}^{(i)}_t: t=1,\ldots,T\}, \theta_{uu}^{(i)}, \theta_{up}^{(i-1)}, \sigma_u^{2(i-1)}
\]</span></p></li>
<li><p>using <a href="#eq-FCthvu2" class="quarto-xref">Equation&nbsp;<span>8.41</span></a>, <strong>sample from</strong></p>
<p><span class="math display">\[
\theta_{vu}^{(i)} | \{\mathbf{u}^{(i)}_t: t=1,\ldots,T\}, \{\mathbf{v}^{(i)}_t: t=1,\ldots,T\}, \theta_{vv}^{(i)}, \theta_{vp}^{(i-1)}, \sigma_v^{2(i-1)}
\]</span></p></li>
<li><p>using <a href="#eq-FCthup2" class="quarto-xref">Equation&nbsp;<span>8.42</span></a>, <strong>sample from</strong></p>
<p><span class="math display">\[
\theta_{up}^{(i)} | \{\mathbf{u}^{(i)}_t: t=1,\ldots,T\}, \{\mathbf{v}^{(i)}_t: t=1,\ldots,T\}, \theta_{uu}^{(i)}, \theta_{uv}^{(i)}, \sigma_u^{2(i-1)}
\]</span></p></li>
<li><p>using <a href="#eq-FCthvp2" class="quarto-xref">Equation&nbsp;<span>8.43</span></a>, <strong>sample from</strong></p>
<p><span class="math display">\[
\theta_{vp}^{(i)} | \{\mathbf{u}^{(i)}_t: t=1,\ldots,T\}, \{\mathbf{v}^{(i)}_t: t=1,\ldots,T\}, \theta_{vv}^{(i)}, \theta_{vu}^{(i)}, \sigma_v^{2(i-1)}
\]</span></p></li>
<li><p>using <a href="#eq-FCs2u2" class="quarto-xref">Equation&nbsp;<span>8.44</span></a>, <strong>sample from</strong></p>
<p><span class="math display">\[
\sigma_u^{2(i)} | \{\mathbf{u}^{(i)}_t: t=1,\ldots,T\}, \{\mathbf{v}^{(i)}_t: t=1,\ldots,T\}, \theta_{uu}^{(i)}, \theta_{uv}^{(i)}, \theta_{up}^{(i)}
\]</span></p></li>
<li><p>using <a href="#eq-FCs2v2" class="quarto-xref">Equation&nbsp;<span>8.45</span></a>, <strong>sample from</strong></p>
<p><span class="math display">\[
\sigma_v^{2(i)} | \{\mathbf{u}^{(i)}_t: t=1,\ldots,T\}, \{\mathbf{v}^{(i)}_t: t=1,\ldots,T\}, \theta_{vv}^{(i)}, \theta_{vu}^{(i)}, \theta_{vp}^{(i)}
\]</span></p></li>
</ol>
<p><strong>end for</strong></p>
</div>
</div>
<p><strong>Full Conditional Distributions.</strong> Readers be warned that this material is very technical! The full conditional distributions for the Gibbs sampler presented in <a href="#nte-algorithm-MedWindGibbsSampler" class="quarto-xref">Note&nbsp;<span>8.4</span></a> are included here for advanced readers. For more examples in the spatio-temporal context, see <span class="citation" data-cites="cressie2011statistics">(<a href="references.html#ref-cressie2011statistics" role="doc-biblioref">Cressie and Wikle 2011, chap. 8</a>)</span>, and for other examples see <span class="citation" data-cites="gelman2013bayesian">Gelman et al. (<a href="references.html#ref-gelman2013bayesian" role="doc-biblioref">2014</a>)</span>. In the representation to follow, <span class="math inline">\([equation\ number]_t\)</span> corresponds to the distribution associated with the equation number above, where the variable on the left side of the conditioning symbol is given at time <span class="math inline">\(t\)</span>. When referring to the parameter model, <a href="#eq-theta_ab2" class="quarto-xref">Equation&nbsp;<span>8.30</span></a> and <a href="#eq-sig2a2" class="quarto-xref">Equation&nbsp;<span>8.31</span></a>, the notation <span class="math inline">\([equation\ number]_{ab}\)</span> and <span class="math inline">\([equation\ number]_a\)</span> correspond to the specific parameter distribution given by <span class="math inline">\(ab = \{uu, vv, uv, vu, up, vp\}\)</span> or <span class="math inline">\(a = \{u, v\}\)</span>, respectively.</p>
<ul>
<li>Full conditional distribution for <span class="math inline">\(\mathbf{u}_1\)</span>:</li>
</ul>
<div class="text-center">
<p><span class="math inline">\([\mathbf{u}_1 | \cdot] \propto [\)</span> <a href="#eq-Eu2" class="quarto-xref">Equation&nbsp;<span>8.22</span></a> <span class="math inline">\(]_1 \times [\)</span> <a href="#eq-Su2" class="quarto-xref">Equation&nbsp;<span>8.24</span></a> <span class="math inline">\(]_1 \times [\)</span> <a href="#eq-uproc2" class="quarto-xref">Equation&nbsp;<span>8.26</span></a> <span class="math inline">\(]_2 \times [\)</span> <a href="#eq-vproc2" class="quarto-xref">Equation&nbsp;<span>8.27</span></a> <span class="math inline">\(]_2 \times [\)</span> <a href="#eq-u12" class="quarto-xref">Equation&nbsp;<span>8.28</span></a> <span class="math inline">\(]\)</span></p>
</div>
<p><span id="eq-FCu12"><span class="math display">\[
  \mathbf{u}_1 | \cdot \sim Gau(\mathbf{A}_{u,1} \mathbf{b}_{u,1}, \mathbf{A}_{u,1})
   \tag{8.32}\]</span></span></p>
<p>where</p>
<p><span class="math display">\[
  \begin{aligned}
  \mathbf{A}_{u,1}\equiv &amp;\left( \mathbf{H}_e' \mathbf{H}_e/\sigma^2_e + \mathbf{H}_{s,1}' \mathbf{H}_{s,1}/\sigma^2_s + \theta_{vu}^2 \, \mathbf{I}/\sigma^2_v + \theta_{uu}^2 \, \mathbf{I}/\sigma^2_u +  \mathbf{I}/\sigma^2_{u,1} \right)^{-1},\\
  \mathbf{b}_{u,1}\equiv &amp;\left(\mathbf{E}_{u,1}' \mathbf{H}_e/\sigma^2_e + \mathbf{S}_{u,1}' \mathbf{H}_{s,1}/\sigma^2_s +  (\mathbf{v}_2 - \mathbf{c}_{v,1})' \theta_{vu}/\sigma^2_v \right.\\
  &amp;~~~\left.+ (\mathbf{u}_2 - \mathbf{c}_{u,1})' \theta_{uu}/\sigma^2_u + \boldsymbol{\mu}_{u,1}'/\sigma^2_{u,1}   \right)',
  \end{aligned}
  \]</span></p>
<p>with</p>
<p><span class="math display">\[
  \mathbf{c}_{u,1} \equiv \theta_{uv} \mathbf{v}_1  + \theta_{up} \mathbf{D}_x \mathbf{P}_1,
  \]</span></p>
<p><span class="math display">\[
  \mathbf{c}_{v,1} \equiv \theta_{vv} \mathbf{v}_1  + \theta_{vp} \mathbf{D}_y \mathbf{P}_1.
  \]</span></p>
<ul>
<li>Full conditional distribution for <span class="math inline">\(\mathbf{u}_t, t=2,\ldots,T-1\)</span>:</li>
</ul>
<div class="text-center">
<p><span class="math inline">\([\mathbf{u}_t | \cdot] \propto [\)</span> <a href="#eq-Eu2" class="quarto-xref">Equation&nbsp;<span>8.22</span></a> <span class="math inline">\(]_t \times [\)</span> <a href="#eq-Su2" class="quarto-xref">Equation&nbsp;<span>8.24</span></a> <span class="math inline">\(]_t \times [\)</span> <a href="#eq-vproc2" class="quarto-xref">Equation&nbsp;<span>8.27</span></a> <span class="math inline">\(]_{t+1} \times [\)</span> <a href="#eq-uproc2" class="quarto-xref">Equation&nbsp;<span>8.26</span></a> <span class="math inline">\(]_{t+1} \times [\)</span> <a href="#eq-uproc2" class="quarto-xref">Equation&nbsp;<span>8.26</span></a> <span class="math inline">\(]_{t}\)</span></p>
</div>
<p><span id="eq-FCut2"><span class="math display">\[
  \mathbf{u}_t | \cdot \sim Gau(\mathbf{A}_{u,t} \mathbf{b}_{u,t}, \mathbf{A}_{u,t})
   \tag{8.33}\]</span></span></p>
<p>where</p>
<p><span class="math display">\[
  \mathbf{A}_{u,t} \equiv \left( \mathbf{H}_e' \mathbf{H}_e/\sigma^2_e + \mathbf{H}_{s,t}' \mathbf{H}_{s,t}/\sigma^2_s + \theta_{vu}^2 \, \mathbf{I}/\sigma^2_v + \theta_{uu}^2 \, \mathbf{I}/\sigma^2_u + \mathbf{I}/\sigma^2_{u}  \right)^{-1},
  \]</span></p>
<p><span class="math display">\[
  \begin{aligned}
  \mathbf{b}_{u,t} \equiv &amp; (\mathbf{E}_{u,t}' \mathbf{H}_e/\sigma^2_e + \mathbf{S}_{u,t}' \mathbf{H}_{s,t}/\sigma^2_s + (\mathbf{v}_{t+1} - \mathbf{c}_{v,t})' \theta_{vu}/\sigma^2_v  + (\mathbf{u}_{t+1} - \mathbf{c}_{u,t})' \theta_{uu}/\sigma^2_u. \\
  &amp; ~~~ +  (\mathbf{c}_{u,t-1} + \theta_{uu} \mathbf{u}_{t-1})'/\sigma^2_u  )',
  \end{aligned}
  \]</span></p>
<p>with</p>
<p><span class="math display">\[
  \mathbf{c}_{v,t} \equiv \theta_{vv} \mathbf{v}_t  + \theta_{vp} \mathbf{D}_y \mathbf{P}_t,
  \]</span></p>
<p><span class="math display">\[
  \mathbf{c}_{u,t} \equiv \theta_{uv} \mathbf{v}_t + \theta_{up} \mathbf{D}_x \mathbf{P}_t,
  \]</span></p>
<p><span class="math display">\[
  \mathbf{c}_{u,t-1} \equiv \theta_{uv} \mathbf{v}_{t-1} + \theta_{up} \mathbf{D}_x \mathbf{P}_{t-1}.
  \]</span></p>
<ul>
<li>Full conditional distribution for <span class="math inline">\(\mathbf{u}_T\)</span>:</li>
</ul>
<div class="text-center">
<p><span class="math inline">\([\mathbf{u}_T | \cdot] \propto [\)</span> <a href="#eq-Eu2" class="quarto-xref">Equation&nbsp;<span>8.22</span></a> <span class="math inline">\(]_T \times [\)</span> <a href="#eq-Su2" class="quarto-xref">Equation&nbsp;<span>8.24</span></a> <span class="math inline">\(]_T \times [\)</span> <a href="#eq-uproc2" class="quarto-xref">Equation&nbsp;<span>8.26</span></a> <span class="math inline">\(]_{T}\)</span></p>
</div>
<p><span id="eq-FCuT2"><span class="math display">\[
\mathbf{u}_T | \cdot \sim Gau(\mathbf{A}_{u,T} \mathbf{b}_{u,T}, \mathbf{A}_{u,T})
\tag{8.34}\]</span></span></p>
<p>where</p>
<p><span class="math display">\[
\begin{align*}
\mathbf{A}_{u,T} &amp;\equiv \left( \mathbf{H}_e' \mathbf{H}_e/\sigma^2_e + \mathbf{H}_{s,T}' \mathbf{H}_{s,T}/\sigma^2_s + \mathbf{I}/ \sigma^2_{u}  \right)^{-1}, \\
\mathbf{b}_{u,T} &amp;\equiv (\mathbf{E}_{u,T}' \mathbf{H}_e/\sigma^2_e + \mathbf{S}_{u,T}' \mathbf{H}_{s,T}/\sigma^2_s +   (\mathbf{c}_{u,T-1} + \theta_{uu} \mathbf{u}_{T-1})'/\sigma^2_u  )',  
\end{align*}
\]</span></p>
<p>with</p>
<p><span class="math display">\[
\mathbf{c}_{u,T-1} \equiv \theta_{uv} \mathbf{v}_{T-1} + \theta_{up} \mathbf{D}_x \mathbf{P}_{T-1}.
\]</span></p>
<ul>
<li>Full conditional distribution for <span class="math inline">\(\mathbf{v}_1\)</span>:</li>
</ul>
<div class="text-center">
<p><span class="math inline">\([\mathbf{v}_1 | \cdot] \propto [\)</span> <a href="#eq-Ev2" class="quarto-xref">Equation&nbsp;<span>8.23</span></a> <span class="math inline">\(]_1 \times [\)</span> <a href="#eq-Sv2" class="quarto-xref">Equation&nbsp;<span>8.25</span></a> <span class="math inline">\(]_1 \times [\)</span> <a href="#eq-vproc2" class="quarto-xref">Equation&nbsp;<span>8.27</span></a> <span class="math inline">\(]_2 \times [\)</span> <a href="#eq-uproc2" class="quarto-xref">Equation&nbsp;<span>8.26</span></a> <span class="math inline">\(]_2 \times [\)</span> <a href="#eq-v12" class="quarto-xref">Equation&nbsp;<span>8.29</span></a> <span class="math inline">\(]\)</span></p>
</div>
<p><span id="eq-FCv12"><span class="math display">\[
\mathbf{v}_1 | \cdot \sim Gau(\mathbf{A}_{v,1} \mathbf{b}_{v,1}, \mathbf{A}_{v,1})
\tag{8.35}\]</span></span></p>
<p>where</p>
<p><span class="math display">\[
\begin{align*}
\mathbf{A}_{v,1} &amp;\equiv \left( \mathbf{H}_e' \mathbf{H}_e/\sigma^2_e + \mathbf{H}_{s,1}' \mathbf{H}_{s,1}/\sigma^2_s + \theta_{uv}^2 \, \mathbf{I}/\sigma^2_u + \theta_{vv}^2 \, \mathbf{I}/\sigma^2_v +   \, \mathbf{I}/\sigma^2_{v,1}  \right)^{-1}, \\
\mathbf{b}_{v,1} &amp;\equiv \left(\mathbf{E}_{v,1}' \mathbf{H}_e/\sigma^2_e + \mathbf{S}_{v,1}' \mathbf{H}_{s,1}/\sigma^2_s +  (\mathbf{u}_2 - \mathbf{c}_{u,1})' \theta_{uv}/\sigma^2_u  \right. \\
&amp;~~~~ \left. + (\mathbf{v}_2 - \mathbf{c}_{v,1})' \theta_{vv}/\sigma^2_v + \boldsymbol{\mu}_{v,1}'/\sigma^2_{v,1}   \right)',  
\end{align*}
\]</span></p>
<p>with</p>
<p><span class="math display">\[
\begin{align*}
\mathbf{c}_{v,1} &amp;\equiv \theta_{vu} \mathbf{u}_1  + \theta_{vp} \mathbf{D}_y \mathbf{P}_1, \\
\mathbf{c}_{u,1} &amp;\equiv \theta_{uu} \mathbf{u}_1  + \theta_{up} \mathbf{D}_x \mathbf{P}_1.
\end{align*}
\]</span></p>
<ul>
<li>Full conditional distribution for <span class="math inline">\(\mathbf{v}_t,\ t=2,\ldots,T-1\)</span>:</li>
</ul>
<div class="text-center">
<p><span class="math inline">\([\mathbf{v}_t | \cdot] \propto [\)</span> <a href="#eq-Ev2" class="quarto-xref">Equation&nbsp;<span>8.23</span></a> <span class="math inline">\(]_t \times [\)</span> <a href="#eq-Sv2" class="quarto-xref">Equation&nbsp;<span>8.25</span></a> <span class="math inline">\(]_t \times [\)</span> <a href="#eq-uproc2" class="quarto-xref">Equation&nbsp;<span>8.26</span></a> <span class="math inline">\(]_{t+1} \times [\)</span> <a href="#eq-vproc2" class="quarto-xref">Equation&nbsp;<span>8.27</span></a> <span class="math inline">\(]_{t+1} \times [\)</span> <a href="#eq-vproc2" class="quarto-xref">Equation&nbsp;<span>8.27</span></a> <span class="math inline">\(]_{t}\)</span></p>
</div>
<p><span id="eq-FCvt2"><span class="math display">\[
\mathbf{v}_t | \cdot \sim Gau(\mathbf{A}_{v,t} \mathbf{b}_{v,t}, \mathbf{A}_{v,t})
\tag{8.36}\]</span></span></p>
<p>where</p>
<p><span class="math display">\[
\begin{align*}
\mathbf{A}_{v,t} \equiv &amp;\left( \mathbf{H}_e' \mathbf{H}_e/\sigma^2_e + \mathbf{H}_{s,t}' \mathbf{H}_{s,t}/\sigma^2_s + \theta_{uv}^2 \, \mathbf{I}/\sigma^2_u + \theta_{vv}^2 \, \mathbf{I}/\sigma^2_v +  \, \mathbf{I}/\sigma^2_{v}  \right)^{-1}, \\
\mathbf{b}_{v,t} \equiv &amp;(\mathbf{E}_{v,t}' \mathbf{H}_e/\sigma^2_e + \mathbf{S}_{v,t}' \mathbf{H}_{s,t}/\sigma^2_s +  (\mathbf{u}_{t+1} - \mathbf{c}_{u,t})' \theta_{uv}/\sigma^2_u  + (\mathbf{v}_{t+1} - \mathbf{c}_{v,t})' \theta_{vv}/\sigma^2_v \\ &amp;+  (\mathbf{c}_{v,t-1} + \theta_{vv} \mathbf{v}_{t-1})'/\sigma^2_v  )',  
\end{align*}
\]</span></p>
<p>with</p>
<p><span class="math display">\[
\begin{align*}
\mathbf{c}_{u,t} &amp;\equiv \theta_{uu} \mathbf{u}_t  + \theta_{up} \mathbf{D}_x \mathbf{P}_t,\\
\mathbf{c}_{v,t} &amp;\equiv \theta_{vu} \mathbf{u}_t + \theta_{vp} \mathbf{D}_y \mathbf{P}_t,\\
\mathbf{c}_{v,t-1} &amp;\equiv \theta_{vu} \mathbf{u}_{t-1} + \theta_{vp} \mathbf{D}_y \mathbf{P}_{t-1}.
\end{align*}
\]</span></p>
<ul>
<li>Full conditional distribution for <span class="math inline">\(\mathbf{v}_T\)</span>:</li>
</ul>
<div class="text-center">
<p><span class="math inline">\([\mathbf{v}_T | \cdot] \propto [\)</span> <a href="#eq-Ev2" class="quarto-xref">Equation&nbsp;<span>8.23</span></a> <span class="math inline">\(]_T \times [\)</span> <a href="#eq-Sv2" class="quarto-xref">Equation&nbsp;<span>8.25</span></a> <span class="math inline">\(]_T \times [\)</span> <a href="#eq-vproc2" class="quarto-xref">Equation&nbsp;<span>8.27</span></a> <span class="math inline">\(]_{T}\)</span></p>
</div>
<p><span id="eq-FCvT2"><span class="math display">\[
\mathbf{v}_T | \cdot \sim Gau(\mathbf{A}_{v,T} \mathbf{b}_{v,T}, \mathbf{A}_{v,T})
\tag{8.37}\]</span></span></p>
<p>where</p>
<p><span class="math display">\[
\mathbf{A}_{v,T} \equiv \left( \mathbf{H}_e' \mathbf{H}_e/\sigma^2_e + \mathbf{H}_{s,T}' \mathbf{H}_{s,T}/\sigma^2_s +  \, \mathbf{I}/\sigma^2_{v}  \right)^{-1},
\]</span></p>
<p><span class="math display">\[
\mathbf{b}_{v,T} \equiv (\mathbf{E}_{v,T}' \mathbf{H}_e/\sigma^2_e + \mathbf{S}_{v,T}' \mathbf{H}_{s,T}/\sigma^2_s +   (\mathbf{c}_{v,T-1} + \theta_{vv} \mathbf{v}_{T-1})'/\sigma^2_v  )',
\]</span></p>
<p>with</p>
<p><span class="math display">\[
\mathbf{c}_{v,T-1} \equiv \theta_{vu} \mathbf{u}_{T-1} + \theta_{vp} \mathbf{D}_y \mathbf{P}_{T-1}.
\]</span></p>
<ul>
<li>Full conditional distribution for <span class="math inline">\(\theta_{uu}\)</span>:</li>
</ul>
<div class="text-center">
<p><span class="math inline">\([\theta_{uu} | \cdot] \propto \prod_{t=1}^{T-1} [\)</span> <a href="#eq-uproc2" class="quarto-xref">Equation&nbsp;<span>8.26</span></a> <span class="math inline">\(]_{t+1} \times [\)</span> <a href="#eq-theta_ab2" class="quarto-xref">Equation&nbsp;<span>8.30</span></a> <span class="math inline">\(]_{(uu)}\)</span></p>
</div>
<p><span id="eq-FCthuu2"><span class="math display">\[
\theta_{uu} | \cdot \sim Gau(A_{uu} b_{uu}, A_{uu})
\tag{8.38}\]</span></span></p>
<p>where</p>
<p><span class="math display">\[
A_{uu} \equiv \left( \sum_{t=1}^{T-1} \mathbf{u}_t' \mathbf{u}_t /\sigma^2_{u} + 1/\sigma^2_{uu} \right)^{-1},
\]</span></p>
<p><span class="math display">\[
b_{uu} \equiv  \sum_{t=1}^{T-1} (\mathbf{u}_{t+1} - \mathbf{k}_{v,t})' \mathbf{u}_t /\sigma^2_u + \mu_{uu}/\sigma^2_{uu},
\]</span></p>
<p>with</p>
<p><span class="math display">\[
\mathbf{k}_{v,t} \equiv \theta_{uv} \mathbf{v}_t + \theta_{up} \mathbf{D}_x \mathbf{P}_t.
\]</span></p>
<ul>
<li>Full conditional distribution for <span class="math inline">\(\theta_{vv}\)</span>:</li>
</ul>
<div class="text-center">
<p><span class="math inline">\([\theta_{vv} | \cdot] \propto \prod_{t=1}^{T-1} [\)</span> <a href="#eq-vproc2" class="quarto-xref">Equation&nbsp;<span>8.27</span></a> <span class="math inline">\(]_{t+1} \times [\)</span> <a href="#eq-theta_ab2" class="quarto-xref">Equation&nbsp;<span>8.30</span></a> <span class="math inline">\(]_{(vv)}\)</span></p>
</div>
<p><span id="eq-FCthvv2"><span class="math display">\[
\theta_{vv} | \cdot \sim Gau(A_{vv} b_{vv}, A_{vv})
\tag{8.39}\]</span></span></p>
<p>where</p>
<p><span class="math display">\[
A_{vv} \equiv \left( \sum_{t=1}^{T-1} \mathbf{v}_t' \mathbf{v}_t /\sigma^2_{v} + 1/\sigma^2_{vv} \right)^{-1},
\]</span></p>
<p><span class="math display">\[
b_{vv} \equiv  \sum_{t=1}^{T-1} (\mathbf{v}_{t+1} - \mathbf{k}_{u,t})' \mathbf{v}_t /\sigma^2_v + \mu_{vv}/\sigma^2_{vv},
\]</span></p>
<p>with</p>
<p><span class="math display">\[
\mathbf{k}_{u,t} \equiv \theta_{vu} \mathbf{u}_t + \theta_{vp} \mathbf{D}_y \mathbf{P}_t.
\]</span></p>
<ul>
<li>Full conditional distribution for <span class="math inline">\(\theta_{uv}\)</span>:</li>
</ul>
<div class="text-center">
<p><span class="math inline">\([\theta_{uv} | \cdot] \propto \prod_{t=1}^{T-1} [\)</span> <a href="#eq-uproc2" class="quarto-xref">Equation&nbsp;<span>8.26</span></a> <span class="math inline">\(]_{t+1} \times [\)</span> <a href="#eq-theta_ab2" class="quarto-xref">Equation&nbsp;<span>8.30</span></a> <span class="math inline">\(]_{(uv)}\)</span></p>
</div>
<p><span id="eq-FCthuv2"><span class="math display">\[
\theta_{uv} | \cdot \sim Gau(A_{uv} b_{uv}, A_{uv})
\tag{8.40}\]</span></span></p>
<p>where</p>
<p><span class="math display">\[
A_{uv} \equiv \left( \sum_{t=1}^{T-1} \mathbf{v}_t' \mathbf{v}_t /\sigma^2_{u} + 1/\sigma^2_{uv} \right)^{-1},
\]</span></p>
<p><span class="math display">\[
b_{uv} \equiv  \sum_{t=1}^{T-1} (\mathbf{u}_{t+1} - \mathbf{k}_{u,t})' \mathbf{v}_t /\sigma^2_u + \mu_{uv}/\sigma^2_{uv},
\]</span></p>
<p>with</p>
<p><span class="math display">\[
\mathbf{k}_{u,t} \equiv \theta_{uu} \mathbf{u}_t + \theta_{up} \mathbf{D}_x \mathbf{P}_t.
\]</span></p>
<ul>
<li>Full conditional distribution for <span class="math inline">\(\theta_{vu}\)</span>:</li>
</ul>
<div class="text-center">
<p><span class="math inline">\([\theta_{vu} | \cdot] \propto \prod_{t=1}^{T-1} [\)</span> <a href="#eq-vproc2" class="quarto-xref">Equation&nbsp;<span>8.27</span></a> <span class="math inline">\(]_{t+1} \times [\)</span> <a href="#eq-theta_ab2" class="quarto-xref">Equation&nbsp;<span>8.30</span></a> <span class="math inline">\(]_{(vu)}\)</span></p>
</div>
<p><span id="eq-FCthvu2"><span class="math display">\[
\theta_{vu} | \cdot \sim Gau(A_{vu} b_{vu}, A_{vu})
\tag{8.41}\]</span></span></p>
<p>where</p>
<p><span class="math display">\[
A_{vu} \equiv \left( \sum_{t=1}^{T-1} \mathbf{u}_t' \mathbf{u}_t /\sigma^2_{v} + 1/\sigma^2_{vu} \right)^{-1},
\]</span></p>
<p><span class="math display">\[
b_{vu} \equiv  \sum_{t=1}^{T-1} (\mathbf{v}_{t+1} - \mathbf{k}_{v,t})' \mathbf{u}_t /\sigma^2_v + \mu_{vu}/\sigma^2_{vu},
\]</span></p>
<p>with</p>
<p><span class="math display">\[
\mathbf{k}_{v,t} \equiv \theta_{vv} \mathbf{v}_t + \theta_{vp} \mathbf{D}_y \mathbf{P}_t.
\]</span></p>
<ul>
<li>Full conditional distribution for <span class="math inline">\(\theta_{up}\)</span>:</li>
</ul>
<div class="text-center">
<p><span class="math inline">\([\theta_{up} | \cdot] \propto \prod_{t=1}^{T-1} [\)</span> <a href="#eq-uproc2" class="quarto-xref">Equation&nbsp;<span>8.26</span></a> <span class="math inline">\(]_{t+1} \times [\)</span> <a href="#eq-theta_ab2" class="quarto-xref">Equation&nbsp;<span>8.30</span></a> <span class="math inline">\(]_{(up)}\)</span></p>
</div>
<p><span id="eq-FCthup2"><span class="math display">\[
\theta_{up} | \cdot \sim Gau(A_{up} b_{up}, A_{up})
\tag{8.42}\]</span></span></p>
<p>where</p>
<p><span class="math display">\[
A_{up} \equiv \left( \sum_{t=1}^{T-1} (\mathbf{D}_x \mathbf{P}_t)'  (\mathbf{D}_x \mathbf{P}_t) /\sigma^2_{u} + 1/\sigma^2_{up} \right)^{-1},
\]</span> <span class="math display">\[
b_{up} \equiv  \sum_{t=1}^{T-1} (\mathbf{u}_{t+1} - \mathbf{k}_{u,t})' \mathbf{D}_x \mathbf{P}_t /\sigma^2_u + \mu_{up}/\sigma^2_{up},
\]</span></p>
<p>with</p>
<p><span class="math display">\[
\mathbf{k}_{u,t} \equiv \theta_{uu} \mathbf{u}_t + \theta_{uv} \mathbf{v}_t.
\]</span></p>
<ul>
<li>Full conditional distribution for <span class="math inline">\(\theta_{vp}\)</span>:</li>
</ul>
<div class="text-center">
<p><span class="math inline">\([\theta_{vp} | \cdot] \propto \prod_{t=1}^{T-1} [\)</span> <a href="#eq-vproc2" class="quarto-xref">Equation&nbsp;<span>8.27</span></a> <span class="math inline">\(]_{t+1} \times [\)</span> <a href="#eq-theta_ab2" class="quarto-xref">Equation&nbsp;<span>8.30</span></a> <span class="math inline">\(]_{(vp)}\)</span></p>
</div>
<p><span id="eq-FCthvp2"><span class="math display">\[
\theta_{vp} | \cdot \sim Gau(A_{vp} b_{vp}, A_{vp})
\tag{8.43}\]</span></span></p>
<p>where</p>
<p><span class="math display">\[
A_{vp} \equiv \left( \sum_{t=1}^{T-1} (\mathbf{D}_y \mathbf{P}_t)'  (\mathbf{D}_y \mathbf{P}_t) /\sigma^2_{v} + 1/\sigma^2_{vp} \right)^{-1},
\]</span> <span class="math display">\[
b_{vp} \equiv  \sum_{t=1}^{T-1} (\mathbf{v}_{t+1} - \mathbf{k}_{v,t})' \mathbf{D}_y \mathbf{P}_t /\sigma^2_v + \mu_{vp}/\sigma^2_{vp},
\]</span></p>
<p>with</p>
<p><span class="math display">\[
\mathbf{k}_{v,t} \equiv \theta_{vv} \mathbf{u}_t + \theta_{vu} \mathbf{u}_t.
\]</span></p>
<ul>
<li>Full conditional distribution for <span class="math inline">\(\sigma^2_u\)</span>:</li>
</ul>
<div class="text-center">
<p><span class="math inline">\([\sigma^2_u | \cdot] \propto \prod_{t=1}^{T-1} [\)</span> <a href="#eq-uproc2" class="quarto-xref">Equation&nbsp;<span>8.26</span></a> <span class="math inline">\(]_{t+1} \times [\)</span> <a href="#eq-sig2a2" class="quarto-xref">Equation&nbsp;<span>8.31</span></a> <span class="math inline">\(]_{(u)}\)</span></p>
</div>
<p><span id="eq-FCs2u2"><span class="math display">\[
\sigma^2_u | \cdot \sim IG(q_{\mathrm{new},u},r_{\mathrm{new},u})
\tag{8.44}\]</span></span></p>
<p>where</p>
<p><span class="math display">\[
q_{\mathrm{new},u} = q_u + (T-1)n_g /2,  
\]</span> <span class="math display">\[
r_{\mathrm{new},u} = \left(\frac{1}{r_u} + \frac{1}{2} \sum_{t=1}^{T-1} (\mathbf{u}_{t+1} - \mathbf{k}_{u,t})' (\mathbf{u}_{t+1} - \mathbf{k}_{u,t})  \right)^{-1},
\]</span></p>
<p>with</p>
<p><span class="math display">\[
\mathbf{k}_{u,t} \equiv \theta_{uu} \mathbf{u}_t + \theta_{uv} \mathbf{v}_t + \theta_{up} \mathbf{D}_x \mathbf{P}_t.
\]</span></p>
<ul>
<li>Full conditional distribution for <span class="math inline">\(\sigma^2_v\)</span>:</li>
</ul>
<div class="text-center">
<p><span class="math inline">\([\sigma^2_v | \cdot] \propto \prod_{t=1}^{T-1} [\)</span> <a href="#eq-vproc2" class="quarto-xref">Equation&nbsp;<span>8.27</span></a> <span class="math inline">\(]_{t+1} \times [\)</span> <a href="#eq-sig2a2" class="quarto-xref">Equation&nbsp;<span>8.31</span></a> <span class="math inline">\(]_{(v)}\)</span></p>
</div>
<p><span id="eq-FCs2v2"><span class="math display">\[
\sigma^2_v | \cdot \sim IG(q_{\mathrm{new},v},r_{\mathrm{new},v})
\tag{8.45}\]</span></span></p>
<p>where</p>
<p><span class="math display">\[
q_{\mathrm{new},v} = q_v + (T-1)n_g /2,  
\]</span> <span class="math display">\[
r_{\mathrm{new},v} = \left(\frac{1}{r_v} + \frac{1}{2} \sum_{t=1}^{T-1} (\mathbf{v}_{t+1} - \mathbf{k}_{v,t})' (\mathbf{v}_{t+1} - \mathbf{k}_{v,t})  \right)^{-1},
\]</span></p>
<p>with</p>
<p><span class="math display">\[
\mathbf{k}_{v,t} \equiv \theta_{vv} \mathbf{v}_t + \theta_{vu} \mathbf{u}_t + \theta_{vp} \mathbf{D}_y \mathbf{P}_t.
\]</span></p>
<section id="implementation-in-r" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="implementation-in-r">Implementation in <code>R</code></h3>
<section id="r-preliminaries" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="r-preliminaries"><code>R</code> Preliminaries</h4>
<p>We will need the <strong>Matrix</strong> package because the BHM Gibbs sampler uses sparse matrices, and <strong>ggquiver</strong> and <strong>ggmap</strong> to make “quiver” plots of the wind vectors on a map of the Mediterranean region.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"Matrix"</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggmap"</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggquiver"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"STRbook"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The functions needed for this case study are provided with <strong>STRbook</strong>. Two functions designed to work for this specific application are <code>Medwind_BHM_preproc</code> and <code>Medwind_BHM</code>, which we describe in more detail below. Their purpose is to show that this realistic, complex, science-motivated spatio-temporal BHM can be analyzed in <code>R</code> using the dynamical approach described in Chapter 5. It is worth browsing through the code of these functions to see how it is implemented (visit <a href="https://github.com/andrewzm/STRbook">https://github.com/andrewzm/STRbook</a>).</p>
</section>
<section id="preprocessing-the-data-and-model-setup" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="preprocessing-the-data-and-model-setup">Preprocessing the Data and Model Setup</h4>
<p>The function <code>Medwind_BHM_preproc</code> is a preprocessor function that takes the following as arguments:</p>
<ul>
<li><code>Edat</code>: A list of four items
<ul>
<li><code>ECMWFxylocs</code>: Data frame containing the <span class="math inline">\((x,y)\)</span> coordinates on which the wind vectors and pressures are defined</li>
<li><code>EUdat</code>: Data frame containing the east–west (<span class="math inline">\(u\)</span>) component of the ECMWF wind vector (in units of m/s) in time-wide format</li>
<li><code>EVdat</code>: Data frame containing the north–south (<span class="math inline">\(v\)</span>) component of the ECMWF wind vector (in units of m/s) in time-wide format</li>
<li><code>EPdat</code>: Data frame containing the ECMWF atmospheric pressure (in pascals (Pa)) in time-wide format.</li>
</ul></li>
<li><code>Sdat</code>: A list of three items
<ul>
<li><code>Sxylocs</code>: A list of items (one per time point) containing the spatial locations (for each time point) of the scatterometer data</li>
<li><code>SUdat</code>: The east–west (<span class="math inline">\(u\)</span>) component of the QuikSCAT wind vector (in units of m/s)</li>
<li><code>SVdat</code>: The north–south (<span class="math inline">\(v\)</span>) component of the QuikSCAT wind vector (in units of m/s)</li>
</ul></li>
<li><code>Predlocs</code>: Data frame containing the <span class="math inline">\((x,y)\)</span> coordinates of the spatial prediction grid.</li>
<li><code>Inparm</code>: Other parameters for the Gibbs sampler, discussed further below.</li>
</ul>
<p>The data objects required for this application, <code>Edat</code>, <code>Sdat</code>, and <code>Predlocs</code>, can be loaded from <strong>STRbook</strong> as follows:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"Medwind_data"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The data here correspond to 28 time periods from 00:00 UTC on 29 January 2005 to 18:00 UTC on 04 February 2005 (every 6 hours). The ECMWF analysis winds and pressure are on a <span class="math inline">\(0.5^\circ \times 0.5^\circ\)</span> grid and the QuikSCAT scatterometer winds are polar-orbiting satellite observations at a finer resolution <span class="citation" data-cites="milliff2011ocean">(see the description in <a href="references.html#ref-milliff2011ocean" role="doc-biblioref">Milliff et al. 2011</a>)</span>. There are typically no QuikSCAT observations in the prediction domain considered here at 00:00 UTC and 12:00 UTC. The prediction grid consists of 1035 (<span class="math inline">\(n_y = 23\)</span>, <span class="math inline">\(n_x = 45\)</span>) grid locations with a <span class="math inline">\(0.5^\circ\)</span> spacing; this prediction grid coincides with the interior grid points of the ECMWF domain; see <a href="Chapter2.html#sec-STdata" class="quarto-xref"><span>Section 2.1</span></a> for more details.</p>
<p>The preprocessor argument <code>Inparm</code> is a list of several parameters. These parameters are associated with the prediction grid, the distance to search for data near prediction-grid locations, and hyperparameters for the parameter model (prior) distributions. In particular, the item <code>gspdeg</code> is the prediction-grid spacing in degrees, and <code>srad</code> and <code>erad</code> correspond to the distance (in degrees) to search for ECMWF and QuikSCAT data locations, respectively, centered on a prediction-grid location. So <code>srad = 0.5</code> would mean that we would identify all QuikSCAT observations within 0.25 degrees of a prediction-grid location. The values of <code>hx</code> and <code>hy</code> correspond to the average longitudinal and latitudinal spacing (in meters), respectively, between the prediction-grid locations. With regard to the fixed hyperparameters in <code>Inparm</code>, the variables <code>s2e</code> and <code>s2s</code> are the measurement-error variances for the ECMWF and QuikSCAT wind data (<span class="math inline">\(\sigma^2_e\)</span> and <span class="math inline">\(\sigma^2_s\)</span>), respectively, as given in the data-model equations <a href="#eq-Eu2" class="quarto-xref">Equation&nbsp;<span>8.22</span></a>–<a href="#eq-Sv2" class="quarto-xref">Equation&nbsp;<span>8.25</span></a>. These are assumed to be known <span class="citation" data-cites="milliff2011ocean">(<a href="references.html#ref-milliff2011ocean" role="doc-biblioref">Milliff et al. 2011</a>)</span>. The variables <code>mu_pri</code> and <code>s2_pri</code> corresponding to the normal-distribution-prior mean (<span class="math inline">\(\mu_{ab}\)</span>) and variance (<span class="math inline">\(\sigma^2_{ab}\)</span>) for the <span class="math inline">\(\theta\)</span> parameters, given in model <a href="#eq-theta_ab2" class="quarto-xref">Equation&nbsp;<span>8.30</span></a>, are also fixed (at <span class="math inline">\(0\)</span> and <span class="math inline">\(10^6\)</span>, respectively, corresponding to a vague prior for <span class="math inline">\(\theta_{ab}\)</span>). <code>IGshape</code> and <code>IGrate</code> are the prior shape (<span class="math inline">\(q_a\)</span>) and rate (<span class="math inline">\(r_a\)</span>) parameters, respectively, for an inverse gamma prior on the process-model error variances given in <a href="#eq-sig2a2" class="quarto-xref">Equation&nbsp;<span>8.31</span></a>; these are fixed at 1 and 1, respectively, corresponding to a vague prior for <span class="math inline">\(\sigma^2_a\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="do">##     parameters to control the grid, data search, and priors</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  preprocInput <span class="ot">=</span> <span class="fu">list</span>(</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">gspdeg =</span> .<span class="dv">5</span>,</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">srad =</span> .<span class="dv">5</span>,</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">erad =</span> .<span class="dv">5</span>,</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">hx =</span> <span class="dv">2</span><span class="sc">*</span><span class="fl">19.42865</span><span class="sc">*</span><span class="dv">1000</span>,</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">hy =</span> <span class="dv">2</span><span class="sc">*</span><span class="fl">27.75</span><span class="sc">*</span><span class="dv">1000</span>,</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">s2s =</span> <span class="dv">1</span>,</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">s2e =</span> <span class="dv">10</span>,</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">mu_pri =</span> <span class="dv">0</span>,</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">s2_pri =</span> <span class="dv">10</span><span class="sc">^</span><span class="dv">6</span>,</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">IGshape =</span> <span class="dv">1</span>,</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">IGrate =</span> <span class="dv">1</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The function <code>Medwind_BHM_preproc</code> takes the data and other parameters and then builds the data-model incidence matrices (<span class="math inline">\(\mathbf{H}_e\)</span>, <span class="math inline">\(\mathbf{H}_{s,t}\)</span>) given in equations <a href="#eq-Eu2" class="quarto-xref">Equation&nbsp;<span>8.22</span></a>–<a href="#eq-Sv2" class="quarto-xref">Equation&nbsp;<span>8.25</span></a>, and the difference operator matrices (<span class="math inline">\(\mathbf{D}_x\)</span>, <span class="math inline">\(\mathbf{D}_y\)</span>) given in equations <a href="#eq-Ueq1" class="quarto-xref">Equation&nbsp;<span>8.20</span></a> and <a href="#eq-Veq1" class="quarto-xref">Equation&nbsp;<span>8.21</span></a>, respectively. The returned list (denoted below as <code>Mpre</code>) contains the lists <code>Mdata</code> (data), <code>Mgrid</code> (grid), <code>Mpriors</code> (prior hyperparameters), and <code>Mstrt</code> (MCMC starting values). This list is used in the Gibbs sampler given in the next section. Recall that the Gibbs sampler is an MCMC algorithm that produces samples from the posterior distribution of all the “unknowns” given the data.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>Mpre <span class="ot">&lt;-</span> <span class="fu">Medwind_BHM_preproc</span>(<span class="at">Edat =</span> Edat,</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>                            <span class="at">Sdat =</span> Sdat,</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>                            <span class="at">Predlocs =</span> Predlocs,</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>                            <span class="at">Inparm =</span> preprocInput)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="running-the-gibbs-sampler" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="running-the-gibbs-sampler">Running the Gibbs Sampler</h4>
<p>This section provides the commands necessary to implement the Gibbs sampler presented in <a href="#nte-algorithm-MedWindGibbsSampler" class="quarto-xref">Note&nbsp;<span>8.4</span></a>. We specify the parameters that control the number of Gibbs sampler iterations (<code>ngibbs</code>), the number of burn-in samples (<code>nburn</code>), and the number of iterations to save in memory (<code>nreal</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>GibbsInput <span class="ot">=</span> <span class="fu">list</span>(<span class="at">ngibbs =</span> <span class="dv">10000</span>,</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>                  <span class="at">nburn =</span> <span class="dv">1000</span>,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>                  <span class="at">nreal =</span> <span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The Gibbs sampler for this problem takes the arguments <code>GibbsInput</code>, defined as above, and the output of the pre-processor, <code>Mpre</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>) <span class="co"># ensure reproducibility</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>Mout <span class="ot">&lt;-</span> <span class="fu">Medwind_BHM</span>(GibbsInput, Mpre)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The algorithm can take quite a long time to run in order to obtain a reasonable number of iterations. For this Lab, the output can be loaded directly from <strong>STRbook</strong>, if desired, as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"Medwind_Gibbs_output"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The Gibbs sampler function <code>Medwind_BHM</code> returns a list that includes posterior means, posterior standard deviations, and <code>nreal</code> realizations for the <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> wind components, as well as all of the iterations for the <span class="math inline">\(\theta\)</span> parameters and the process-model variances. Specifically, in this case, the list contains the following items:</p>
<ul>
<li><code>uS</code>: posterior mean of the <span class="math inline">\(u\)</span> components (1035 locations <span class="math inline">\(\times\)</span> 28 time points)</li>
<li><code>vS</code>: posterior mean of the <span class="math inline">\(v\)</span> components (1035 locations <span class="math inline">\(\times\)</span> 28 time points)</li>
<li><code>uSTD</code>: posterior standard deviation of the <span class="math inline">\(u\)</span> components (1035 locations <span class="math inline">\(\times\)</span> 28 time points)</li>
<li><code>vSTD</code>: posterior standard deviation of the <span class="math inline">\(v\)</span> components (1035 locations <span class="math inline">\(\times\)</span> 28 time points)</li>
<li><code>uSreal</code>: <code>nreal</code> realizations of all 1035 <span class="math inline">\(\times\)</span> 28 locations/time points for the <span class="math inline">\(u\)</span> components (list)</li>
<li><code>vSreal</code>: <code>nreal</code> realizations of all 1035 <span class="math inline">\(\times\)</span> 28 locations/time points for the <span class="math inline">\(v\)</span> components (list)</li>
<li><code>theta_xxS</code> (<code>xx = uu,vv,uv,vu,up,vp</code>): <code>ngibbs</code> samples for the <span class="math inline">\(\theta\)</span> parameters</li>
<li><code>s2uS,s2vS</code>: <code>ngibbs</code> samples for the variance parameters.</li>
</ul>
<p>We reiterate that both the pre-processor and the Gibbs sampler functions are specifically designed for this BHM fitted to the Mediterranean winds data. They would need substantial modification for different BHMs fitted to different data sets using different space-time grids. Advanced readers could examine and modify the code contained in the <strong>STRbook</strong> package for their applications.</p>
</section>
<section id="examining-the-model-output" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="examining-the-model-output">Examining the Model Output</h4>
<p>It is customary to plot the Gibbs sampler output against iteration number of the Gibbs sampler, to provide visual evidence that the samples have reasonably converged. More formal diagnostics for MCMC convergence can be found in the <strong>coda</strong> package. In <a href="#fig-BHM_trace" class="quarto-xref">Figure&nbsp;<span>8.1</span></a>, we plot the post burn-in samples for <span class="math inline">\(\theta_{up}\)</span> and <span class="math inline">\(\sigma^2_{u}\)</span> as a demonstration of the code and the graphics.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>indx <span class="ot">&lt;-</span> (GibbsInput<span class="sc">$</span>nburn<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>GibbsInput<span class="sc">$</span>ngibbs <span class="co">#plot post "burn-in"</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="fu">data.frame</span>(<span class="at">indx =</span> indx,</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                        <span class="at">theta_up =</span> Mout<span class="sc">$</span>theta_upS[indx]),</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>             <span class="fu">aes</span>(<span class="at">x =</span> indx,<span class="at">y =</span> theta_up)) <span class="sc">+</span> <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>              <span class="fu">ylab</span>(<span class="fu">expression</span>(theta[up])) <span class="sc">+</span> <span class="fu">theme_bw</span>()</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="fu">data.frame</span>(<span class="at">indx =</span> indx, <span class="at">s2u =</span> Mout<span class="sc">$</span>s2uS[indx]),</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>             <span class="fu">aes</span>(<span class="at">x =</span> indx,<span class="at">y =</span> s2u)) <span class="sc">+</span> <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>              <span class="fu">ylab</span>(<span class="fu">expression</span>(sigma[vu]<span class="sc">^</span><span class="dv">2</span>)) <span class="sc">+</span> <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-BHM_trace" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-BHM_trace-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/Chapter_5/BHM_trace.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-BHM_trace-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.1: Post burn-in trace plots for MCMC samples from the posterior distribution, plotted against iteration number <code>indx</code>. Top: MCMC samples for <span class="math inline">\(\theta_{up}\)</span>. Bottom: MCMC samples for <span class="math inline">\(\sigma^2_{vu}\)</span>.
</figcaption>
</figure>
</div>
<p>For inference on the model’s parameters, we are usually interested in their marginal posterior distributions. In the top-left panel of <a href="#fig-BHM_post" class="quarto-xref">Figure&nbsp;<span>8.2</span></a>, we plot the posterior distribution for <span class="math inline">\(\theta_{up}\)</span> and give the code below; coding for the other parameters in the process-model equations <a href="#eq-Ueq1" class="quarto-xref">Equation&nbsp;<span>8.20</span></a> and <a href="#eq-Veq1" class="quarto-xref">Equation&nbsp;<span>8.21</span></a> proceeds in a similar fashion.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="fu">data.frame</span>(<span class="at">theta_up =</span> Mout<span class="sc">$</span>theta_upS[indx]),</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>             <span class="fu">aes</span>(<span class="at">x =</span> theta_up)) <span class="sc">+</span> <span class="fu">geom_density</span>() <span class="sc">+</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>             <span class="fu">geom_vline</span>(<span class="fu">aes</span>(<span class="at">xintercept =</span> <span class="fu">mean</span>(theta_up)),</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>             <span class="at">color =</span> <span class="st">"red"</span>, <span class="at">linetype =</span> <span class="st">"dashed"</span>, <span class="at">size =</span> <span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>             <span class="fu">xlab</span>(<span class="fu">expression</span>(theta[up])) <span class="sc">+</span> <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-BHM_post" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-BHM_post-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/Chapter_5/BHM_post_parms.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-BHM_post-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.2: The marginal posterior distributions (after applying a kernel smoother to the MCMC samples) for the process-model parameters. The red dashed line shows the posterior mean for each distribution.
</figcaption>
</figure>
</div>
<p>Finally, the main goal in this case study was to fuse the ECMWF and QuikSCAT wind observations to generate a posterior probability distribution on wind speeds. In <a href="#fig-post_quiver14" class="quarto-xref">Figure&nbsp;<span>8.3</span></a>, we plot the posterior mean and a posterior realization quiver plot for the winds for 06:00 UTC on 01 February 2005, using the following code.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Extract mean</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>u14 <span class="ot">&lt;-</span> Mout<span class="sc">$</span>uS[, <span class="dv">14</span>]              <span class="co">#time 14 is Feb 1, 2005 06 UTC</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>v14 <span class="ot">&lt;-</span> Mout<span class="sc">$</span>vS[, <span class="dv">14</span>]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="do">## Extract realization</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>u14r <span class="ot">&lt;-</span> Mout<span class="sc">$</span>uSreal[[<span class="dv">5</span>]][, <span class="dv">14</span>]    <span class="co">#consider the 5th realization</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>v14r <span class="ot">&lt;-</span> Mout<span class="sc">$</span>vSreal[[<span class="dv">5</span>]][, <span class="dv">14</span>]</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="do">## Get map using get_map</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>lat <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">34</span>, <span class="dv">45</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>long <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">6</span>, <span class="dv">16</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>bbox <span class="ot">&lt;-</span> <span class="fu">make_bbox</span>(long, lat, <span class="at">f =</span> <span class="fl">0.05</span>)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>bb2 <span class="ot">&lt;-</span> <span class="fu">get_map</span>(bbox, <span class="at">maptype =</span> <span class="st">"watercolor"</span>, <span class="at">source =</span> <span class="st">"stamen"</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="do">## Create grid on which to plot</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>xg <span class="ot">&lt;-</span> Mpre<span class="sc">$</span>Mgrid<span class="sc">$</span>Mgridxylocs[, <span class="dv">1</span>]</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>yg <span class="ot">&lt;-</span> Mpre<span class="sc">$</span>Mgrid<span class="sc">$</span>Mgridxylocs[, <span class="dv">2</span>]</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>c2 <span class="ot">&lt;-</span>  <span class="fu">expand.grid</span>(<span class="at">x =</span> <span class="fu">seq</span>(long[<span class="dv">1</span>], long[<span class="dv">2</span>], <span class="fl">0.5</span>),</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>                   <span class="at">y =</span> <span class="fu">seq</span>(lat[<span class="dv">1</span>], lat[<span class="dv">2</span>], <span class="fl">0.5</span>))</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a><span class="do">## Plot the posterior mean and realization</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> <span class="fu">ggmap</span>(bb2) <span class="sc">+</span> <span class="fu">geom_quiver</span>(<span class="at">data =</span> c2,</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>                <span class="fu">aes</span>(<span class="at">x =</span> xg, <span class="at">y =</span> yg, <span class="at">u =</span> u14, <span class="at">v =</span> v14),</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>                <span class="at">vecsize =</span> <span class="fl">1.5</span>)</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> <span class="fu">ggmap</span>(bb2) <span class="sc">+</span> <span class="fu">geom_quiver</span>(<span class="at">data =</span> c2,</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>                <span class="fu">aes</span>(<span class="at">x =</span> xg, <span class="at">y =</span> yg, <span class="at">u =</span> u14r, <span class="at">v =</span> v14r),</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>                <span class="at">vecsize =</span> <span class="fl">1.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-post_quiver14" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-post_quiver14-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="./img/Chapter_5/BHM_post_quiver.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-post_quiver14-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.3: Quiver plots derived from the posterior distribution of winds for 06:00 UTC on 01 February 2005. Top: Posterior mean. Bottom: A single realization from the posterior distribution.
</figcaption>
</figure>
</div>
</section>
</section>
</section>
<section id="sec-QESNapp" class="level2" data-number="8.6">
<h2 data-number="8.6" class="anchored" data-anchor-id="sec-QESNapp"><span class="header-section-number">8.6</span> Case Study: Quadratic Echo State Networks for Sea Surface Temperature Long-Lead Prediction</h2>
<p>Recall from <a href="Chapter5.html#sec-nonlinearDSTMs" class="quarto-xref"><span>Section 5.4</span></a> that recurrent neural networks (RNNs) were developed in the engineering and machine-learning literature to accommodate time-dependent cycles and sequences as well as the concept of “memory” in a neural network. But, like the statistical GQN (also discussed in <a href="Chapter5.html#sec-nonlinearDSTMs" class="quarto-xref"><span>Section 5.4</span></a>), RNNs have an extremely high-dimensional parameter space and can be difficult to fit. In contrast, the echo state network (ESN) is a type of RNN that considers sparsely connected hidden layers that allow for sequential interactions, yet specifies (remarkably) most of the parameters (“weights”) to be randomly generated and then fixed, with only the parameters that connect the hidden layer to the response being estimated . We consider a modification of the ESN in this case study. Note that although the models presented here are relatively simple to implement, the notational burden and (especially) the machine-learning jargon can take some getting used to.</p>
<p>A simple representation of an ESN is given by the following hierarchical model for data vector <span class="math inline">\(\mathbf{Z}_t\)</span> (assumed to be <span class="math inline">\(m\)</span>-dimensional here):</p>
<p><span id="eq-ESNresp"><span class="math display">\[
\mathbf{Z}_t = g_o(\mathbf{V}\mathbf{h}_t),
\tag{8.46}\]</span></span></p>
<p><span id="eq-ESNhidden"><span class="math display">\[
\mathbf{h}_t = g_h(\mathbf{W}\mathbf{h}_{t-1} + \mathbf{U}\mathbf{x}_t).
\tag{8.47}\]</span></span></p>
<p>In the data model (<a href="#eq-ESNresp" class="quarto-xref">Equation&nbsp;<span>8.46</span></a>) and the process model (<a href="#eq-ESNhidden" class="quarto-xref">Equation&nbsp;<span>8.47</span></a>), <span class="math inline">\(\mathbf{h}_t\)</span> is an <span class="math inline">\(n\)</span>-dimensional vector of latent (“hidden”) states, <span class="math inline">\(\mathbf{x}_t\)</span> is a <span class="math inline">\(p\)</span>-dimensional input vector, <span class="math inline">\(\mathbf{V}\)</span> is an <span class="math inline">\(m \times n\)</span> output-parameter weight matrix, <span class="math inline">\(\mathbf{W}\)</span> is an <span class="math inline">\(n \times n\)</span> hidden-process-evolution-parameter weight matrix, <span class="math inline">\(\mathbf{U}\)</span> is an <span class="math inline">\(n \times p\)</span> input-parameter weight matrix, and <span class="math inline">\(g_o(\cdot)\)</span> and <span class="math inline">\(g_h(\cdot)\)</span> are so-called “activation functions” (e.g., identity, softmax, hyperbolic tangent). The hidden-state model <a href="#eq-ESNhidden" class="quarto-xref">Equation&nbsp;<span>8.47</span></a> is sometimes called a “reservoir.” This reservoir is key to this modeling framework in that the parameter weight matrices in <a href="#eq-ESNhidden" class="quarto-xref">Equation&nbsp;<span>8.47</span></a>, <span class="math inline">\(\mathbf{W}\)</span> and <span class="math inline">\(\mathbf{U}\)</span>, are sparse (only 1–10% of the parameters are non-zero) with non-zero elements <em>chosen at random</em> and fixed (for details, see the example that follows). This means that only the output weights (in <span class="math inline">\(\mathbf{V}\)</span>) are estimated, substantially reducing the estimation burden. In most applications, <span class="math inline">\(g_o(\cdot)\)</span> is the identity function, and <span class="math inline">\(\mathbf{V}\)</span> can be estimated with regression methods that include regularization, such as a ridge regression or a lasso penalty (see <a href="Chapter3.html#nte-technote-RidgeLassoReg" class="quarto-xref">Note&nbsp;<span>3.4</span></a>). These models work surprisingly well for forecasting central tendency and classification, but they are limited for inference and uncertainty quantification. Notice that there are no error terms in this model!</p>
<p><span class="citation" data-cites="mcdermott2017ensemble">McDermott and Wikle (<a href="references.html#ref-mcdermott2017ensemble" role="doc-biblioref">2017</a>)</span> modified the basic ESN algorithm for use with spatio-temporal data to include quadratic nonlinear outputs, so-called “embedding inputs” (see below), and reservoir parameter uncertainty by considering an ensemble (bootstrap) sample of forecasts. Their quadratic echo state network (QESN), for <span class="math inline">\(t=1,\ldots,T\)</span>, is given by:</p>
<p>Response: <span id="eq-QESNresp"><span class="math display">\[
{\mathbf{Y}}_t = {\mathbf{V}}_1 {\mathbf{h}}_t + {\mathbf{V}}_2 {\mathbf{h}}^2_t + {\boldsymbol{\epsilon}}_t, \quad \textrm{for} \quad {\boldsymbol{\epsilon}}_t \; \sim \; Gau({\mathbf{0}},\sigma^2_\epsilon \mathbf{I});
\tag{8.48}\]</span></span></p>
<p>Hidden state: <span id="eq-QESNhidden"><span class="math display">\[
{\mathbf{h}}_t = g_h\left(\frac{\nu}{|\lambda_w|}{\mathbf{W}} {\mathbf{h}}_{t-1} + {\mathbf{U}}\tilde{\mathbf{x}}_t\right);
\tag{8.49}\]</span></span></p>
<p>Parameters: <span id="eq-QESNw"><span class="math display">\[
{\mathbf{W}} = [w_{i,\ell}]_{i,\ell}: w_{i,\ell} = \gamma^w_{i,\ell} \; Unif(-a_w,a_w) + (1 - \gamma^w_{i,\ell}) \; \delta_0,
\tag{8.50}\]</span></span></p>
<p><span id="eq-QESNu"><span class="math display">\[
{\mathbf{U}} = [u_{i,j}]_{i,j}: u_{i,j} = \gamma^u_{i,j} \; Unif(-a_u,a_u) + (1 - \gamma^u_{i,j}) \; \delta_0,
\tag{8.51}\]</span></span></p>
<p><span id="eq-piw"><span class="math display">\[
\gamma_{i,\ell}^w \; \sim \; Bern(\pi_w),
\tag{8.52}\]</span></span></p>
<p><span id="eq-piu"><span class="math display">\[
\gamma_{i,j}^u \; \sim \; Bern(\pi_u)
\tag{8.53}\]</span></span></p>
<p>where <span class="math inline">\({\mathbf{Y}}_t\)</span> is the <span class="math inline">\(n_y\)</span>-dimensional response vector at time <span class="math inline">\(t\)</span>; <span class="math inline">\({\mathbf{h}}_t\)</span> is the <span class="math inline">\(n_h\)</span>-dimensional hidden-state vector; <span class="math inline">\({\mathbf{h}}^2_t\)</span> is the <span class="math inline">\(n-h\)</span>-dimensional vector where the square operation is defined elementwise;</p>
<p><span id="eq-QEQNembed"><span class="math display">\[
\tilde{\mathbf{x}}_t = [\mathbf{x}'_t,\mathbf{x}'_{t-\tau*}, \mathbf{x}'_{t- 2 \tau*},\ldots,\mathbf{x}'_{t - m \tau*}]'
\tag{8.54}\]</span></span></p>
<p>is the <span class="math inline">\(n_{\tilde{x}} = (m+1) n_x\)</span>-dimensional “embedding input” vector, containing lagged values (embeddings) of the inputs <span class="math inline">\(\{\mathbf{x}_t\}\)</span> for time periods <span class="math inline">\(t- \tau*\)</span> through <span class="math inline">\(t - m \tau*\)</span>, where the quantity <span class="math inline">\(\tau*\)</span> is the embedding lag (a positive integer, often set equal to the forecast lead time); and <span class="math inline">\(Bern(\cdot)\)</span> denotes the Bernoulli distribution. As in the basic ESN above, <span class="math inline">\(\mathbf{W}\)</span> is the <span class="math inline">\(n \times n\)</span> hidden-process-evolution weight matrix, <span class="math inline">\(\mathbf{U}\)</span> is the <span class="math inline">\(n \times p\)</span> input weight matrix, and <span class="math inline">\(\mathbf{V}_1\)</span>, <span class="math inline">\(\mathbf{V}_2\)</span> are the <span class="math inline">\(n \times n_h\)</span> linear and quadratic output weight matrices, respectively. Furthermore, <span class="math inline">\(\delta_0\)</span> is a Kronecker delta function at zero, <span class="math inline">\(\lambda_w\)</span> corresponds to the largest eigenvalue of <span class="math inline">\({\mathbf{W}}\)</span> (i.e., the “spectral radius” of <span class="math inline">\(\mathbf{W}\)</span>), and <span class="math inline">\(\nu\)</span> is a spectral-radius control parameter. The “activation function” <span class="math inline">\(g_h(\cdot)\)</span> (a hyperbolic tangent function in our application below) controls the nonlinearity of the hidden-state evolution. The only parameters that are estimated in this model are <span class="math inline">\({\boldsymbol{V}}_1\)</span>, <span class="math inline">\({\mathbf{V}}_2\)</span>, and <span class="math inline">\(\sigma^2_\epsilon\)</span> from <a href="#eq-QESNresp" class="quarto-xref">Equation&nbsp;<span>8.48</span></a>, for which we require a ridge-regression penalty parameter, <span class="math inline">\(r_v\)</span> (see <a href="Chapter3.html#nte-technote-RidgeLassoReg" class="quarto-xref">Note&nbsp;<span>3.4</span></a>). Importantly, note that the matrices <span class="math inline">\({\mathbf{W}}\)</span> and <span class="math inline">\({\mathbf{U}}\)</span> are simulated from mixture distributions of small values (uniformly sampled in the range <span class="math inline">\((-a_w,a_w)\)</span> and <span class="math inline">\((-a_u,a_u)\)</span>, respectively) with, respectively, <span class="math inline">\((1-\pi_w)\)</span> and <span class="math inline">\((1-\pi_u)\)</span> elements set equal to zero on average. After being sampled, these parameters are assumed to be fixed and known. Typically, these weight matrices are very sparse (e.g., of the order of <span class="math inline">\(1\)</span>–<span class="math inline">\(10\%\)</span> non-zeros). The hyperparameters, <span class="math inline">\(\{\nu, n_h, r_v, \pi_w, \pi_u, a_w, a_u\}\)</span>, are usually chosen by cross-validation.</p>
<p>As is the case in most traditional ESN applications, the QESN model does not have an explicit mechanism to quantify uncertainty in the process or in the parameters. This is a bit troubling given that the reservoir weight matrices <span class="math inline">\(\mathbf{W}\)</span> and <span class="math inline">\(\mathbf{U}\)</span> are not estimated, but are chosen at random. We would expect that the model is likely to behave differently with a different set of weight matrices. This is especially true when the number of hidden units is fairly small. Although traditional ESN models typically have a very large number of hidden units, which tends to give more stable predictions, it can be desirable to have many different forecasts using a smaller number of hidden units. This provides flexibility in that it prevents overfitting, allows the various forecasts to behave as a “committee of relatively weak learners,” and gives a more realistic sense of the prediction uncertainty for out-of-sample forecasts. Thus, we could generate an ensemble or bootstrap sample of forecasts. As shown in <span class="citation" data-cites="mcdermott2017ensemble">McDermott and Wikle (<a href="references.html#ref-mcdermott2017ensemble" role="doc-biblioref">2017</a>)</span>, this ensemble approach can be implemented straightforwardly with the QESN model using the algorithm in <a href="#nte-algorithm-E-QESN" class="quarto-xref">Note&nbsp;<span>8.5</span></a>.</p>
<div id="nte-algorithm-E-QESN" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;8.5: Ensemble QESN Algorithm
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>Initialize</strong>: Select tuning parameters <span class="math inline">\(\{ν, n_h, r_v, π_w, π_u, a_w, a_u\}\)</span> (e.g., by cross-validation with a standalone QESN)</p>
<p><strong>for</strong> <span class="math inline">\(k = 1\)</span> to <span class="math inline">\(K\)</span> <strong>do</strong></p>
<ol type="1">
<li><p>Simulate <span class="math inline">\(\mathbf{W}^{(k)}\)</span>, <span class="math inline">\(\mathbf{U}^{(k)}\)</span> using <a href="#eq-QESNw" class="quarto-xref">Equation&nbsp;<span>8.50</span></a> and <a href="#eq-QESNu" class="quarto-xref">Equation&nbsp;<span>8.51</span></a> and initialize <span class="math inline">\({\mathbf{h}}_1^{(k)}\)</span></p></li>
<li><p>Calculate <span class="math inline">\(\{{\mathbf{h}}_t^{(k)}: t=2,...,T\}\)</span> using <a href="#eq-QESNhidden" class="quarto-xref">Equation&nbsp;<span>8.49</span></a></p></li>
<li><p>Use ridge regression to estimate <span class="math inline">\(\mathbf{V}^{(k)}_1, \mathbf{V}^{(k)}_2\)</span>, and <span class="math inline">\(\sigma^2_\epsilon\)</span></p></li>
<li><p>Calculate out-of-sample forecasts <span class="math inline">\(\{\widehat{\mathbf{Y}}^{(k)}_t: t=T+1,...,T+\tau\}\)</span>, where <span class="math inline">\(\tau\)</span> is the forecast lead time (requires calculating <span class="math inline">\(\{\widehat{{\mathbf{h}}}^{(k)}_t: t=T+1,...,T+\tau\}\)</span> from <a href="#eq-QESNhidden" class="quarto-xref">Equation&nbsp;<span>8.49</span></a>)</p></li>
</ol>
<p><strong>end for</strong></p>
<p>Use ensemble of forecasts <span class="math inline">\(\{\widehat{\mathbf{Y}}^{(k)}_t: t=T+1,...,T+\tau; k = 1,...,K\}\)</span> to calculate moments, prediction intervals, etc.</p>
</div>
</div>
<section id="implementation-in-r-1" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="implementation-in-r-1">Implementation in R</h3>
<p>In what follows, we provide a demonstration of the ensemble QESN model applied to long-lead forecasting of sea-surface temperature using the SST data set.</p>
<section id="ensemble-qesn-model-data-preparation" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="ensemble-qesn-model-data-preparation">Ensemble QESN Model Data Preparation</h4>
<p>To prepare the data, we need <strong>ggplot2</strong>, <strong>dplyr</strong>, <strong>STRbook</strong>, and <strong>tidyr</strong>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggplot2"</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"dplyr"</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"STRbook"</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"tidyr"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The functions needed for this case study are provided with <strong>STRbook</strong>. Our purpose here is to show that this nonlinear DSTM can be implemented in <code>R</code> fairly easily. If readers are interested in adapting these functions to their own applications, it is worth browsing through the functions to see how the code is implemented (visit <a href="https://github.com/andrewzm/STRbook">https://github.com/andrewzm/STRbook</a>).</p>
<p>We first load the SST data set. This time we shall use the data up to October 1996 as training data and perform out-of-sample six-month forecasts from April 1997 to July 1999.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"SSTlandmask"</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"SSTlonlat"</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"SSTdata"</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>delete_rows <span class="ot">&lt;-</span> <span class="fu">which</span>(SSTlandmask <span class="sc">==</span> <span class="dv">1</span>)   <span class="co"># find land values</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>SSTdataA <span class="ot">&lt;-</span> SSTdata[<span class="sc">-</span>delete_rows, ]      <span class="co"># remove land values</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In this application, we shall evaluate the forecast in terms of the time series corresponding to the average of the SST anomalies in the so-called Niño 3.4 region (defined to be the region of the tropical Pacific Ocean contained by <span class="math inline">\(5^\circ\)</span>S–<span class="math inline">\(5^\circ\)</span>N, <span class="math inline">\(170^\circ\)</span>W–<span class="math inline">\(120^\circ\)</span>W).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="do">## find grid locations corresponding to Nino 3.4 region;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="do">## note, 190 - 240 deg E longitude corresponds</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="do">## to 170 - 120 deg W longitude</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>nino34Index <span class="ot">&lt;-</span> <span class="fu">which</span>(SSTlonlat[,<span class="dv">2</span>] <span class="sc">&lt;=</span> <span class="dv">5</span> <span class="sc">&amp;</span> SSTlonlat[, <span class="dv">2</span>] <span class="sc">&gt;=</span> <span class="sc">-</span><span class="dv">5</span> <span class="sc">&amp;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>                       SSTlonlat[,<span class="dv">1</span>] <span class="sc">&gt;=</span> <span class="dv">190</span> <span class="sc">&amp;</span> SSTlonlat[, <span class="dv">1</span>] <span class="sc">&lt;=</span> <span class="dv">240</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The object <code>SSTdataA</code> is a 2261 × 399 matrix in time-wide format. In the code below, we save the number of spatial locations in the variable <code>nspatial</code>. Of the 399 time points, we only need 322 for training, the number of months between (and including) January 1970 and October 1996. We define a six-month-ahead forecast by specifying <code>tau = 6</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>nspatial <span class="ot">&lt;-</span> <span class="fu">nrow</span>(SSTdataA)    <span class="co"># number of spat. locations</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>TrainLen <span class="ot">&lt;-</span> <span class="dv">322</span>               <span class="co"># no. of months to Oct 1996</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>tau <span class="ot">&lt;-</span> <span class="dv">6</span>                      <span class="co"># forecast lead time (months)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We train the ESN on time series associated with the first ten EOFs extracted from the SST (training) data. The following code follows closely what was done in Labs 2.3 and 5.3.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="dv">10</span>                               <span class="co"># number of EOFs to retain</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>Z <span class="ot">&lt;-</span> <span class="fu">t</span>(SSTdataA[, <span class="dv">1</span><span class="sc">:</span>TrainLen])        <span class="co"># data matrix</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>spat_mean <span class="ot">&lt;-</span> <span class="fu">apply</span>(SSTdataA, <span class="dv">1</span>, mean)        <span class="co"># spatial mean</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>Zspat_detrend <span class="ot">&lt;-</span> Z <span class="sc">-</span> <span class="fu">outer</span>(<span class="fu">rep</span>(<span class="dv">1</span>, TrainLen), <span class="co"># detrend data</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>                           spat_mean)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>Zt <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span><span class="fu">sqrt</span>(TrainLen <span class="sc">-</span> <span class="dv">1</span>)<span class="sc">*</span>Zspat_detrend     <span class="co"># normalize</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>E <span class="ot">&lt;-</span> <span class="fu">svd</span>(Zt)                   <span class="co"># SVD</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>PHI <span class="ot">&lt;-</span> E<span class="sc">$</span>v[, <span class="dv">1</span><span class="sc">:</span>n]              <span class="co"># 10 EOF spatial basis functions</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>TS <span class="ot">&lt;-</span> <span class="fu">t</span>(SSTdataA) <span class="sc">%*%</span> PHI      <span class="co"># project data onto basis functions</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>                               <span class="co"># for PC time series</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we need to create the training and validation data sets. Both data sets will need input data and output data. Since we are setting up the ESN for six-months-ahead forecasting, as input we use the PC time series (see <a href="Chapter2.html#sec-EOFs" class="quarto-xref"><span>Section 2.4.3</span></a>) lagged by six months with respect to the output. For example, the PC time-series values at January 1970 are inputs (<span class="math inline">\(\mathbf{x}_t\)</span>) to forecast the SST (output) in July 1970. For prediction, we consider forecasting at ten three-month intervals starting from October 1996 (we chose three-month intervals to improve the visualization, but one can forecast each month if desired).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="do">## training set</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>xTrainIndex <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span>(TrainLen <span class="sc">-</span> tau) <span class="co"># training period ind. for input</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>yTrainIndex <span class="ot">&lt;-</span> (tau<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>(TrainLen) <span class="co"># shifted period ind. for output</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>xTrain <span class="ot">&lt;-</span> TS[xTrainIndex, ]       <span class="co"># training input time series</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>yTrain <span class="ot">&lt;-</span> TS[yTrainIndex, ]       <span class="co"># training output time series</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="do">## test set: forecast every three months</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>xTestIndex <span class="ot">&lt;-</span> <span class="fu">seq</span>(TrainLen, <span class="at">by =</span> <span class="dv">3</span>, <span class="at">length.out =</span> <span class="dv">10</span>)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>yTestIndex <span class="ot">&lt;-</span> xTestIndex<span class="sc">+</span>tau       <span class="co"># test output indices</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>xTest <span class="ot">&lt;-</span> TS[xTestIndex,]           <span class="co"># test input data</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>yTest <span class="ot">&lt;-</span> TS[yTestIndex,]           <span class="co"># test output data</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>testLen <span class="ot">&lt;-</span> <span class="fu">nrow</span>(xTest)             <span class="co"># number of test cases</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="ensemble-qesn-model-implementation" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="ensemble-qesn-model-implementation">Ensemble QESN Model Implementation</h4>
<p>We first have to make some model choices and set some parameters to run the ensemble QESN model. For model details and terminology, see the description above.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>quadInd <span class="ot">&lt;-</span> <span class="cn">TRUE</span>  <span class="co"># include both quadratic and linear output terms</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co"># if FALSE, then include only linear terms</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>ensembleLen <span class="ot">&lt;-</span> <span class="dv">500</span>  <span class="co"># number of ensemble members (i.e., QESN runs)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The next set of parameters can be trained by cross-validation or out-of-sample validation <span class="citation" data-cites="mcdermott2017ensemble">(see <a href="references.html#ref-mcdermott2017ensemble" role="doc-biblioref">McDermott and Wikle 2017</a>)</span>. For simplicity, we use the values obtained in that paper (which considered a similar long-lead SST forecasting application) here. The model arguments required as input are: <code>wWidth</code>, which corresponds to the parameter <span class="math inline">\(a_w\)</span> that specifies the range of the uniform distribution for the <span class="math inline">\(\mathbf{W}\)</span> weight matrix parameters in <a href="#eq-QESNw" class="quarto-xref">Equation&nbsp;<span>8.50</span></a>; similarly, <code>uWidth</code>, which corresponds to the parameter <span class="math inline">\(a_u\)</span> that specifies the range of the uniform distribution for the <span class="math inline">\(\mathbf{U}\)</span> matrix in <a href="#eq-QESNu" class="quarto-xref">Equation&nbsp;<span>8.51</span></a>; <code>piW</code>, which corresponds to <span class="math inline">\(\pi_w\)</span> in <a href="#eq-piw" class="quarto-xref">Equation&nbsp;<span>8.52</span></a>, the probability of a non-zero <span class="math inline">\(\mathbf{W}\)</span> weight; <code>piU</code>, which corresponds to <span class="math inline">\(\pi_u\)</span>, the probability of non-zero <span class="math inline">\(\mathbf{U}\)</span> weight parameter in <a href="#eq-piu" class="quarto-xref">Equation&nbsp;<span>8.53</span></a>; <code>curNh</code>, which corresponds to <span class="math inline">\(n_h\)</span>, the number of hidden units; <code>curNu</code>, which corresponds to <span class="math inline">\(\nu\)</span>, the spectral radius of the <span class="math inline">\(\mathbf{W}\)</span> matrix; <code>curM</code>, which corresponds to <span class="math inline">\(m\)</span>, the number of lags (embeddings) of input vectors to use; <code>tauEMB</code>, which corresponds to the embedding lag (<span class="math inline">\(\tau*\)</span> in <a href="#eq-QEQNembed" class="quarto-xref">Equation&nbsp;<span>8.54</span></a>); and <code>curRV</code>, which corresponds to <span class="math inline">\(r_v\)</span>, the ridge-regression parameter associated with the estimation of the output matrices, <span class="math inline">\(\mathbf{V}_1\)</span> and <span class="math inline">\(\mathbf{V}_2\)</span> in <a href="#eq-QESNresp" class="quarto-xref">Equation&nbsp;<span>8.48</span></a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>wWidth <span class="ot">&lt;-</span> .<span class="dv">10</span>      <span class="co"># W-weight matrix, uniform dist "width" param.</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>uWidth <span class="ot">&lt;-</span> .<span class="dv">10</span>      <span class="co"># U-weight matrix, uniform dist "width" param.</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>piW <span class="ot">&lt;-</span> .<span class="dv">10</span>         <span class="co"># sparseness parameter for W-weight matrix</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>piU <span class="ot">&lt;-</span> .<span class="dv">10</span>         <span class="co"># sparseness parameter for U-weight matrix</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>curNh <span class="ot">&lt;-</span> <span class="dv">120</span>       <span class="co"># number of hidden units</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>curNu <span class="ot">&lt;-</span> .<span class="dv">35</span>       <span class="co"># scaling parameter for W-weight matrix</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>curM <span class="ot">&lt;-</span> <span class="dv">4</span>          <span class="co"># number of embeddings</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>tauEMB <span class="ot">&lt;-</span> <span class="dv">6</span>        <span class="co"># embedding lag</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>curRV <span class="ot">&lt;-</span> .<span class="dv">01</span>       <span class="co"># output ridge regression parameter</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we use the function <code>createEmbedRNNData</code> to create a data object containing responses and embedding matrix inputs (see <a href="#eq-QEQNembed" class="quarto-xref">Equation&nbsp;<span>8.54</span></a>) for the training and prediction data sets (note that the responses and inputs are scaled by their respective standard deviations, as is common in the ESN literature). The function takes as inputs variables defined above: <code>curM</code>, the number of embedding lags; <code>tauEMB</code>, the embedding lag; <code>tau</code>, the forecast lead time; <code>yTrain</code>, the training output time series; <code>TS</code>, the input time series associated with the projection of the data onto the EOFs; and <code>xTestIndex</code>, which identifies the indices for the input data corresponding to the test periods.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="do">## standardize and create embedding matrices</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>DataObj <span class="ot">&lt;-</span> <span class="fu">createEmbedRNNData</span>(curM, tauEMB, tau, yTrain, TS,</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>                              xTestIndex)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The returned object, <code>DataObj</code>, is a list containing inputs and training data in the format required to train the ESN. We now need to create a parameter object that contains the parameters to be used in constructing the ESN. The function we use initializes the vectors associated with: the embedding matrix <span class="math inline">\(\tilde{\mathbf{x}}_t\)</span> in <a href="#eq-QEQNembed" class="quarto-xref">Equation&nbsp;<span>8.54</span></a>; the hidden state <span class="math inline">\(\mathbf{h}_t\)</span> in <a href="#eq-QESNhidden" class="quarto-xref">Equation&nbsp;<span>8.49</span></a>; and the ridge-regression matrix, <span class="math inline">\(r_v {\mathbf{I}}\)</span> (as defined in <a href="Chapter3.html#nte-technote-RidgeLassoReg" class="quarto-xref">Note&nbsp;<span>3.4</span></a>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>setParObj <span class="ot">&lt;-</span> <span class="fu">setParsEESN</span>(curRV ,curNh, n, curM, quadInd)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We save the forecasts in a three-dimensional array, with the first dimension indexing the ensemble number, the second dimension indexing the forecast time point, and the third dimension indexing the EOF number. We also create a second three-dimensional array with the first two dimensions the same, and the third dimension indexing spatial location.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>fmatESNFin <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="fu">c</span>(ensembleLen, testLen, n))</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>fmatESNFinFull <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="cn">NA</span>,<span class="fu">c</span>(ensembleLen, testLen, nspatial))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We are now ready to run the ensemble of QESN models to obtain forecasts. For each ensemble, we run the function <code>genResR</code>, which takes arguments defined previously as input: <code>curNh</code>, the number of hidden units; <code>wWidth</code> and <code>uWidth</code>, the uniform distribution sampling range for <span class="math inline">\(\mathbf{W}\)</span> and <span class="math inline">\(\mathbf{U}\)</span>, respectively; <code>piW</code> and <code>piU</code>, the probabilities of non-zeros in <span class="math inline">\(\mathbf{W}\)</span> and <span class="math inline">\(\mathbf{U}\)</span>, respectively; <code>curNu</code>, the spectral-radius parameter; <code>quadInd</code>, the indicator on whether to include the quadratic output weights or not; <code>DataObj</code>, the embedding input matrices; <code>setParObj</code>, the initializations corresponding to the hidden state vectors and the ridge-regression matrices; and <code>testLen</code>, the number of test cases.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(iEnsem <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>ensembleLen) {</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="do">## Run the QESN model for a single ensemble</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  QESNOutObj <span class="ot">=</span> <span class="fu">genResR</span>(<span class="at">nh =</span> curNh,</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>                       <span class="at">wWidth =</span> wWidth,</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>                       <span class="at">uWidth =</span> uWidth,</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>                       <span class="at">piW =</span> piW,</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>                       <span class="at">piU =</span> piU,</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>                       <span class="at">nuESN =</span> curNu,</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>                       <span class="at">quadInd =</span> quadInd,</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>                       <span class="at">DataObj =</span> DataObj,</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>                       <span class="at">setParObj =</span> setParObj,</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>                       <span class="at">testLen =</span> testLen)</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>  <span class="do">## save forecasts for the reduced dimension output</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>  fmatESNFin[iEnsem, , ] <span class="ot">&lt;-</span> <span class="fu">t</span>(QESNOutObj<span class="sc">$</span>unScaledForecasts)</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>  <span class="do">## forecasts for the full spatial field</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>  fmatESNFinFull[iEnsem, , ] <span class="ot">&lt;-</span> fmatESNFin[iEnsem, , ] <span class="sc">%*%</span> <span class="fu">t</span>(PHI)</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="post-processing-the-ensemble-qesn-output" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="post-processing-the-ensemble-qesn-output">Post-Processing the Ensemble QESN Output</h4>
<p>In this section, we focus on post-processing the ensemble QESN output for the Niño 3.4 region. To assess whether or not we have the correct coverage of the prediction intervals, we consider 95% (pointwise) prediction intervals.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>alpha <span class="ot">&lt;-</span> .<span class="dv">05</span>   <span class="co"># alpha-level of 1-alpha pred. intervals (P.I.s)</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>lwPI <span class="ot">&lt;-</span> alpha<span class="sc">/</span><span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In the following code, we calculate the mean and the lower/upper boundaries of the 95% prediction interval for the Niño 3.4 region (across the whole ensemble of realizations from the predictive distribution).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>nino34AvgPreds <span class="ot">&lt;-</span> nino34LwPI <span class="ot">&lt;-</span> nino34UpPI <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, testLen)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>testLen){</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  nino34AvgPreds[i] <span class="ot">&lt;-</span> fmatESNFinFull[,i,nino34Index] <span class="sc">%&gt;%</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mean</span>()</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  nino34LwPI[i] <span class="ot">&lt;-</span> fmatESNFinFull[, i, nino34Index] <span class="sc">%&gt;%</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rowMeans</span>() <span class="sc">%&gt;%</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">quantile</span>(lwPI)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  nino34UpPI[i] <span class="ot">&lt;-</span> fmatESNFinFull[,i,nino34Index] <span class="sc">%&gt;%</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rowMeans</span>() <span class="sc">%&gt;%</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">quantile</span>(<span class="dv">1</span> <span class="sc">-</span> lwPI)</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>nino34_results <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">AvgPres =</span> nino34AvgPreds,</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>                             <span class="at">LwPI =</span> nino34LwPI,</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>                             <span class="at">UpPI =</span> nino34UpPI)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>These predictive-distribution summaries can be compared to the average SST at the prediction month, which we calculate as follows:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>nino34_results<span class="sc">$</span>AvgObs <span class="ot">&lt;-</span> SSTdata[nino34Index, yTestIndex] <span class="sc">%&gt;%</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colMeans</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, we allocate the prediction-month labels to the data frame which, for this example, is achieved as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>nino34_results<span class="sc">$</span>date <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="fu">as.Date</span>(<span class="st">"1997-04-01"</span>),</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>                           <span class="at">length.out =</span> <span class="dv">10</span>, <span class="at">by =</span> <span class="st">"3 months"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="plotting-results-for-forecasts-in-the-niño-3.4-region" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="plotting-results-for-forecasts-in-the-niño-3.4-region">Plotting Results for Forecasts in the Niño 3.4 Region</h4>
<p>In this last section, we focus our plots on the results for spatially averaged SST anomalies over the Niño 3.4 region for every third month (to make the plot less cluttered). Although we skip months and present the spatial average for ease of visualization, we note that the full spatial fields could easily be plotted for any of the forecast months, as shown in Lab 5.3. In <a href="#fig-QESN_N34_Forecasts" class="quarto-xref">Figure&nbsp;<span>8.4</span></a>, we plot the prediction and prediction intervals for the spatial average alongside the spatial average of the observations by month. The following code produces this figure.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>gresults <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(nino34_results) <span class="sc">+</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">x =</span> date, <span class="at">y =</span> AvgObs)) <span class="sc">+</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_ribbon</span>(<span class="fu">aes</span>(<span class="at">x =</span> date, <span class="at">ymin =</span> LwPI, <span class="at">ymax =</span> UpPI),</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>              <span class="at">alpha =</span> <span class="fl">0.1</span>, <span class="at">fill =</span> <span class="st">"black"</span>) <span class="sc">+</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">x =</span> date, <span class="at">y =</span> AvgPres), <span class="at">col =</span> <span class="st">"red"</span>) <span class="sc">+</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="fu">expression</span>(<span class="fu">paste</span>(<span class="st">"Ni"</span>, <span class="fu">tilde</span>(n), <span class="st">"o 3.4 Index"</span>))) <span class="sc">+</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"Month"</span>) <span class="sc">+</span> <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-QESN_N34_Forecasts" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-QESN_N34_Forecasts-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_5/ESN_N34_Forecast2.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-QESN_N34_Forecasts-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.4: Out-of-sample six-month forecasts of SST anomalies averaged over the Niño 3.4 region from April 1997 to July 1999 (every three months). The black line shows the truth and the red line shows the average of the ensemble of QESN forecasts. The point-wise 95% prediction intervals from the ensemble of QESN forecasts is shown with light-gray shading.
</figcaption>
</figure>
</div>
<p>Although pointwise prediction intervals are informative, it can also be helpful to plot the trajectories of individual forecasts from the QESN model. This can be done by first assigning a number (say, the first 15) of ensemble trajectories to the data frame and then putting the data frame into long format using <code>gather</code>. The following code produces <a href="#fig-QESN_N34_ForecastsENS" class="quarto-xref">Figure&nbsp;<span>8.5</span></a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Compute the spatial average over Nino3.4 for each ensemble</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">15</span>)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  nino34_results[<span class="fu">paste0</span>(<span class="st">"Sim"</span>, i)] <span class="ot">&lt;-</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rowMeans</span>(fmatESNFinFull[i, , nino34Index])</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="do">## Convert to long data frame</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>nino34_results_long <span class="ot">&lt;-</span> nino34_results <span class="sc">%&gt;%</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span>AvgPres, <span class="sc">-</span>LwPI,</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>                <span class="sc">-</span>UpPI, <span class="sc">-</span>AvgObs) <span class="sc">%&gt;%</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">gather</span>(SimNum, SSTindex, <span class="sc">-</span>date)</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="do">## Plot</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>gresults2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(nino34_results_long) <span class="sc">+</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> nino34_results, <span class="fu">aes</span>(<span class="at">x =</span> date, <span class="at">y =</span> AvgObs)) <span class="sc">+</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">x =</span> date, <span class="at">y =</span> SSTindex, <span class="at">group =</span> SimNum,</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>                <span class="at">linetype =</span> SimNum, <span class="at">colour =</span> SimNum)) <span class="sc">+</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="fu">expression</span>(<span class="fu">paste</span>(<span class="st">"Ni"</span>, <span class="fu">tilde</span>(n), <span class="st">"o 3.4 Index"</span>))) <span class="sc">+</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"Month"</span>) <span class="sc">+</span> <span class="fu">theme_bw</span>() <span class="sc">+</span> <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">"none"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-QESN_N34_ForecastsENS" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-QESN_N34_ForecastsENS-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_5/ESN_N34_ForecastENS2.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-QESN_N34_ForecastsENS-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8.5: Out-of-sample six-month forecasts of SST anomalies averaged over the Niño 3.4 region from April 1997 through July 1999 (every three months). The black line shows the truth, and other lines show the first 15 ensemble members from the ensemble of QESN model forecasts.
</figcaption>
</figure>
</div>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-cressie2011statistics" class="csl-entry" role="listitem">
Cressie, N., and C. K. Wikle. 2011. <em>Statistics for Spatio-Temporal Data</em>. Hoboken, NJ: John Wiley &amp; Sons.
</div>
<div id="ref-gelman2013bayesian" class="csl-entry" role="listitem">
Gelman, Andrew, John B Carlin, Hal S Stern, David B Dunson, Aki Vehtari, and Donald B Rubin. 2014. <em>Bayesian Data Analysis</em>. 3rd ed. Boca Raton, FL: Chapman &amp; Hall/CRC.
</div>
<div id="ref-harvey1993time" class="csl-entry" role="listitem">
Harvey, Andrew C. 1993. <em>Time Series Models</em>. 2nd ed. Cambridge, MA: MIT Press.
</div>
<div id="ref-james2013introduction" class="csl-entry" role="listitem">
James, Gareth, Daniela Witten, Trevor Hastie, and Robert Tibshirani. 2013. <em>An Introduction to Statistical Learning</em>. New York: Springer.
</div>
<div id="ref-johnson1992applied" class="csl-entry" role="listitem">
Johnson, Richard A., and Dean W. Wichern. 1992. <em>Applied Multivariate Statistical Analysis</em>. <em>Prentice Hall</em>. 3rd ed. Englewood Cliffs, NJ: Prentice Hall.
</div>
<div id="ref-mcdermott2017ensemble" class="csl-entry" role="listitem">
McDermott, Patrick L, and Christopher K Wikle. 2017. <span>“An Ensemble Quadratic Echo State Network for Non-Linear Spatio-Temporal Forecasting.”</span> <em>Stat</em> 6 (1): 315–30.
</div>
<div id="ref-milliff2011ocean" class="csl-entry" role="listitem">
Milliff, R. F., A. Bonazzi, C. K. Wikle, N. Pinardi, and L. M. Berliner. 2011. <span>“Ocean Ensemble Forecasting. Part i: Ensemble Mediterranean Winds from a Bayesian Hierarchical Model.”</span> <em>Quarterly Journal of the Royal Meteorological Society</em> 137 (657): 858–78.
</div>
<div id="ref-schott2016matrix" class="csl-entry" role="listitem">
Schott, James R. 2017. <em>Matrix Analysis for Statistics</em>. 3rd ed. Hoboken, NJ: John Wiley &amp; Sons.
</div>
<div id="ref-shumway1982approach" class="csl-entry" role="listitem">
Shumway, Robert H, and David S Stoffer. 1982. <span>“An Approach to Time Series Smoothing and Forecasting Using the EM Algorithm.”</span> <em>Journal of Time Series Analysis</em> 3 (4): 253–64.
</div>
<div id="ref-stevens2002entrainment" class="csl-entry" role="listitem">
Stevens, Bjorn, Jianjun Duan, James C McWilliams, Matthias Münnich, and J David Neelin. 2002. <span>“Entrainment, Rayleigh Friction, and Boundary Layer Winds over the Tropical Pacific.”</span> <em>Journal of Climate</em> 15 (1): 30–44.
</div>
</div>
</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./ChapterPergimus.html" class="pagination-link" aria-label="Pergimus (Epilogue)">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Pergimus (Epilogue)</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./references.html" class="pagination-link" aria-label="References">
        <span class="nav-page-text">References</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>