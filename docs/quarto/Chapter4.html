<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.28">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>4&nbsp; Descriptive Spatio-Temporal Statistical Models – Spatio-Temporal Statistics with R (1st edition)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Chapter5.html" rel="next">
<link href="./Chapter3.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-b719d3d4935f2b08311a76135e2bf442.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-7d2e1f8220df954187ab24ed36a0da9c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Chapter4.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Descriptive Spatio-Temporal Statistical Models</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Spatio-Temporal Statistics with R (1st edition)</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction to Spatio-Temporal Statistics</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Exploring Spatio-Temporal Data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Spatio-Temporal Statistical Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter4.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Descriptive Spatio-Temporal Statistical Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Dynamic Spatio-Temporal Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Chapter6.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Evaluating Spatio-Temporal Statistical Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterPergimus.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Pergimus (Epilogue)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterAppendices.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Appendices</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ChapterRPackages.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">List of <code>R</code> packages</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-adderrproc" id="toc-sec-adderrproc" class="nav-link active" data-scroll-target="#sec-adderrproc"><span class="header-section-number">4.1</span> Additive Measurement Error and Process Models</a></li>
  <li><a href="#sec-GaussDataProc" id="toc-sec-GaussDataProc" class="nav-link" data-scroll-target="#sec-GaussDataProc"><span class="header-section-number">4.2</span> Prediction for Gaussian Data and Processes</a>
  <ul class="collapse">
  <li><a href="#sec-covfun" id="toc-sec-covfun" class="nav-link" data-scroll-target="#sec-covfun"><span class="header-section-number">4.2.1</span> Spatio-Temporal Covariance Functions</a></li>
  <li><a href="#spatio-temporal-semivariograms" id="toc-spatio-temporal-semivariograms" class="nav-link" data-scroll-target="#spatio-temporal-semivariograms"><span class="header-section-number">4.2.2</span> Spatio-Temporal Semivariograms</a></li>
  <li><a href="#sec-LGestimation" id="toc-sec-LGestimation" class="nav-link" data-scroll-target="#sec-LGestimation"><span class="header-section-number">4.2.3</span> Gaussian Spatio-Temporal Model Estimation</a></li>
  </ul></li>
  <li><a href="#sec-randomeffects" id="toc-sec-randomeffects" class="nav-link" data-scroll-target="#sec-randomeffects"><span class="header-section-number">4.3</span> Random-Effects Parameterizations</a></li>
  <li><a href="#sec-basisfunctions" id="toc-sec-basisfunctions" class="nav-link" data-scroll-target="#sec-basisfunctions"><span class="header-section-number">4.4</span> Basis-Function Representations</a>
  <ul class="collapse">
  <li><a href="#sec-Randeffects_STbasis" id="toc-sec-Randeffects_STbasis" class="nav-link" data-scroll-target="#sec-Randeffects_STbasis"><span class="header-section-number">4.4.1</span> Random Effects with Spatio-Temporal Basis Functions</a></li>
  <li><a href="#sec-randeffspat" id="toc-sec-randeffspat" class="nav-link" data-scroll-target="#sec-randeffspat"><span class="header-section-number">4.4.2</span> Random Effects with Spatial Basis Functions</a></li>
  <li><a href="#random-effects-with-temporal-basis-functions" id="toc-random-effects-with-temporal-basis-functions" class="nav-link" data-scroll-target="#random-effects-with-temporal-basis-functions"><span class="header-section-number">4.4.3</span> Random Effects with Temporal Basis Functions</a></li>
  <li><a href="#confounding-of-fixed-effects-and-random-effects" id="toc-confounding-of-fixed-effects-and-random-effects" class="nav-link" data-scroll-target="#confounding-of-fixed-effects-and-random-effects"><span class="header-section-number">4.4.4</span> Confounding of Fixed Effects and Random Effects</a></li>
  </ul></li>
  <li><a href="#sec-nonGaussian" id="toc-sec-nonGaussian" class="nav-link" data-scroll-target="#sec-nonGaussian"><span class="header-section-number">4.5</span> Non-Gaussian Data Models with Latent Gaussian Processes</a>
  <ul class="collapse">
  <li><a href="#generalized-additive-models-gams" id="toc-generalized-additive-models-gams" class="nav-link" data-scroll-target="#generalized-additive-models-gams"><span class="header-section-number">4.5.1</span> Generalized Additive Models (GAMs)</a></li>
  <li><a href="#sec-BHMest" id="toc-sec-BHMest" class="nav-link" data-scroll-target="#sec-BHMest"><span class="header-section-number">4.5.2</span> Inference for Spatio-Temporal Hierarchical Models</a></li>
  </ul></li>
  <li><a href="#sec-Chap4wrapup" id="toc-sec-Chap4wrapup" class="nav-link" data-scroll-target="#sec-Chap4wrapup"><span class="header-section-number">4.6</span> Chapter 4 Wrap-Up</a></li>
  <li><a href="#lab-4.1-spatio-temporal-kriging-with-gstat" id="toc-lab-4.1-spatio-temporal-kriging-with-gstat" class="nav-link" data-scroll-target="#lab-4.1-spatio-temporal-kriging-with-gstat">Lab 4.1: Spatio-Temporal Kriging with <strong>gstat</strong></a></li>
  <li><a href="#lab-4.2-spatio-temporal-basis-functions-with-frk" id="toc-lab-4.2-spatio-temporal-basis-functions-with-frk" class="nav-link" data-scroll-target="#lab-4.2-spatio-temporal-basis-functions-with-frk">Lab 4.2: Spatio-Temporal Basis Functions with <strong>FRK</strong></a></li>
  <li><a href="#lab-4.3-temporal-basis-functions-with-spatiotemporal" id="toc-lab-4.3-temporal-basis-functions-with-spatiotemporal" class="nav-link" data-scroll-target="#lab-4.3-temporal-basis-functions-with-spatiotemporal">Lab 4.3: Temporal Basis Functions with <strong>SpatioTemporal</strong></a></li>
  <li><a href="#lab-4.4-non-gaussian-spatio-temporal-gams-with-mgcv" id="toc-lab-4.4-non-gaussian-spatio-temporal-gams-with-mgcv" class="nav-link" data-scroll-target="#lab-4.4-non-gaussian-spatio-temporal-gams-with-mgcv">Lab 4.4: Non-Gaussian Spatio-Temporal GAMs with <strong>mgcv</strong></a></li>
  <li><a href="#lab-4.5-non-gaussian-spatio-temporal-models-with-inla" id="toc-lab-4.5-non-gaussian-spatio-temporal-models-with-inla" class="nav-link" data-scroll-target="#lab-4.5-non-gaussian-spatio-temporal-models-with-inla">Lab 4.5: Non-Gaussian Spatio-Temporal Models with <strong>INLA</strong></a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Descriptive Spatio-Temporal Statistical Models</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Chapter 3 is the linchpin for the “two Ds” of spatio-temporal statistical modeling, which are now upon us in this chapter (the first “D,” namely “descriptive”) and the next chapter (the second “D,” namely “dynamic”). We hope to have eased you from the free form of spatio-temporal exploratory data analysis presented in Chapter 2 into the “rigor” needed to build a coherent statistical model. The independent probability structure assumed in Chapter 3 was a place-holder for the sorts of probability structures that respect Tobler’s law, discussed in the previous chapters: in our context, this says that a set of values at nearby spatio-temporal locations should <em>not</em> be assumed independent. As we shall see, there is a “descriptive” way (this chapter, Chapter 4) and a “dynamic” way (Chapter 5) to incorporate spatio-temporal statistical dependence into models.</p>
<p>In this chapter we focus on two of the goals of spatio-temporal modeling given in Chapter 3: prediction at some location in space within the time span of the observations and, to a lesser extent, parameter inference for spatio-temporal covariates. For both goals we assume that our observations can be decomposed into a true (latent) spatio-temporal process plus observation error. We then assume that the true process can be written in terms of spatio-temporal fixed effects due to covariates plus a spatio-temporally dependent random process. We call this a <em>descriptive</em> approach because its main concern is to specify (or describe) the dependence structure in the random process. This is in contrast to the <em>dynamic</em> approach presented in Chapter 5 that models the evolution of the dependent random process through time. To implement the prediction and inference approaches discussed herein we must perform estimation. We mention the most popular and relevant estimation approaches and algorithms as they come up, but omit most of the details. The interested reader can explore these details in the references given in <a href="#sec-Chap4wrapup" class="quarto-xref"><span>Section 4.6</span></a>. Finally, we note that these discussions require a bit more statistical formality and mathematical notation, and so the presentations in this and the next chapter are at a higher technical level than those in Chapter 3.</p>
<section id="sec-adderrproc" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="sec-adderrproc"><span class="header-section-number">4.1</span> Additive Measurement Error and Process Models</h2>
<p>In this section we describe more formally a two-stage model that considers additive measurement error in a data (observation) model, and a process model that is decomposed into a fixed- (covariate-) effect term and a random-process term. This general decomposition is the basis for the models that we present in this and the next chapter.</p>
<p>Recall that at each time <span class="math inline">\(t \in \{t_1,\ldots,t_T\}\)</span> we have <span class="math inline">\(m_{t_j}\)</span> observations. With a slight abuse of notation, we write the number of observations at time <span class="math inline">\(t_j\)</span> as <span class="math inline">\(m_j\)</span>. The vector of all observations is then given by</p>
<p><span class="math display">\[
\mathbf{Z}= \left(Z(\mathbf{s}_{11};t_1), Z(\mathbf{s}_{21};t_1),\ldots, Z(\mathbf{s}_{m_11};t_1),\ldots, Z(\mathbf{s}_{1T};t_T),\ldots,Z(\mathbf{s}_{m_TT};t_T)\right)'.
\]</span></p>
<p>That is, different numbers of irregular spatial observations are allowed for each time (note that if there are no observations at a given time, <span class="math inline">\(t_j\)</span>, the set of spatial locations is empty for that time and <span class="math inline">\(m_j = 0\)</span>). We seek a prediction at some spatio-temporal location <span class="math inline">\((\mathbf{s}_0;t_0)\)</span>. As described in Chapter 1, if <span class="math inline">\(t_0 &lt; t_T\)</span>, so that we have all data available to us, then we are in a smoothing situation; if we only have data up to time <span class="math inline">\(t_0\)</span> then we are in a filtering situation; and if <span class="math inline">\(t_0 &gt; t_T\)</span> then we are in a forecasting situation. We seek statistically optimal predictions for an underlying latent (i.e., hidden) random spatio-temporal process. We denote this process by <span class="math inline">\(\{Y(\mathbf{s};t): \mathbf{s}\in D_s,\ t \in D_t\}\)</span>, for spatial location <span class="math inline">\(\mathbf{s}\)</span> in spatial domain <span class="math inline">\(D_s\)</span> (a subset of <span class="math inline">\(d\)</span>-dimensional Euclidean space), and time index <span class="math inline">\(t\)</span> in temporal domain <span class="math inline">\(D_t\)</span> (along the one-dimensional real line).</p>
<p>More specifically, suppose we represent the data in terms of the latent spatio-temporal process of interest plus a measurement error. For example,</p>
<p><span id="eq-Zmodel"><span class="math display">\[
Z(\mathbf{s}_{ij};t_{j}) = Y(\mathbf{s}_{ij};t_j) + \epsilon(\mathbf{s}_{ij};t_{j}), \quad i=1,\ldots,m_j;\ j=1,\ldots,T,
\tag{4.1}\]</span></span></p>
<p>where the errors <span class="math inline">\(\{\epsilon(\mathbf{s}_{ij};t_j)\}\)</span> represent <em>iid</em> mean-zero measurement error that is independent of <span class="math inline">\(Y(\cdot;\cdot)\)</span> and has variance <span class="math inline">\(\sigma^2_\epsilon\)</span>. So, in the simple data model <a href="#eq-Zmodel" class="quarto-xref">Equation&nbsp;<span>4.1</span></a> we assume that the data are noisy observations of the <em>latent</em> process <span class="math inline">\(Y\)</span> at a finite collection of locations in the space-time domain, where typically we have not observed data at all locations of interest. Consequently, we would like to predict the latent value <span class="math inline">\(Y(\mathbf{s}_0;t_0)\)</span> at a spatio-temporal location <span class="math inline">\((\mathbf{s}_{0};t_0)\)</span> as a function of the data vector represented by <span class="math inline">\(\mathbf{Z}\)</span> (or some subset of these observations), which is of dimension <span class="math inline">\(\sum_{j=1}^T m_j\)</span>. To simplify the notation that follows, we shall sometimes assume that data were observed at the same set of <span class="math inline">\(m\)</span> locations for each of the <span class="math inline">\(T\)</span> times, in which case <span class="math inline">\(\mathbf{Z}\)</span> is of length <span class="math inline">\(m T\)</span>.</p>
<p>Now suppose that the latent process follows the model</p>
<p><span id="eq-Yprocess_st"><span class="math display">\[
Y(\mathbf{s};t) = \mu(\mathbf{s};t) + \eta(\mathbf{s};t),
\tag{4.2}\]</span></span></p>
<p>for all <span class="math inline">\((\mathbf{s};t)\)</span> in our space-time domain of interest (e.g., <span class="math inline">\(D_s \times D_t\)</span>), where each component in <a href="#eq-Yprocess_st" class="quarto-xref">Equation&nbsp;<span>4.2</span></a> has a special role to play. In <a href="#eq-Yprocess_st" class="quarto-xref">Equation&nbsp;<span>4.2</span></a>, <span class="math inline">\(\mu(\mathbf{s};t)\)</span> represents the process mean, which is not random, and <span class="math inline">\(\eta(\mathbf{s};t)\)</span> represents a mean-zero random process with spatial and temporal statistical dependence. Our goal here is to find the optimal linear predictor in the sense that it minimizes the mean squared prediction error between <span class="math inline">\(Y(\mathbf{s}_0;t_0)\)</span> and our prediction, which we write as <span class="math inline">\(\widehat{Y}(\mathbf{s}_0;t_0).\)</span> Depending on the problem at hand, we may choose to let <span class="math inline">\(\mu(\mathbf{s};t)\)</span> be: (i) known, (ii) constant but unknown, or (iii) modeled in terms of <span class="math inline">\(p\)</span> covariates, <span class="math inline">\(\mu(\mathbf{s};t) = \mathbf{x}(\mathbf{s};t)'\boldsymbol{\beta}\)</span>, where the <span class="math inline">\(p\)</span>-dimensional vector of parameters <span class="math inline">\(\boldsymbol{\beta}\)</span> is unknown. In the context of the descriptive methods considered in this chapter, these choices result in spatio-temporal (S-T) (i) simple, (ii) ordinary, and (iii) universal kriging, respectively. Note that in this and subsequent chapters, the covariate vector <span class="math inline">\(\mathbf{x}(\mathbf{s};t)\)</span> could include the variable “1,” which models an intercept in the multivariable regression.</p>
</section>
<section id="sec-GaussDataProc" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="sec-GaussDataProc"><span class="header-section-number">4.2</span> Prediction for Gaussian Data and Processes</h2>
<p>Recall from Chapter 3 that when we interpolate with spatio-temporal data we specify that the value of the process at some location is simply a weighted combination of nearby observations. We described a couple of deterministic methods to obtain such weights (inverse distance weighting and kernel smoothing). Here we are concerned with determining the statistically “optimal” weights in this linear combination. At this point, it is worth taking a step back and looking at the big picture.</p>
<p>In the case of predicting statistically within the domain of our space-time observation locations (smoothing), we are just interpolating our observations <span class="math inline">\(\mathbf{Z}\)</span> to the location <span class="math inline">\((\mathbf{s}_0;t_0)\)</span> in a way that respects that we have observational uncertainty. For example, in the special case where <span class="math inline">\((\mathbf{s}_0;t_0)\)</span> corresponds to an observation location, we are simply smoothing out this observation uncertainty. Unlike the deterministic approaches to spatio-temporal prediction in Chapter 3, we seek the weights in a linear predictor that minimize the interpolation error on average. This optimization criterion is <span class="math inline">\(E(Y(\mathbf{s}_0;t_0) - \widehat{Y}(\mathbf{s}_0;t_0))^2\)</span>, the mean square prediction error (MSPE). The best linear unbiased predictor that minimizes the MSPE is referred to as the <em>kriging predictor</em>. As we shall see, the kriging weights are determined by the statistical dependence (i.e., covariances) between observation locations (roughly, the greater the covariability, the greater the weight), yet respect the measurement uncertainty.</p>
<p>There are several different approaches to deriving the form of the optimal linear predictor, which we henceforth call <em>S-T</em> . Given that we are just focusing on the first two moments in the descriptive approach (i.e., the means, variances, and covariances of <span class="math inline">\(Y(\cdot;\cdot)\)</span>), it is convenient to assume that the underlying process is a <em>Gaussian process</em> and the has a Gaussian distribution. We take this approach in this book.</p>
<p>What is a Gaussian process? Consider a stochastic process denoted by <span class="math inline">\(\{Y(\mathbf{r}): \mathbf{r}\in D\}\)</span>, where <span class="math inline">\(\mathbf{r}\)</span> is a spatial, temporal, or spatio-temporal location in <span class="math inline">\(D\)</span>, a subset of <span class="math inline">\(d\)</span>-dimensional space. This process is said to be a Gaussian process, often denoted <span class="math inline">\(Y(\mathbf{r}) \sim GP(\mu(\mathbf{r}), c(\cdot;\cdot))\)</span>, if the process has all its finite-dimensional distributions Gaussian, determined by a mean function <span class="math inline">\(\mu(\mathbf{r})\)</span> and a covariance function <span class="math inline">\(c(\mathbf{r},\mathbf{r}') = \textrm{cov}(Y(\mathbf{r}),Y(\mathbf{r}'))\)</span> for <em>any</em> location <span class="math inline">\(\{\mathbf{r},\mathbf{r}'\} \in D\)</span>. (Note that in spatio-temporal statistics it is common to use <span class="math inline">\(Gau(\cdot,\cdot)\)</span> instead of <span class="math inline">\(GP(\cdot,\cdot)\)</span>, and we follow that convention in this book.) There are two important points to make about the Gaussian process. First, because the Gaussian process determines a probability distribution over functions, it exists <em>everywhere</em> in the domain of interest <span class="math inline">\(D\)</span>; so, if the mean and covariance functions are known, the process can be described anywhere in the domain. Second, only finite distributions need to be considered in practice because of the fundamental property that any finite collection of Gaussian process random variables <span class="math inline">\(\{Y(\mathbf{r}_i)\}\)</span> has a joint multivariate normal (Gaussian) distribution. This allows the use of traditional machinery of multivariate normal distributions when performing prediction and inference. Gaussian processes are fundamental to the theoretical and practical foundation of spatial and spatio-temporal statistics and, since the first decade of the twenty-first century, have become increasingly important and popular modeling tools in the machine-learning community <span class="citation" data-cites="rasmussen2006gaussian">(e.g., <a href="references.html#ref-rasmussen2006gaussian" role="doc-biblioref">Rasmussen and Williams 2006</a>)</span>.</p>
<p>In the context of S-T , time is implicitly treated as another dimension, and we consider covariance functions that describe covariability between any two space-time locations (where in general we should use covariance functions that respect that durations in time are different from distances in space). We can write the data model in terms of vectors,</p>
<p><span id="eq-Zdata_vec"><span class="math display">\[
\mathbf{Z}= \mathbf{Y}+ \boldsymbol{\varepsilon},
\tag{4.3}\]</span></span></p>
<p>where <span class="math inline">\(\mathbf{Y}\equiv (Y(\mathbf{s}_{11};t_1),\ldots,Y(\mathbf{s}_{m_TT};t_T))'\)</span> and <span class="math inline">\(\boldsymbol{\varepsilon}\equiv (\epsilon(\mathbf{s}_{11};t_1),\ldots,\epsilon(\mathbf{s}_{m_TT};t_T))'\)</span>. Similarly, the vector form of the process model for <span class="math inline">\(\mathbf{Y}\)</span> is written</p>
<p><span id="eq-Yproc_vec"><span class="math display">\[
\mathbf{Y}= \boldsymbol{\mu}+ \boldsymbol{\eta},
\tag{4.4}\]</span></span></p>
<p>where <span class="math inline">\(\boldsymbol{\mu}\equiv (\mu(\mathbf{s}_{11};t_1),\ldots,\mu(\mathbf{s}_{m_TT};t_T))' = \mathbf{X}\boldsymbol{\beta}\)</span>, and <span class="math inline">\(\boldsymbol{\eta}\equiv (\eta(\mathbf{s}_{11};t_1),\ldots,\eta(\mathbf{s}_{m_TT};t_T))'\)</span>. Note that <span class="math inline">\(\textrm{cov}({\mathbf{Y}}) \equiv \mathbf{C}_y = \mathbf{C}_\eta\)</span>, <span class="math inline">\(\textrm{cov}({\boldsymbol{\varepsilon}}) \equiv \mathbf{C}_{\epsilon}\)</span>, and <span class="math inline">\(\textrm{cov}({\mathbf{Z}}) \equiv \mathbf{C}_z = \mathbf{C}_y + \mathbf{C}_{\epsilon}\)</span>.</p>
<p>Now, defining <span class="math inline">\(\mathbf{c}_0' \equiv \textrm{cov}(Y(\mathbf{s}_0;t_0),{\mathbf{Z}})\)</span>, <span class="math inline">\(c_{0,0} \equiv \textrm{var}(Y(\mathbf{s}_0;t_0))\)</span>, and <span class="math inline">\(\mathbf{X}\)</span> the <span class="math inline">\((\sum_{j=1}^T m_j) \times p\)</span> matrix given by <span class="math inline">\(\mathbf{X}\equiv [\mathbf{x}(\mathbf{s}_{ij};t_j)': i=1,\ldots,m_j;\ j=1,\ldots,T]\)</span>, consider the joint Gaussian distribution,</p>
<p><span class="math display">\[
\left[\begin{array}{c} Y(\mathbf{s}_0;t_0) \\ \mathbf{Z}\end{array}\right] \; \sim \; Gau\left(\left[\begin{array}{c} \mathbf{x}(\mathbf{s}_0;t_0)' \\ \mathbf{X}\end{array}\right] \boldsymbol{\beta}\; , \; \left[\begin{array}{cc} c_{0,0} &amp; \mathbf{c}_0' \\ \mathbf{c}_0 &amp; \mathbf{C}_z \end{array}\right] \right).
\]</span></p>
<p>Using well-known results for conditional distributions from a joint multivariate normal (Gaussian) distribution <span class="citation" data-cites="johnson1992applied">(e.g., <a href="references.html#ref-johnson1992applied" role="doc-biblioref">Johnson and Wichern 1992</a>)</span>, and assuming (for the moment) that <span class="math inline">\(\boldsymbol{\beta}\)</span> is known (recall that this is called <em>S-T simple</em> kriging), one can obtain the conditional distribution,</p>
<p><span id="eq-STkrig"><span class="math display">\[
Y(\mathbf{s}_0;t_0) \; \mid  \mathbf{Z}\; \sim \; Gau(\mathbf{x}(\mathbf{s}_0;t_0)'\boldsymbol{\beta}+ \mathbf{c}_0' \mathbf{C}_z^{-1} (\mathbf{Z}- \mathbf{X}\boldsymbol{\beta})\; , \; c_{0,0} - \mathbf{c}_0' \mathbf{C}_z^{-1} \mathbf{c}_0),
\tag{4.5}\]</span></span></p>
<p>for which the mean is the S-T simple kriging predictor,</p>
<p><span id="eq-STkrigpred"><span class="math display">\[
\widehat{Y}(\mathbf{s}_0;t_0) = \mathbf{x}(\mathbf{s}_0;t_0)'\boldsymbol{\beta}+ \mathbf{c}_0' \mathbf{C}_z^{-1} (\mathbf{Z}- \mathbf{X}\boldsymbol{\beta}),
\tag{4.6}\]</span></span></p>
<p>and the variance is the S-T simple kriging variance,</p>
<p><span id="eq-STkrigvar"><span class="math display">\[
\sigma^2_{Y,sk}(\mathbf{s}_0;t_0) = c_{0,0} - \mathbf{c}_0' \mathbf{C}_z^{-1} \mathbf{c}_0.
\tag{4.7}\]</span></span></p>
<p>Note that we call <span class="math inline">\(\sigma_{Y,sk}(\mathbf{s}_0;t_0)\)</span> the S-T simple kriging <em>prediction standard error</em>, and it has the same units as <span class="math inline">\(\widehat{Y}(\mathbf{s}_0;t_0)\)</span>.</p>
<p>It is fundamentally important in kriging that one be able to specify the covariance between the process at <em>any</em> two locations in the domain of interest (i.e., <span class="math inline">\(\mathbf{c}_0\)</span>). That is, we assume that the process is defined for an uncountable set of locations and the data correspond to a partial realization of this process. As mentioned above, this is the benefit of considering S-T kriging from the Gaussian-process perspective. That is, if we assume we have a Gaussian process, then we can specify a valid finite-dimensional Gaussian distribution for <em>any</em> finite subset of locations.</p>
<p>Another important observation to make here is that <a href="#eq-STkrigpred" class="quarto-xref">Equation&nbsp;<span>4.6</span></a> is a predictor of the hidden value, <span class="math inline">\(Y(\mathbf{s}_0;t_0)\)</span>, not of <span class="math inline">\(Z(\mathbf{s}_0;t_0)\)</span>. The form of the conditional distribution given by <a href="#eq-STkrig" class="quarto-xref">Equation&nbsp;<span>4.5</span></a> helps clarify the intuition behind S-T kriging. In particular, note that the conditional mean takes the residuals between the observations and their marginal means (i.e., <span class="math inline">\(\mathbf{Z}- \mathbf{X}\boldsymbol{\beta}\)</span>), weights them according to <span class="math inline">\(\mathbf{w}' \equiv \mathbf{c}_0' \mathbf{C}_z^{-1}\)</span>, and adds the result back onto the marginal mean corresponding to the prediction location (i.e., <span class="math inline">\(\mathbf{x}(\mathbf{s}_0;t_0)'\boldsymbol{\beta}\)</span>). Furthermore, the weights, <span class="math inline">\(\mathbf{w}\)</span>, are only a function of the covariances and the measurement-error variance. Another way to think of this is that the trend term <span class="math inline">\(\mathbf{x}(\mathbf{s}_0;t_0)' \boldsymbol{\beta}\)</span> is the mean of <span class="math inline">\(Y(\mathbf{s}_0;t_0)\)</span> <em>prior to</em> considering the observations; then the simple S-T kriging predictor combines this prior mean with a weighted average of the mean-corrected observations to get a new, conditional, mean. Similarly, if one interprets <span class="math inline">\(c_{0,0}\)</span> as the variance prior to considering the observations, then the conditional (on the data) variance reduces this initial variance by an amount given by <span class="math inline">\(\mathbf{c}_0' \mathbf{C}_z^{-1} \mathbf{c}_0\)</span>. Consider the following numerical example.</p>
<section id="example-simple-s-t-kriging" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="example-simple-s-t-kriging">Example: Simple S-T Kriging</h4>
<p>Suppose we have four observations in a one-dimensional space and a one-dimensional time domain: <span class="math inline">\(Z(2;0.2) = 15\)</span>, <span class="math inline">\(Z(2;1.0) = 22\)</span>, <span class="math inline">\(Z(6;0.2) = 17\)</span>, and <span class="math inline">\(Z(6;0.9) = 23\)</span>. We seek an S-T simple kriging prediction for <span class="math inline">\(Y(s_0;t_0) = Y(3;0.5)\)</span>. The data locations and prediction location are shown in <a href="#fig-STkrig_examp" class="quarto-xref">Figure&nbsp;<span>4.1</span></a>. Let <span class="math inline">\(x(s;t) = 1\)</span> for all <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span>, <span class="math inline">\(\beta = 20\)</span>, and <span class="math inline">\(\textrm{var}(Y(s;t)) = 2\)</span> for all <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span>. Using the spatio-temporal covariance function <a href="#eq-CH99" class="quarto-xref">Equation&nbsp;<span>4.13</span></a> discussed below (with parameters <span class="math inline">\(a=2\)</span>, <span class="math inline">\(b=0.2\)</span>, <span class="math inline">\(\sigma^2 = c_{0,0} = 2.0\)</span>, and <span class="math inline">\(d=1\)</span>), the covariance (between data) matrix <span class="math inline">\(\mathbf{C}_z\)</span>, the covariance (between the data and the latent <span class="math inline">\(Y(\cdot;\cdot)\)</span> at the prediction location) vector <span class="math inline">\(\mathbf{c}_0\)</span>, and the weights <span class="math inline">\(\mathbf{w}' = \mathbf{c}_0' \mathbf{C}_z^{-1}\)</span> are given by</p>
<p><span class="math display">\[
\mathbf{C}_z = \left[\begin{array}{rrrr}
    2.0000  &amp;  1.0600   &amp; 1.0546  &amp;  0.9364 \\
    1.0600  &amp;  2.0000  &amp;  0.8856  &amp;  1.0599 \\
    1.0546  &amp;  0.8856  &amp;  2.0000  &amp;  1.1625 \\
    0.9364  &amp;  1.0599 &amp;   1.1625  &amp;  2.0000
\end{array} \right],  \;\;
\mathbf{c}_0 = \left[\begin{array}{r} 1.6653 \\   1.3862 \\  1.3161  \\  1.2539 \end{array}
\right], \;\;
\mathbf{w}= \left[\begin{array}{r} 0.5377  \\  0.2565 \\   0.1841 \\   0.1323
\end{array}
\right].
\]</span></p>
<p>Substituting these matrices, vectors, and the data vector, <span class="math inline">\(\mathbf{Z}= (15,22,17,23)'\)</span>, into the formulas for the S-T kriging predictor <a href="#eq-STkrigpred" class="quarto-xref">Equation&nbsp;<span>4.6</span></a> and prediction variance <a href="#eq-STkrigvar" class="quarto-xref">Equation&nbsp;<span>4.7</span></a>, we obtain</p>
<p><span class="math display">\[
\begin{aligned}
  \widehat{Y}(3;0.5) &amp;= 17.67, \\
  \widehat{\sigma}^2_{Y,sk} &amp;= 0.34.
\end{aligned}
\]</span></p>
<p>Note that the S-T simple kriging prediction <span class="math inline">\((17.67)\)</span> is substantially smaller than the prior mean <span class="math inline">\((20)\)</span>, mainly because the highest weights are associated with the earlier times, which have smaller values. In addition, the S-T simple kriging prediction variance (<span class="math inline">\(0.34\)</span>) is much less than the prior variance <span class="math inline">\((2)\)</span>, as expected when there is strong spatio-temporal dependence.</p>
<div id="fig-STkrig_examp" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-STkrig_examp-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/Ch4_STkrig_example2.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-STkrig_examp-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.1: Data locations (blue dots) and prediction location (red dot) in a (one-dimensional) space-time domain for an example of S-T simple kriging. The data values and the S-T simple kriging prediction are given next to the locations. The S-T simple kriging weights associated with each data location are given in parentheses next to the dashed lines connecting the data locations to the prediction location.
</figcaption>
</figure>
</div>
<p>In most real-world problems, one would not know <span class="math inline">\(\boldsymbol{\beta}\)</span>. In this case, our optimal prediction problem is analogous to the estimation of effects in a linear mixed model, that is, in a model that considers the response in terms of both fixed effects (e.g., regression terms) and random effects, <span class="math inline">\(\boldsymbol{\eta}\)</span>. It is straightforward to show that the optimal linear unbiased predictor, or S-T <em>universal kriging</em> predictor of <span class="math inline">\(Y(\mathbf{s}_0;t_0)\)</span> is</p>
<p><span id="eq-ukYgls"><span class="math display">\[
\widehat{Y}(\mathbf{s}_0;t_0) = \mathbf{x}(\mathbf{s}_0;t_0)' \widehat{\boldsymbol{\beta}}_{\mathrm{gls}} + \mathbf{c}_0' \mathbf{C}_z^{-1} (\mathbf{Z}- \mathbf{X}\widehat{\boldsymbol{\beta}}_{\mathrm{gls}}),
\tag{4.8}\]</span></span></p>
<p>where the generalized least squares (gls) estimator of <span class="math inline">\(\boldsymbol{\beta}\)</span> is given by</p>
<p><span id="eq-beta_gls"><span class="math display">\[
\widehat{\boldsymbol{\beta}}_{\mathrm{gls}} \equiv (\mathbf{X}' \mathbf{C}_z^{-1} \mathbf{X})^{-1} \mathbf{X}' \mathbf{C}_z^{-1} \mathbf{Z}.
\tag{4.9}\]</span></span></p>
<p>The associated S-T universal kriging variance is given by</p>
<p><span id="eq-uk_var"><span class="math display">\[
\sigma^2_{Y,\mathrm{uk}}(\mathbf{s}_0;t_0) = c_{0,0} - \mathbf{c}_0' \mathbf{C}_z^{-1} \mathbf{c}_0 + \kappa,
\tag{4.10}\]</span></span></p>
<p>where</p>
<p><span class="math display">\[
\kappa \equiv (\mathbf{x}(\mathbf{s}_0;t_0) - \mathbf{X}' \mathbf{C}_z^{-1} \mathbf{c}_0)' (\mathbf{X}' \mathbf{C}_z^{-1} \mathbf{X})^{-1} (\mathbf{x}(\mathbf{s}_0;t_0) - \mathbf{X}' \mathbf{C}_z^{-1} \mathbf{c}_0)
\]</span></p>
<p>represents the additional uncertainty brought to the prediction (relative to S-T simple kriging) due to the estimation of <span class="math inline">\(\boldsymbol{\beta}\)</span>. We call <span class="math inline">\(\sigma_{Y,\mathrm{uk}}(\mathbf{s}_0;t_0)\)</span> the S-T universal kriging <em>prediction standard error</em>.</p>
<p>Both the S-T simple and universal kriging equations can be extended easily to accommodate prediction at many locations in space and time, including those at which we have observations. For example, in <a href="#fig-maxT-predictions" class="quarto-xref">Figure&nbsp;<span>4.2</span></a>, we show predictions of maximum temperature from data in the NOAA data set in July 1993 on a space-time grid (using a separable spatio-temporal covariance function, defined in <a href="#sec-covfun" class="quarto-xref"><span>Section 4.2.1</span></a>), with 14 July deliberately omitted from the data set. The respective prediction standard errors are shown in <a href="#fig-maxT-predictions" class="quarto-xref">Figure&nbsp;<span>4.2</span></a>, where those for 14 July are substantially larger. We produce these figures in Lab 4.1.</p>
<p>For readers who have some experience with spatial statistics, particularly geostatistics, the development given above in the spatio-temporal context will look very familiar. S-T simple, ordinary, and universal are the same as their spatial counterparts, but now in space <em>and</em> time.</p>
<p>So far, we have assumed that we know the variances and covariances that make up <span class="math inline">\(\mathbf{C}_y\)</span>, <span class="math inline">\(\mathbf{C}_\epsilon\)</span> (recall that <span class="math inline">\(\mathbf{C}_z = \mathbf{C}_y + \mathbf{C}_\epsilon\)</span>), <span class="math inline">\(\mathbf{c}_0\)</span>, and <span class="math inline">\(c_{0,0}\)</span>. Of course, in reality we would rarely (if ever) know these. The seemingly simple solution is to parameterize them, say in terms of parameters <span class="math inline">\(\boldsymbol{\theta}\)</span>, and then estimate them through maximum likelihood, restricted maximum likelihood (see <a href="#nte-technote-REML" class="quarto-xref">Note&nbsp;<span>4.2</span></a>) as in the classical linear mixed model, or perhaps through a fully implementation, in which case one specifies prior distributions for the elements of <span class="math inline">\(\boldsymbol{\theta}\)</span> (see <a href="#sec-LGestimation" class="quarto-xref"><span>Section 4.2.3</span></a>). As in spatial statistics, the parameterization of these covariance functions is one of the most challenging problems in spatio-temporal statistics.</p>
<div id="fig-maxT-predictions" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-maxT-predictions-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/STkrig_pred.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-maxT-predictions-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.2: Left: S-T universal predictions and right: prediction standard errors of maximum temperature (in degrees Fahrenheit) within a square lat-lon box enclosing the domain of interest for six days (each 5 days apart) in July 1993 using the <strong>R</strong> package <strong>gstat</strong>. Data for 14 July 1993 were omitted from the original data set.
</figcaption>
</figure>
</div>
</section>
<section id="sec-covfun" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="sec-covfun"><span class="header-section-number">4.2.1</span> Spatio-Temporal Covariance Functions</h3>
<p>We saw in the previous section that S-T predictors require that we know <span class="math inline">\(\mathbf{C}_z\)</span> and <span class="math inline">\(\mathbf{c}_0\)</span>, and hence we need to know the spatio-temporal covariances between the hidden random process evaluated at any two locations in space and time. It is important to note that <em>not any function can be used as a covariance function.</em> Let a general <em>spatio-temporal covariance function</em> be denoted by</p>
<p><span id="eq-c_star"><span class="math display">\[
c_*(\mathbf{s},\mathbf{s}';t,t') \equiv \textrm{cov}(Y(\mathbf{s};t),Y(\mathbf{s}';t')),
\tag{4.11}\]</span></span></p>
<p>which is appropriate only if the function is <em>valid</em> (i.e., non-negative-definite, which guarantees that the variances are non-negative). (Note that in <a href="#eq-c_star" class="quarto-xref">Equation&nbsp;<span>4.11</span></a> the primes are not transposes, but are used to denote different spatio-temporal locations.)</p>
<p>In practice, classical- implementations assume second-order stationarity: the random process is said to be <em>second-order</em> (or <em>weakly</em>) <em>stationary</em> if it has a constant expectation <span class="math inline">\(\mu\)</span> (say) and a covariance function that can be expressed in terms of spatial and temporal lags:</p>
<p><span class="math display">\[
c_*(\mathbf{s},\mathbf{s}';t,t') = c(\mathbf{s}' - \mathbf{s}; t' - t) = c(\mathbf{h}; \tau),
\]</span></p>
<p>where <span class="math inline">\(\mathbf{h}\equiv \mathbf{s}' - \mathbf{s}\)</span> and <span class="math inline">\(\tau \equiv t - t'\)</span> are the spatial and temporal lags, respectively. Recall from Chapter 2 that if the dependence on spatial lag is only a function of <span class="math inline">\(||\mathbf{h}||\)</span>, we say there is spatial <em></em>. Arguably, the two biggest benefits of the second-order stationarity assumption are that it allows for more parsimonious parameterizations of the covariance function, and that it provides pseudo-replication of dependencies at given lags in space and time, both of which facilitate estimation of the covariance function’s parameters. <span class="math inline">\((\)</span>In practice, it is unlikely that the spatio-temporal stationary covariance function is completely known and it is usually specified in terms of some parameters <span class="math inline">\(\boldsymbol{\theta}.)\)</span></p>
<p>The next question is how to obtain valid stationary (or non-stationary) spatio-temporal covariance functions. Mathematically speaking, how do we ensure that the functions we choose are non-negative-definite?</p>
<section id="separable-in-space-and-time-covariance-functions" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="separable-in-space-and-time-covariance-functions">Separable (in Space and Time) Covariance Functions</h4>
<p>Separable classes of spatio-temporal covariance functions have often been used in spatio-temporal modeling because they offer a convenient way to guarantee validity. The class is given by</p>
<p><span class="math display">\[
c(\mathbf{h};\tau) \equiv c^{(s)}(\mathbf{h}) \cdot c^{(t)}(\tau),
\]</span></p>
<p>which is valid if both the spatial covariance function, <span class="math inline">\(c^{(s)}(\mathbf{h})\)</span>, and the temporal covariance function, <span class="math inline">\(c^{(t)}(\tau)\)</span>, are valid. There are a large number of classes of valid spatial and valid temporal covariance functions in the literature (e.g., the Matérn, power exponential, and Gaussian classes, to name a few). For example, the exponential covariance function (which is a special case of both the Matérn covariance function and the power exponential covariance function) is given by</p>
<p><span class="math display">\[
c^{(s)}(\mathbf{h}) = \sigma_s^2 \exp\left\{- \frac{||\mathbf{h}||}{a_s}  \right\},
\]</span></p>
<p>where <span class="math inline">\(\sigma_s^2\)</span> is the variance parameter and <span class="math inline">\(a_s\)</span> is the spatial-dependence (or scale) parameter in units of distance. The larger <span class="math inline">\(a_s\)</span> is, the more dependent the spatial process is. Similarly, <span class="math inline">\(c^{(t)}(\tau) = \sigma_t^2 \exp\{-|\tau|/a_t\}\)</span> is a valid temporal covariance function (see <a href="#fig-exp_cov" class="quarto-xref">Figure&nbsp;<span>4.3</span></a> for an example).</p>
<div id="fig-exp_cov" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-exp_cov-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/exp_cov.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-exp_cov-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.3: Exponential covariance function for time lag <span class="math inline">\(\tau\)</span>, <span class="math inline">\(\sigma_t^2 = 2.5\)</span>, and <span class="math inline">\(a_t = 2\)</span>.
</figcaption>
</figure>
</div>
<p>A consequence of separability is that the resulting spatio-temporal correlation function, <span class="math inline">\(\rho(\mathbf{h};\tau) \equiv c(\mathbf{h};\tau)/c({\mathbf{0}};0)\)</span>, is given by</p>
<p><span class="math display">\[
\rho(\mathbf{h};\tau) = \rho^{(s)}(\mathbf{h};0) \cdot \rho^{(t)}({\mathbf{0}};\tau),
\]</span></p>
<p>where <span class="math inline">\(\rho^{(s)}(\mathbf{h};0)\)</span> and <span class="math inline">\(\rho^{(t)}({\mathbf{0}};\tau)\)</span> are the corresponding marginal spatial and temporal correlation functions, respectively. Thus, one only needs the marginal spatial and temporal correlation functions to obtain the joint spatio-temporal correlation function under separability. In addition, models facilitate computation. Notice (e.g., from <a href="#eq-STkrigpred" class="quarto-xref">Equation&nbsp;<span>4.6</span></a> and <a href="#eq-STkrigvar" class="quarto-xref">Equation&nbsp;<span>4.7</span></a>) that the inverse <span class="math inline">\(\mathbf{C}_z^{-1}\)</span> is ubiquitous in S-T equations. Separability can allow one to consider the inverse of the spatial and temporal components separately. For example, assume that <span class="math inline">\(Z(\mathbf{s}_{ij};t_j)\)</span> is observed at the same <span class="math inline">\(i=1,\ldots,m_j = m\)</span> locations at each time point, <span class="math inline">\(j=1,\ldots,T\)</span>. In this case, one can write <span class="math inline">\(\mathbf{C}_z = \mathbf{C}_z^{(t)} \otimes \mathbf{C}_z^{(s)}\)</span>, where <span class="math inline">\(\otimes\)</span> is the (see <a href="#nte-technote-Kronecker" class="quarto-xref">Note&nbsp;<span>4.1</span></a>), <span class="math inline">\(\mathbf{C}_z^{(t)}\)</span> is the <span class="math inline">\(T \times T\)</span> temporal covariance matrix, and <span class="math inline">\(\mathbf{C}_z^{(s)}\)</span> is the <span class="math inline">\(m \times m\)</span> spatial covariance matrix. Taking advantage of a useful property of s (see <a href="#nte-technote-Kronecker" class="quarto-xref">Note&nbsp;<span>4.1</span></a>), <span class="math inline">\(\mathbf{C}_z^{-1} = (\mathbf{C}_z^{(t)})^{-1} \otimes (\mathbf{C}_z^{(s)})^{-1}\)</span>, which shows that to take the inverse of the <span class="math inline">\(m T \times m T\)</span> matrix <span class="math inline">\(\mathbf{C}_z\)</span>, one only has to take the inverses of <span class="math inline">\(T \times T\)</span> and <span class="math inline">\(m \times m\)</span> matrices.</p>
<p>Consider the maximum-temperature observations (<code>Tmax</code>) from the NOAA data set presented in Chapter 2. After removing the obvious linear trend in latitude, we consider the empirical isotropic spatio-temporal covariance function (discussed in <a href="Chapter2.html#sec-STcovsemi" class="quarto-xref"><span>Section 2.4.2</span></a>) calculated for the residuals, shown in <a href="#fig-cov_fits" class="quarto-xref">Figure&nbsp;<span>4.4</span></a> (top left panel), and we compare that to the empirical model in <a href="#fig-cov_fits" class="quarto-xref">Figure&nbsp;<span>4.4</span></a> (top right panel). That is, we are simply considering the product of <span class="math inline">\(\hat{c}(0;|\tau|)\)</span> and <span class="math inline">\(\hat{c}(\|\mathbf{h}\|;0)\)</span>. Note that these two plots are remarkably similar, giving visual support for a model in this case. We shall discuss the lower two panels of this figure in <a href="#sec-LGestimation" class="quarto-xref"><span>Section 4.2.3</span></a>. See <span class="citation" data-cites="crujeiras2010nonparametric">Crujeiras, Fernández-Casal, and González-Manteiga (<a href="references.html#ref-crujeiras2010nonparametric" role="doc-biblioref">2010</a>)</span> and references therein for formal tests of separability.</p>
<div id="fig-cov_fits" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-cov_fits-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/contour_plots.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-cov_fits-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.4: Contour plot of the empirical covariance function (top left), fitted separable covariance function obtained by taking the product of <span class="math inline">\(\hat{c}^{(s)}(\|\mathbf{h}\|)\)</span> and <span class="math inline">\(\hat{c}^{(t)}(|\tau|)\)</span> (top right), fitted separable covariance function using the spatio-temporal separable model given in <a href="#eq-sep_cov" class="quarto-xref">Equation&nbsp;<span>4.18</span></a> and <a href="#eq-exp_cov" class="quarto-xref">Equation&nbsp;<span>4.19</span></a> (bottom left) and fitted covariance function using the non-separable model given in <a href="#eq-metric_cov" class="quarto-xref">Equation&nbsp;<span>4.20</span></a> (bottom right).
</figcaption>
</figure>
</div>
<p>A consequence of the separability property is that the temporal evolution of the process at a given spatial location does not depend directly on the process’ temporal evolution at other locations. As we discuss in Chapter 5, this is very seldom the case for real-world processes as it implies no interaction across space and time. The question then becomes, “how can we obtain other classes of spatio-temporal covariance functions?” Several approaches that have been developed in the literature: (i) sums-and-products formulation; (ii) construction by a spectral representation through <strong>Bochner’s theorem</strong> (which formally relates the spectral representation to the covariance representation; e.g., the inverse Fourier transform is a special case); and (iii) covariance functions from the solution of stochastic partial differential equations (SPDEs). We discuss these briefly below.</p>
<div id="nte-technote-Kronecker" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;4.1: Kronecker Products
</div>
</div>
<div class="callout-body-container callout-body">
<p>Consider two matrices, an <span class="math inline">\(n_a \times m_a\)</span> matrix, <span class="math inline">\(\mathbf{A}\)</span>, and an <span class="math inline">\(n_b \times m_b\)</span> matrix, <span class="math inline">\(\mathbf{B}\)</span>. The Kronecker product is given by the <span class="math inline">\(n_a n_b \times m_a m_b\)</span> matrix <span class="math inline">\(\mathbf{A}\otimes \mathbf{B}\)</span> defined as <span class="math display">\[
\mathbf{A}\otimes \mathbf{B}= \left[\begin{array}{ccc}
a_{11} \mathbf{B}&amp; \cdots &amp; a_{1 m_a} \mathbf{B}\\
\vdots &amp; \vdots &amp; \vdots \\
a_{n_a 1} \mathbf{B}&amp; \cdots &amp; a_{n_a m_a} \mathbf{B}
\end{array}\right].
\]</span> The <strong>Kronecker product</strong> has some nice properties that facilitate matrix representations. For example, if <span class="math inline">\(\mathbf{A}\)</span> is <span class="math inline">\(n_a \times n_a\)</span> and <span class="math inline">\(\mathbf{B}\)</span> is <span class="math inline">\(n_b \times n_b\)</span>, the inverse and determinants can be expressed in terms of the individual matrices: <span class="math display">\[\begin{align*}
(\mathbf{A}\otimes \mathbf{B})^{-1} &amp;= \mathbf{A}^{-1} \otimes \mathbf{B}^{-1},\\
|\mathbf{A}\otimes \mathbf{B}| &amp;= |\mathbf{A}|^{n_b} \; |\mathbf{B}|^{n_a}.
\end{align*}\]</span></p>
<p>In the context of spatio-temporal processes, Kronecker products are useful in at least two ways. First, they provide a convenient way to represent spatio-temporal covariance matrices for processes. That is, consider <span class="math inline">\(\{Y(\mathbf{s}_i;t_j): i=1,\ldots,m;\ j=1,\ldots,T\}\)</span> and define <span class="math inline">\(\mathbf{C}_y^{(s)}\)</span> to be the <span class="math inline">\(m \times m\)</span> matrix of purely spatial covariances and <span class="math inline">\(\mathbf{C}_y^{(t)}\)</span> to be the <span class="math inline">\(T \times T\)</span> matrix of purely temporal covariances. Then the <span class="math inline">\(mT \times mT\)</span> spatio-temporal covariance matrix can be written as, <span class="math inline">\(\mathbf{C}_y = \mathbf{C}_y^{(t)} \otimes \mathbf{C}_y^{(s)}\)</span> if the process is . Although this may not be realistic for many processes, it is advantageous because of the inverse property, <span class="math inline">\(\mathbf{C}_y^{-1} = (\mathbf{C}_y^{(t)})^{-1} \otimes (\mathbf{C}_y^{(s)})^{-1}\)</span>; see <a href="#sec-covfun" class="quarto-xref"><span>Section 4.2.1</span></a>.</p>
<p>The second way that s are useful for spatio-temporal modeling is for forming spatio-temporal , which we discuss in <a href="#sec-basisfunctions" class="quarto-xref"><span>Section 4.4</span></a>. In particular, if we construct an <span class="math inline">\(m \times n_{\alpha,s}\)</span> matrix <span class="math inline">\(\boldsymbol{\Phi}\)</span> by evaluating <span class="math inline">\(n_{\alpha,s}\)</span> spatial basis functions at <span class="math inline">\(m\)</span> spatial locations, and a <span class="math inline">\(T \times n_{\alpha,t}\)</span> matrix <span class="math inline">\(\boldsymbol{\Psi}\)</span> by evaluating <span class="math inline">\(n_{\alpha,t}\)</span> temporal basis functions at <span class="math inline">\(T\)</span> temporal locations, then the matrix constructed from spatio-temporal basis functions formed through the <em>tensor product</em> of the spatial and temporal basis functions and evaluated at all combinations of spatial and temporal locations is given by the <span class="math inline">\(m T \times n_{\alpha,s} n_{\alpha,t}\)</span> matrix <span class="math inline">\(\mathbf{B}= \boldsymbol{\Psi}\otimes \boldsymbol{\Phi}\)</span>. Basis functions can be used to construct spatio-temporal covariance functions. Note that using a set of basis functions constructed through the yields a class of <em>spatio-temporal covariance functions</em> that are in general not separable.</p>
</div>
</div>
</section>
<section id="sums-and-products-formulation" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="sums-and-products-formulation">Sums-and-Products Formulation</h4>
<p>There is a useful result in mathematics that states that, as well as the product, the <em>sum</em> of two non-negative-definite functions is non-negative-definite. This allows us to construct valid spatio-temporal covariance functions as the product and/or sum of valid covariance functions. For example,</p>
<p><span id="eq-sumsandprods"><span class="math display">\[
c(\mathbf{h};\tau) \equiv p \; c_1^{(s)}(\mathbf{h}) \cdot c_1^{(t)}(\tau) + q \; c_2^{(s)}(\mathbf{h}) + r  \; c_2^{(t)}(\tau)
\tag{4.12}\]</span></span></p>
<p>is a valid spatio-temporal covariance function when <span class="math inline">\(p &gt; 0\)</span>, <span class="math inline">\(q \ge 0\)</span>, <span class="math inline">\(r \ge 0\)</span>; <span class="math inline">\(c_1^{(s)}(\mathbf{h})\)</span> and <span class="math inline">\(c_2^{(s)}(\mathbf{h})\)</span> are valid spatial covariance functions; and <span class="math inline">\(c_1^{(t)}(\tau)\)</span> and <span class="math inline">\(c_2^{(t)}(\tau)\)</span> are valid temporal covariance functions. Of course, <a href="#eq-sumsandprods" class="quarto-xref">Equation&nbsp;<span>4.12</span></a> can be extended to include the sum of many terms and the result is non-negative definite if each component covariance function is non-negative-definite.</p>
<p>The sums-and-products formulation above points to connections between separable covariance functions and other special cases. For example, consider the <em>fully symmetric</em> spatio-temporal covariance functions: a spatio-temporal random process <span class="math inline">\(\{Y(\mathbf{s};t)\}\)</span> is said to have a fully symmetric spatio-temporal covariance function if, for all spatial locations <span class="math inline">\(\mathbf{s}, \mathbf{s}'\)</span> in the spatial domain of interest and time points <span class="math inline">\(t, t'\)</span> in the temporal domain of interest, we can write</p>
<p><span class="math display">\[
\textrm{cov}(Y(\mathbf{s};t),Y(\mathbf{s}';t')) = \textrm{cov}(Y(\mathbf{s};t'),Y(\mathbf{s}';t)).
\]</span></p>
<p>Using such covariances to model spatio-temporal dependence is not always reasonable for real-world processes. For example, is it reasonable that the covariance between yesterday’s temperature in London and today’s temperature in Paris is the same as that between yesterday’s temperature in Paris and today’s temperature in London? Such a relationship might be appropriate under certain meteorological conditions, but not in general (imagine a weather system moving from northwest to southeast across Europe). So, for scientific reasons or as a result of an exploratory data analysis, the fully symmetric covariance function may not be an appropriate choice.</p>
<p>Now, note that the covariance given by <a href="#eq-sumsandprods" class="quarto-xref">Equation&nbsp;<span>4.12</span></a> is an example of a fully symmetric covariance, but it is only separable if <span class="math inline">\(q=r=0\)</span>. In general, separable covariance functions are always fully symmetric, while the converse is not true.</p>
</section>
<section id="construction-via-a-spectral-representation" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="construction-via-a-spectral-representation">Construction via a Spectral Representation</h4>
<p>An important example of the construction approach to spatio-temporal covariance function development was given by <span class="citation" data-cites="cressie1999classes">Noel Cressie and Huang (<a href="references.html#ref-cressie1999classes" role="doc-biblioref">1999</a>)</span>. They were able to cast the problem in the spectral domain so that one only needs to choose a one-dimensional positive-definite function of time lag in order to obtain a class of valid non-separable spatio-temporal covariance functions. In their Example 1, they construct the stationary spatio-temporal covariance function,</p>
<p><span id="eq-CH99"><span class="math display">\[
c(\mathbf{h};\tau) = \sigma^2 \exp\{-b^2 ||\mathbf{h}||^2/(a^2 \tau^2 + 1)\}/(a^2 \tau^2 + 1)^{d/2},
\tag{4.13}\]</span></span></p>
<p>where <span class="math inline">\(\sigma^2 =c({\mathbf{0}};0)\)</span>, <span class="math inline">\(d\)</span> corresponds to the spatial dimension (often <span class="math inline">\(d=2\)</span>), and <span class="math inline">\(a \ge 0\)</span> and <span class="math inline">\(b \ge 0\)</span> are scale parameters in space and time, respectively. There are other classes of such spatio-temporal models, and this has been an active area of research in the past few decades <span class="citation" data-cites="Montero2015spatial">(see the overview in <a href="references.html#ref-Montero2015spatial" role="doc-biblioref">Montero, Fernández-Avilés, and Mateu 2015</a>)</span>.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>In this book we limit our focus to <strong>gstat</strong> when doing S-T kriging. However, there are numerous other packages in <code>R</code> that could be used. Among these <strong>CompRandFld</strong> and <strong>RandomFields</strong> are worth noting because of the large selection of non-separable spatio-temporal covariance functions they make available to the user.</p>
</div>
</div>
</section>
<section id="stochastic-partial-differential-equation-spde-approach" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="stochastic-partial-differential-equation-spde-approach">Stochastic Partial Differential Equation (SPDE) Approach</h4>
<p>The SPDE approach to deriving spatio-temporal covariance functions was originally inspired by statistical physics, where physical equations forced by random processes that describe advective, diffusive, and decay behavior were used to describe the second moments of macro-scale processes, at least in principle. A famous example of this approach in spatial statistics resulted in the ubiquitous Matérn spatial covariance function, which was originally derived as the solution to a fractional stochastic diffusion equation and has been extended by several authors <span class="citation" data-cites="Montero2015spatial">(e.g., <a href="references.html#ref-Montero2015spatial" role="doc-biblioref">Montero, Fernández-Avilés, and Mateu 2015</a>)</span>.</p>
<p>Although such an approach can suggest non-separable spatio-temporal covariance functions, only a few special (simple) cases lead to closed-form functions <span class="citation" data-cites="cressie2011statistics">N. Cressie and Wikle (<a href="references.html#ref-cressie2011statistics" role="doc-biblioref">2011</a>)</span>. Perhaps more importantly, although these models appear to have a physical basis through the SPDE, macro-scale real-world processes of interest are seldom this simple (e.g., linear and stationary in space and/or time). That is, the spatio-temporal covariance functions that can be obtained in closed form from SPDEs are seldom directly appropriate models for physical processes (but may still provide good fits to data).</p>
</section>
</section>
<section id="spatio-temporal-semivariograms" class="level3" data-number="4.2.2">
<h3 data-number="4.2.2" class="anchored" data-anchor-id="spatio-temporal-semivariograms"><span class="header-section-number">4.2.2</span> Spatio-Temporal Semivariograms</h3>
<p>Historically, it has been common in the area of spatial statistics known as geostatistics to consider dependence through the variogram. In the context of a spatio-temporal random process <span class="math inline">\(\{Y(\mathbf{s};t)\}\)</span>, the <em>spatio-temporal variogram</em> is defined as</p>
<p><span id="eq-STvariogram"><span class="math display">\[
\textrm{var}(Y(\mathbf{s};t) - Y(\mathbf{s}';t')) \equiv 2 \gamma(\mathbf{s},\mathbf{s}';t,t'),
\tag{4.14}\]</span></span></p>
<p>where <span class="math inline">\(\gamma( \cdot)\)</span> is called the <em></em> (see <a href="Chapter2.html#nte-technote-semivariogram" class="quarto-xref">Note&nbsp;<span>2.1</span></a>). The stationary version of the spatio-temporal variogram is denoted by <span class="math inline">\(2 \gamma(\mathbf{h};\tau)\)</span>, where <span class="math inline">\(\mathbf{h}= \mathbf{s}' - \mathbf{s}\)</span> and <span class="math inline">\(\tau = t' - t\)</span>, analogous to the stationary-covariance representation given previously. The underlying process <span class="math inline">\(Y\)</span> is considered to be <em>intrinsically stationary</em> if it has a constant expectation and a stationary variogram. When the process is second-order stationary (second-order stationarity is a stronger restriction than intrinsic stationarity), there is a useful and simple relationship between the spatio-temporal and the covariance function, namely,</p>
<p><span id="eq-var2ndorder"><span class="math display">\[
\gamma(\mathbf{h};\tau) = c(\mathbf{0};0) - c(\mathbf{h};\tau).
\tag{4.15}\]</span></span></p>
<p>Notice that strong spatio-temporal dependence corresponds to small values of the . Thus, contour plots of <span class="math inline">\(\{\gamma(\mathbf{h};\tau)\}\)</span> in <a href="#eq-var2ndorder" class="quarto-xref">Equation&nbsp;<span>4.15</span></a> start near zero close to the origin <span class="math inline">\((\mathbf{h};\tau) = (\mathbf{0},0)\)</span>, and they rise to a constant value (the “sill”) as both <span class="math inline">\(\mathbf{h}\)</span> and <span class="math inline">\(\tau\)</span> move away from the origin.</p>
<p>Although there has been a preference to consider dependence through the variogram in geostatistics, this has not been the case in more mainstream spatio-temporal statistical analyses. The primary reason for this is that most real-world processes are best characterized in the context of <em>local</em> second-order stationarity. The difference between intrinsic stationarity and second-order stationarity is most appreciated when the lags <span class="math inline">\(\mathbf{h}\)</span> and <span class="math inline">\(\tau\)</span> are large. If only local stationarity is expected and modeled, the extra generality given by the variogram is not needed. Still, the empirical semivariogram offers a useful way to summarize the spatio-temporal dependence in the data and to fit a spatio-temporal covariance function.</p>
<p>On a theoretical level, the stationary variogram allows S-T for a larger class of processes (i.e., intrinsically stationary processes) than the second-order stationary processes. A price to pay for this extra generality is the extreme caution needed when using the variogram to find optimal coefficients. <span class="citation" data-cites="cressie2011statistics">N. Cressie and Wikle (<a href="references.html#ref-cressie2011statistics" role="doc-biblioref">2011, 148</a>)</span> point out that the universal- weights may not sum to 1 and, in situations where they do not, the resulting variogram-based predictor will not be optimal. However, when using the covariance-based predictor, there are no such issues and it is always optimal.</p>
<p>In addition, on a more practical level, most spatio-temporal analyses consider models that are specified from a likelihood perspective or a perspective, where covariance matrices are needed. The variogram by itself does not specify the covariance matrix, since one also needs to model the variance function <span class="math inline">\(\sigma^2(\mathbf{s};t) \equiv \textrm{var}(Y(\mathbf{s};t))\)</span>, which is usually impractical unless it is stationary and does not depend on <span class="math inline">\(\mathbf{s}\)</span> and <span class="math inline">\(t\)</span>. Some software packages that perform S-T , such as <strong>gstat</strong>, fit variogram functions to data, mainly for historical reasons and because of the implicit assumption in <a href="#eq-STvariogram" class="quarto-xref">Equation&nbsp;<span>4.14</span></a> that a constant mean need not be assumed when estimating the variogram. (This is generally a good thing because the constant mean assumption is tenuous in practice, since the mean for real-world processes typically depends on exogenous covariates that vary with space and time.)</p>
</section>
<section id="sec-LGestimation" class="level3" data-number="4.2.3">
<h3 data-number="4.2.3" class="anchored" data-anchor-id="sec-LGestimation"><span class="header-section-number">4.2.3</span> Gaussian Spatio-Temporal Model Estimation</h3>
<p>The spatio-temporal covariance and variogram functions presented above depend on unknown parameters. These are almost never known in practice and must be estimated from the data. There is a history in spatial statistics of fitting covariance functions (or semivariograms) directly to the empirical estimates – for example, by using a least squares or weighted least squares approach . However, in the spatio-temporal context we prefer to consider fully parameterized covariance models and infer the parameters through likelihood-based methods or through fully methods. This follows closely the approaches in mixed-linear-model parameter estimation; for an overview, see <span class="citation" data-cites="mcculloch2001generalized">McCulloch and Searle (<a href="references.html#ref-mcculloch2001generalized" role="doc-biblioref">2001</a>)</span>. We briefly describe the likelihood-based approach and the approach below.</p>
<section id="likelihood-estimation" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="likelihood-estimation">Likelihood Estimation</h4>
<p>Given the data model <a href="#eq-Zdata_vec" class="quarto-xref">Equation&nbsp;<span>4.3</span></a>, note that <span class="math inline">\(\mathbf{C}_z = \mathbf{C}_y + \mathbf{C}_\epsilon\)</span>. Then, in obvious notation, <span class="math inline">\(\mathbf{C}_z\)</span> depends on parameters <span class="math inline">\(\boldsymbol{\theta}\equiv \{\boldsymbol{\theta}_y,\boldsymbol{\theta}_\epsilon\}\)</span> for the covariance functions of the hidden process <span class="math inline">\(Y\)</span> and the measurement-error process <span class="math inline">\(\epsilon\)</span>, respectively. The likelihood can then be written as</p>
<p><span id="eq-Zlike"><span class="math display">\[
L(\boldsymbol{\beta},\boldsymbol{\theta}; \mathbf{Z}) \propto |\mathbf{C}_z(\boldsymbol{\theta})|^{-1/2} \exp\left\{-\frac{1}{2}(\mathbf{Z}- \mathbf{X}\boldsymbol{\beta})'(\mathbf{C}_z(\boldsymbol{\theta}))^{-1}(\mathbf{Z}- \mathbf{X}\boldsymbol{\beta})\right\},
\tag{4.16}\]</span></span></p>
<p>and we maximize this with respect to <span class="math inline">\(\{\boldsymbol{\beta},\boldsymbol{\theta}\}\)</span>, thus obtaining the maximum likelihood estimates (MLEs), <span class="math inline">\(\{\widehat{\boldsymbol{\beta}}_{\mathrm{mle}}, \widehat{\boldsymbol{\theta}}_{\mathrm{mle}}\}\)</span>. Because the covariance parameters appear in the matrix inverse and determinant in <a href="#eq-Zlike" class="quarto-xref">Equation&nbsp;<span>4.16</span></a>, analytical maximization for most parametric covariance models is not possible, but numerical methods can be used. To reduce the number of parameters in this maximization, we often consider “profiling,” where we replace <span class="math inline">\(\boldsymbol{\beta}\)</span> in <a href="#eq-Zlike" class="quarto-xref">Equation&nbsp;<span>4.16</span></a> with the generalized least squares estimator, <span class="math inline">\({\boldsymbol{\beta}}_{\mathrm{gls}} = (\mathbf{X}' \mathbf{C}_z(\boldsymbol{\theta})^{-1} \mathbf{X})^{-1} \mathbf{X}' \mathbf{C}_z(\boldsymbol{\theta})^{-1} \mathbf{Z}\)</span> (which depends only on <span class="math inline">\(\boldsymbol{\theta}\)</span>). Then the profile likelihood is just a function of the unknown parameters <span class="math inline">\(\boldsymbol{\theta}\)</span>. Using a numerical optimization method (e.g., Newton–Raphson) to obtain <span class="math inline">\(\widehat{\boldsymbol{\theta}}_{\mathrm{mle}}\)</span>, we then obtain <span class="math inline">\(\widehat{\boldsymbol{\beta}}_{\mathrm{mle}} = (\mathbf{X}' \mathbf{C}_z(\widehat{\boldsymbol{\theta}}_{\mathrm{mle}})^{-1} \mathbf{X})^{-1} \mathbf{X}' \mathbf{C}_z(\widehat{\boldsymbol{\theta}}_{\mathrm{mle}})^{-1} \mathbf{Z}\)</span>, which is the MLE of <span class="math inline">\(\boldsymbol{\beta}\)</span>. The parameter estimates <span class="math inline">\(\{\widehat{\boldsymbol{\beta}}_{\mathrm{mle}}, \widehat{\boldsymbol{\theta}}_{\mathrm{mle}}\}\)</span> are then substituted into the kriging equations above (e.g., <a href="#eq-ukYgls" class="quarto-xref">Equation&nbsp;<span>4.8</span></a> and <a href="#eq-uk_var" class="quarto-xref">Equation&nbsp;<span>4.10</span></a>) to obtain the empirical best linear unbiased predictor (EBLUP) and the associated empirical prediction variance.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Maximizing the log-likelihood (i.e., the <span class="math inline">\(\log\)</span> of <a href="#eq-Zlike" class="quarto-xref">Equation&nbsp;<span>4.16</span></a>) in <strong>R</strong> can be done in a number of ways. Among the most popular functions in base <strong>R</strong> are <code>nlm</code>, which implements a Newton-type algorithm, and <code>optim</code>, which contains a number of general-purpose routines, some of which are gradient-based. When a simple covariance function is used, the gradient can be found analytically, and gradient information may then be used to facilitate optimization. Many of the parameters in our models (such as the variance or dependence-scale parameters) need to be positive to ensure positive-definite covariance matrices. This can be easily achieved by finding the MLEs of the log of the parameters, instead of the parameters themselves. Then the MLE of the parameter on the original scale is obtained by exponentiating the MLE on the log scale. In this case, one typically uses the <em>delta method</em> to obtain the variance of the transformed parameter estimates <span class="citation" data-cites="kendall1969advanced">(see, for example, <a href="references.html#ref-kendall1969advanced" role="doc-biblioref">Kendall and Stuart 1969</a>)</span>.</p>
</div>
</div>
<p>As described in <a href="#nte-technote-REML" class="quarto-xref">Note&nbsp;<span>4.2</span></a>, restricted maximum likelihood (REML) considers the likelihood of a linear transformation of the data vector such that the errors are orthogonal to the <span class="math inline">\(\mathbf{X}\)</span>s that make up the mean function. Numerical maximization of the associated likelihood, which is only a function of the parameters <span class="math inline">\(\boldsymbol{\theta}\)</span> (i.e., not of <span class="math inline">\(\boldsymbol{\beta}\)</span>), gives <span class="math inline">\(\widehat{\boldsymbol{\theta}}_{\mathrm{reml}}\)</span>. These estimates are substituted into <a href="#eq-beta_gls" class="quarto-xref">Equation&nbsp;<span>4.9</span></a>, the GLS formula for <span class="math inline">\(\boldsymbol{\beta}\)</span>, to obtain <span class="math inline">\(\widehat{\boldsymbol{\beta}}_{\mathrm{reml}}\)</span> as well as the kriging equations <a href="#eq-ukYgls" class="quarto-xref">Equation&nbsp;<span>4.8</span></a> and <a href="#eq-uk_var" class="quarto-xref">Equation&nbsp;<span>4.10</span></a>.</p>
<p>Both the MLE and REML approaches have the advantage that they are based on the “likelihood principle” and, assuming that the Gaussian distributional assumptions are correct, they have desirable properties such as sufficiency, invariance, consistency, efficiency, and asymptotic normality. In mixed-effects models and in spatial statistics, REML is usually preferred over MLE for estimation of covariance parameters because REML typically has less bias in small samples <span class="citation" data-cites="wu2001comparison">(see, for example, the overview in <a href="references.html#ref-wu2001comparison" role="doc-biblioref">Wu, Gumpertz, and Boos 2001</a>)</span>.</p>
<div id="nte-technote-REML" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;4.2: Restricted Maximum Likelihood
</div>
</div>
<div class="callout-body-container callout-body">
<p>Consider a contrast matrix <span class="math inline">\(\mathbf{K}\)</span> such that <span class="math inline">\(E(\mathbf{K}\mathbf{Z}) = \mathbf{0}\)</span>. For example, let <span class="math inline">\(\mathbf{K}\)</span> be an <span class="math inline">\((m - p ) \times m\)</span> matrix orthogonal to the column space of the <span class="math inline">\(m \times p\)</span> design matrix <span class="math inline">\(\mathbf{X}\)</span>. That is, let <span class="math inline">\(\mathbf{K}\)</span> correspond to the <span class="math inline">\(m - p\)</span> linearly independent rows of <span class="math inline">\((\mathbf{I}- \mathbf{X}(\mathbf{X}' \mathbf{X})^{-1} \mathbf{X}')\)</span>. Because <span class="math inline">\(\mathbf{K}\mathbf{X}= \mathbf{0}\)</span>, it follows that <span class="math inline">\(E(\mathbf{K}\mathbf{Z}) = \mathbf{K}\mathbf{X}\boldsymbol{\beta}= \mathbf{0}\)</span>, and <span class="math inline">\(\textrm{var}(\mathbf{K}\mathbf{Z}) = \mathbf{K}\mathbf{C}_z(\boldsymbol{\theta}) \mathbf{K}'\)</span>. In this case, the likelihood based on <span class="math inline">\(\mathbf{K}\mathbf{Z}\)</span> is not a function of the mean parameters <span class="math inline">\(\boldsymbol{\beta}\)</span> and is given by</p>
<p><span id="eq-Lreml"><span class="math display">\[
L_{\mathrm{reml}}(\boldsymbol{\theta};\mathbf{Z}) \propto |\mathbf{K}\mathbf{C}_z(\boldsymbol{\theta}) \mathbf{K}'|^{-1/2} \exp\left\{-\frac{1}{2}(\mathbf{K}\mathbf{Z})'(\mathbf{K}\mathbf{C}_z(\boldsymbol{\theta}) \mathbf{K}')^{-1}(\mathbf{K}\mathbf{Z}) \right\}.
\tag{4.17}\]</span></span></p>
<p>Then <a href="#eq-Lreml" class="quarto-xref">Equation&nbsp;<span>4.17</span></a> is maximized numerically to obtain <span class="math inline">\(\widehat{\boldsymbol{\theta}}_{\mathrm{reml}}\)</span>. Note that parameter estimation and statistical inference with REML do not depend on the specific choice of <span class="math inline">\(\mathbf{K}\)</span>, so long as it is a contrast matrix that leads to <span class="math inline">\(E(\mathbf{K}\mathbf{Z}) = \mathbf{0}\)</span> <span class="citation" data-cites="patterson1971recovery">(<a href="references.html#ref-patterson1971recovery" role="doc-biblioref">Patterson and Thompson 1971</a>)</span>. One can then use these estimates in a GLS estimate of <span class="math inline">\(\boldsymbol{\beta}\)</span>: <span class="math inline">\(\widehat{\boldsymbol{\beta}}_{\mathrm{reml}} \equiv (\mathbf{X}' \mathbf{C}_z(\widehat{\boldsymbol{\theta}}_{\mathrm{reml}})^{-1} \mathbf{X})^{-1} \mathbf{X}' \mathbf{C}_z(\widehat{\boldsymbol{\theta}}_{\mathrm{reml}})^{-1} \mathbf{Z}\)</span>.</p>
</div>
</div>
</section>
<section id="bayesian-inference" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="bayesian-inference">Bayesian Inference</h4>
<p>Instead of treating <span class="math inline">\(\boldsymbol{\beta}\)</span> and <span class="math inline">\(\boldsymbol{\theta}\)</span> as fixed, unknown, and to be estimated (e.g., from the likelihood), prior distributions <span class="math inline">\([\boldsymbol{\beta}]\)</span> and <span class="math inline">\([\boldsymbol{\theta}]\)</span> (often assumed independent) could be posited for the mean parameters <span class="math inline">\(\boldsymbol{\beta}\)</span> and the covariance parameters <span class="math inline">\(\boldsymbol{\theta}\)</span>, respectively. Typical choices for <span class="math inline">\([\boldsymbol{\theta}]\)</span> do not admit closed-form posterior distributions for <span class="math inline">\([Y(\mathbf{s}_0) | \mathbf{Z}]\)</span>, which means that the predictor <span class="math inline">\(E(Y(\mathbf{s}_0;t_0) | \mathbf{Z})\)</span> and the associated uncertainty, <span class="math inline">\(\textrm{var}(Y(\mathbf{s}_0;t_0) | \mathbf{Z})\)</span>, are not available in closed form and must be obtained through numerical evaluation of the posterior distribution (for more details, see <a href="#sec-BHMest" class="quarto-xref"><span>Section 4.5.2</span></a> below; <span class="citation" data-cites="cressie2011statistics">N. Cressie and Wikle (<a href="references.html#ref-cressie2011statistics" role="doc-biblioref">2011</a>)</span>; <span class="citation" data-cites="banerjee2015hierarchical">Banerjee, Carlin, and Gelfand (<a href="references.html#ref-banerjee2015hierarchical" role="doc-biblioref">2015</a>)</span>).</p>
</section>
<section id="example-s-t-kriging" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="example-s-t-kriging">Example: S-T Kriging</h4>
<p>Consider the maximum-temperature observations in the NOAA data set <code>Tmax</code>. The empirical covariogram of these data is shown in the top left panel of <a href="#fig-cov_fits" class="quarto-xref">Figure&nbsp;<span>4.4</span></a>. Consider two spatio-temporal covariance functions fitted to the residuals from a model with a regression component that includes an intercept and latitude as a covariate. The first of these covariance functions is given by an isotropic and stationary separable model of the form</p>
<p><span id="eq-sep_cov"><span class="math display">\[
c^{(\mathrm{sep})}(\| \mathbf{h}\| ; | \tau|) \equiv c^{(s)}(\| \mathbf{h}\|) \cdot c^{(t)}(|\tau|),
\tag{4.18}\]</span></span></p>
<p>in which we let both covariance functions, <span class="math inline">\(c^{(s)}(\cdot)\)</span> and <span class="math inline">\(c^{(t)}(\cdot)\)</span>, take the form</p>
<p><span id="eq-exp_cov"><span class="math display">\[
c^{(\cdot)}(h) = b_1\exp(-\phi h) + b_2I(h=0),
\tag{4.19}\]</span></span></p>
<p>where <span class="math inline">\(\phi\)</span>, <span class="math inline">\(b_1\)</span>, and <span class="math inline">\(b_2\)</span> are parameters that are different for <span class="math inline">\(c^{(s)}(\cdot)\)</span> and <span class="math inline">\(c^{(t)}(\cdot)\)</span> and need to be estimated; and <span class="math inline">\(I(\cdot)\)</span> is the indicator function that is used to represent the so-called <em>nugget effect</em>, made up of the measurement-error variance plus the micro-scale variation. The fitted model is shown in the bottom left panel of <a href="#fig-cov_fits" class="quarto-xref">Figure&nbsp;<span>4.4</span></a>.</p>
<p>The second model we fit is a non-separable spatio-temporal covariance function, in which the temporal lag is scaled to account for the different nature of space and time. This model is given by</p>
<p><span id="eq-metric_cov"><span class="math display">\[
c^{(\mathrm{st})}(\| \mathbf{v}_a \|) \equiv b_1\exp(-\phi \| \mathbf{v}_a \|) + b_2I(\| \mathbf{v}_a \| = 0),
\tag{4.20}\]</span></span></p>
<p>where <span class="math inline">\(\mathbf{v}_a \equiv (\mathbf{h}',a \tau)'\)</span>, and recall that <span class="math inline">\(||\mathbf{v}_a|| = (\mathbf{h}' \mathbf{h}+ a^2 \tau^2)^{1/2}\)</span>. Here, <span class="math inline">\(a\)</span> is the scaling factor used for generating the space-time anisotropy. The fitted model is shown in the bottom right panel of <a href="#fig-cov_fits" class="quarto-xref">Figure&nbsp;<span>4.4</span></a>.</p>
<p>The non-separable spatio-temporal covariance function (<a href="#eq-metric_cov" class="quarto-xref">Equation&nbsp;<span>4.20</span></a>) allows for space-time anisotropy, but it is otherwise relatively inflexible. It only contains one parameter (<span class="math inline">\(a\)</span>) to account for the different scaling needed for space and time, one parameter (<span class="math inline">\(\phi\)</span>) for the length scale, and two parameters to specify the variance (the nugget effect, <span class="math inline">\(b_2\)</span>, and the variance of the smooth component, <span class="math inline">\(b_1\)</span>). Thus, <a href="#eq-metric_cov" class="quarto-xref">Equation&nbsp;<span>4.20</span></a> has a total of four parameters, in contrast to the six parameters in <a href="#eq-sep_cov" class="quarto-xref">Equation&nbsp;<span>4.18</span></a>. This results in a relatively poor fit to the <code>Tmax</code> data from the NOAA data set. In this case, the separable model is able to provide a better reconstruction of the empirical covariance function despite its lack of space-time interaction, which is not surprising given that the fitted separable covariance function (<a href="#fig-cov_fits" class="quarto-xref">Figure&nbsp;<span>4.4</span></a>, top right) is visually similar to the empirical spatio-temporal covariance function (<a href="#fig-cov_fits" class="quarto-xref">Figure&nbsp;<span>4.4</span></a>, top left). We note that although the separable model fits better in this case, it is still a rather unrealistic model for most processes of interest.</p>
</section>
</section>
</section>
<section id="sec-randomeffects" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="sec-randomeffects"><span class="header-section-number">4.3</span> Random-Effects Parameterizations</h2>
<p>As discussed previously, it can be difficult to specify realistic valid spatio-temporal covariance functions and to work with large spatio-temporal covariance matrices (e.g., <span class="math inline">\(\mathbf{C}_z\)</span>) in situations with large numbers of prediction or observation locations. One way to mitigate these problems is to take advantage of <em>conditional</em> specifications that the hierarchical modeling framework allows.</p>
<p>We can consider classical linear mixed models from either a conditional perspective, where we condition the response on the random effects, or from a marginal perspective, where the random effects have been averaged (integrated) out (see <a href="#nte-technote-MargCond" class="quarto-xref">Note&nbsp;<span>4.3</span></a>), and it is this marginal distribution that is modeled. We digress briefly from the spatio-temporal context to illustrate the conditional versus marginal approach in a simple longitudinal-data-analysis setting. Longitudinal data are collected over time, often in a clinical trial where the response to drug treatments and controls is measured on the same subjects at different follow-up times. Here, one might allow there to be subject-specific intercepts or slopes corresponding to the treatment effect over time.</p>
<p><a href="#fig-LMMlongexamp" class="quarto-xref">Figure&nbsp;<span>4.5</span></a> shows simulated data for a longitudinal study in which 90 individuals are assigned randomly to three treatment groups (control, treatment 1, and treatment 2), 30 per group. Their responses are then plotted through time (20 time points). In each case, the response is generally linear with time, with individual-specific random intercepts and slopes. These responses can be modeled in terms of a linear mixed model, with fixed effects corresponding to the treatment (control, treatment 1, and treatment 2), individual random effects for the slope and intercept, and a random effect for the error. The random effects correspond to a situation where individuals have somewhat different baseline responses (intercept), and their response with time to the treatment is also subject to individual variation (slope).</p>
<p>For the simulated data shown in <a href="#fig-LMMlongexamp" class="quarto-xref">Figure&nbsp;<span>4.5</span></a>, we might consider a longitudinal model such as <span class="citation" data-cites="verbeke2009linear">Verbeke and Molenberghs (<a href="references.html#ref-verbeke2009linear" role="doc-biblioref">2009</a>)</span>, Section 3.3:</p>
<p><span class="math display">\[
Z_{ij} = \left\{
\begin{array}{ll}
(\beta_0 + \alpha_{0i}) + (\beta_1 + \alpha_{1i}) t_{j} + \epsilon_{ij}, &amp; \text{if the subject receives the control}, \\
(\beta_0 + \alpha_{0i}) + (\beta_2 + \alpha_{1i}) t_{j} + \epsilon_{ij}, &amp; \text{if the subject receives treatment 1}, \\
(\beta_0 + \alpha_{0i}) + (\beta_3 + \alpha_{1i}) t_{j} + \epsilon_{ij}, &amp; \text{if the subject receives treatment 2},
\end{array}
\right.
\]</span></p>
<p>where <span class="math inline">\(Z_{ij}\)</span> is the response for the <span class="math inline">\(i\)</span>th subject (<span class="math inline">\(i=1,\ldots,n=90\)</span>) at time <span class="math inline">\(j=1,\ldots,T=20\)</span>; <span class="math inline">\(\beta_0\)</span> is an overall fixed intercept; <span class="math inline">\(\beta_1, \beta_2, \beta_3\)</span> are fixed time-trend effects; and <span class="math inline">\(\alpha_{0i} \sim \text{iid} \, \text{Gau}(0,\sigma^2_1)\)</span> and <span class="math inline">\(\alpha_{1i} \sim \text{iid} \, \text{Gau}(0,\sigma^2_2)\)</span> are individual-specific random intercept and slope effects, respectively. We can write this model in the classical linear mixed-model notation as</p>
<p><span class="math display">\[
\mathbf{Z}_i = \mathbf{X}_i \boldsymbol{\beta}+ \boldsymbol{\Phi}\boldsymbol{\alpha}_i + \boldsymbol{\varepsilon}_i,
\]</span></p>
<p>where <span class="math inline">\(\mathbf{Z}_i\)</span> is a <span class="math inline">\(20\)</span>-dimensional vector of responses for the <span class="math inline">\(i\)</span>th individual; <span class="math inline">\(\mathbf{X}_i\)</span> is a <span class="math inline">\(20 \times 4\)</span> matrix consisting of a column vector of <span class="math inline">\(1\)</span>s (intercept) and three columns indicating the treatment group of the <span class="math inline">\(i\)</span>th individual; <span class="math inline">\(\boldsymbol{\beta}\)</span> is a four-dimensional vector of fixed effects; <span class="math inline">\(\boldsymbol{\Phi}\)</span> is a <span class="math inline">\(20 \times 2\)</span> matrix with a vector of <span class="math inline">\(1\)</span>s in the first column and the second column consists of the vector of times, <span class="math inline">\((1,2,\ldots,20)'\)</span>; the associated random-effect vector is <span class="math inline">\(\boldsymbol{\alpha}_i \equiv (\alpha_{0i},\alpha_{1i})'  \sim \text{Gau}(\mathbf{0},\mathbf{C}_\alpha)\)</span>, where <span class="math inline">\(\mathbf{C}_\alpha = \text{diag}(\sigma^2_1, \sigma^2_2)\)</span>; and <span class="math inline">\(\boldsymbol{\varepsilon}_i \sim \text{Gau}(\mathbf{0},\sigma^2_\epsilon \mathbf{I})\)</span> is a <span class="math inline">\(20\)</span>-dimensional error vector. We assume that the elements of <span class="math inline">\(\{\boldsymbol{\alpha}_i\}\)</span> and <span class="math inline">\(\{\boldsymbol{\varepsilon}_i\}\)</span> are all mutually independent.</p>
<p>Because the variation in the individuals’ intercepts and slopes is specified by random effects, this formulation allows one to consider inference at the subject (individual) level (e.g., predictions of an individual’s true values). However, if interest is in the fixed treatment effects <span class="math inline">\(\boldsymbol{\beta}\)</span>, one might consider the marginal distribution of the responses in which these individual random effects have been removed through averaging (integration). Responses that share common random effects exhibit marginal dependence through the marginal covariance matrix, and so the inference on the fixed effects (e.g., via generalized least squares) then accounts for this more complicated marginal dependence. For the example presented here, one can show that the marginal covariance for an individual’s response at time <span class="math inline">\(t_j\)</span> and <span class="math inline">\(t_k\)</span> is given by <span class="math inline">\(\mbox{cov}(Z_{ij},Z_{ik}) = \sigma^2_1 + t_j  t_k  \sigma^2_2 + \sigma^2_\epsilon I(j = k)\)</span>, which says that the marginal variance is time-varying, whereas the conditional covariance (conditioned on <span class="math inline">\(\boldsymbol{\alpha}\)</span>) is simply <span class="math inline">\(\sigma^2_\epsilon I(j = k)\)</span>.</p>
<p>In the context of spatial or spatio-temporal modeling, the same considerations as for the classical linear mixed-effects model apply. That is, we can also write the process of interest conditional on random effects, where the random effects might be spatial, temporal, or spatio-temporal. Why is this important? As we show in the next section, it allows us to <em>build</em> spatio-temporal dependence <em>conditionally</em>, in such a way that the implied marginal spatio-temporal covariance function is <em>always valid</em>, and it provides some computational advantages.</p>
<div id="fig-LMMlongexamp" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-LMMlongexamp-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/LMMlongexample2.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-LMMlongexamp-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.5: Simulated longitudinal data showing the response of individuals through time. The red lines are the simulated responses for a control group, the green lines are the simulated responses for treatment 1, and the blue lines are the simulated responses for treatment 2.
</figcaption>
</figure>
</div>
<div id="nte-technote-MargCond" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;4.3: Marginal and Conditional Linear Mixed Models
</div>
</div>
<div class="callout-body-container callout-body">
<p>Consider the conditional representation of a classic general linear mixed-effects model <span class="citation" data-cites="laird1982random">Laird and Ware (<a href="references.html#ref-laird1982random" role="doc-biblioref">1982</a>)</span> for response vector <span class="math inline">\(\mathbf{Z}\)</span> and fixed and random effects vectors, <span class="math inline">\(\boldsymbol{\beta}\)</span> and <span class="math inline">\(\boldsymbol{\alpha}\)</span>, respectively. Specifically, consider</p>
<p><span id="eq-Zgivenalpha"><span class="math display">\[
\mathbf{Z}| \boldsymbol{\alpha}\sim Gau(\mathbf{X}\boldsymbol{\beta}+ \boldsymbol{\Phi}\boldsymbol{\alpha}, \mathbf{C}_\epsilon),
\tag{4.21}\]</span></span></p>
<p><span class="math display">\[
\boldsymbol{\alpha}\sim Gau({\mathbf{0}}, \mathbf{C}_\alpha),
\]</span></p>
<p>where <span class="math inline">\(\mathbf{X}\)</span> and <span class="math inline">\(\boldsymbol{\Phi}\)</span> are assumed to be known matrices, and <span class="math inline">\(\mathbf{C}_\epsilon\)</span> and <span class="math inline">\(\mathbf{C}_\alpha\)</span> are known covariance matrices. The marginal distribution of <span class="math inline">\(\mathbf{Z}\)</span> is then given by integrating out the random effects:</p>
<p><span id="eq-marginalZ"><span class="math display">\[
[\mathbf{Z}] = \int [\mathbf{Z}\; | \; \boldsymbol{\alpha}][\boldsymbol{\alpha}] \textrm{d}\boldsymbol{\alpha}.
\tag{4.22}\]</span></span></p>
<p>Note that dependence on <span class="math inline">\(\boldsymbol{\theta}\)</span>, which recall are the covariance parameters in <span class="math inline">\(\mathbf{C}_z\)</span> and <span class="math inline">\(\mathbf{C}_\alpha\)</span>, has been suppressed in <a href="#eq-marginalZ" class="quarto-xref">Equation&nbsp;<span>4.22</span></a>, although the (implicit) presence of <span class="math inline">\(\boldsymbol{\theta}\)</span> can be seen in <a href="#eq-Zcondeq" class="quarto-xref">Equation&nbsp;<span>4.23</span></a>–<a href="#eq-Zmarg" class="quarto-xref">Equation&nbsp;<span>4.26</span></a> below. We can obtain this distribution by making use of iterated conditional expectation and variance formulas. In particular, note that we can write the model associated with <a href="#eq-Zgivenalpha" class="quarto-xref">Equation&nbsp;<span>4.21</span></a> as</p>
<p><span id="eq-Zcondeq"><span class="math display">\[
\mathbf{Z}= \mathbf{X}\boldsymbol{\beta}+ \boldsymbol{\Phi}\boldsymbol{\alpha}+ \boldsymbol{\varepsilon}, \quad\boldsymbol{\varepsilon}\sim Gau({\mathbf{0}}, \mathbf{C}_\epsilon),
\tag{4.23}\]</span></span></p>
<p>and then</p>
<p><span id="eq-EZ"><span class="math display">\[
E(\mathbf{Z}) = E_{\alpha}\{E(\mathbf{Z}| \boldsymbol{\alpha})\} = E_{\alpha}\{\mathbf{X}\boldsymbol{\beta}+ \boldsymbol{\Phi}\boldsymbol{\alpha}\} = \mathbf{X}\boldsymbol{\beta},
\tag{4.24}\]</span></span></p>
<p><span id="eq-varY"><span class="math display">\[
\textrm{var}(\mathbf{Z}) = \textrm{var}_{\alpha}\{E(\mathbf{Z}| \boldsymbol{\alpha})\} + E_{\alpha}\{\textrm{var}(\mathbf{Z}| \boldsymbol{\alpha})\}  =  \boldsymbol{\Phi}\mathbf{C}_\alpha \boldsymbol{\Phi}' + \mathbf{C}_\epsilon.
\tag{4.25}\]</span></span></p>
<p>Then, since <a href="#eq-Zcondeq" class="quarto-xref">Equation&nbsp;<span>4.23</span></a> shows that <span class="math inline">\(\mathbf{Z}\)</span> is a linear combination of normally distributed random variables, it is also normally distributed and the marginal distribution is given by</p>
<p><span id="eq-Zmarg"><span class="math display">\[
\mathbf{Z}\; \sim \; Gau(\mathbf{X}\boldsymbol{\beta},  \boldsymbol{\Phi}\mathbf{C}_\alpha \boldsymbol{\Phi}' + \mathbf{C}_\epsilon).
\tag{4.26}\]</span></span></p>
<p>Thus, we can see that the integration over the common random effects <span class="math inline">\(\boldsymbol{\alpha}\)</span> in <a href="#eq-marginalZ" class="quarto-xref">Equation&nbsp;<span>4.22</span></a> induces a more complicated error covariance structure in the marginal distribution (i.e., compare the marginal covariance matrix, <span class="math inline">\(\boldsymbol{\Phi}\mathbf{C}_\alpha \boldsymbol{\Phi}' + \mathbf{C}_\epsilon\)</span>, to the conditional covariance matrix, <span class="math inline">\(\mathbf{C}_\epsilon\)</span>). This idea of conditioning on random effects and inducing dependence through integration is fundamentally important to hierarchical statistical modeling. That is, it is typically easier to model means than it is to model covariances, and so we put our modeling effort into the conditional mean and then let the integration induce the more complicated marginal dependence rather than specifying it directly.</p>
</div>
</div>
</section>
<section id="sec-basisfunctions" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="sec-basisfunctions"><span class="header-section-number">4.4</span> Basis-Function Representations</h2>
<p>By themselves, the conditional specifications discussed in <a href="#sec-randomeffects" class="quarto-xref"><span>Section 4.3</span></a> are often not enough to help us deal with the problem of specifying realistic spatio-temporal covariance structures and deal with the “curse of dimensionality,” which is endemic in spatio-temporal statistics. We also need to pay particular attention to our choice of <span class="math inline">\(\boldsymbol{\Phi}\)</span>, and we often do this through basis-function expansions (recall that we introduced basis functions in Chapter 1 and in more detail in Chapter 3).</p>
<p>Basis functions, like covariates, can be nonlinear functions of <span class="math inline">\((\mathbf{s};t)\)</span>; however, the expansion is a linear function of the basis functions’ coefficients. We assume that these coefficients are the objects of inference in a statistical additive model. If the coefficients are fixed but unknown and to be estimated, then we have a regression model and the basis functions act as covariates (see, for example, <a href="Chapter3.html#sec-reg_pred" class="quarto-xref"><span>Section 3.2</span></a>). If the coefficients are random, then we have a random-effects model (or, if covariates are also present, a mixed-effects model) and we can perform inference on the moments of those random effects. More importantly, as we have shown in <a href="#sec-randomeffects" class="quarto-xref"><span>Section 4.3</span></a>, this framework allows us to build complexity through marginalization. This often simplifies the model specification, particularly if we consider the random effects to be associated with spatial, temporal, or spatio-temporal . In the following subsections, we consider spatio-temporal models that involve these three types of basis functions.</p>
<section id="sec-Randeffects_STbasis" class="level3" data-number="4.4.1">
<h3 data-number="4.4.1" class="anchored" data-anchor-id="sec-Randeffects_STbasis"><span class="header-section-number">4.4.1</span> Random Effects with Spatio-Temporal Basis Functions</h3>
<p>Assuming the same data model (<a href="#eq-Zdata_vec" class="quarto-xref">Equation&nbsp;<span>4.3</span></a>) as above, we rewrite the process model (<a href="#eq-Yprocess_st" class="quarto-xref">Equation&nbsp;<span>4.2</span></a>) in terms of fixed and random effects, <span class="math inline">\(\boldsymbol{\beta}\)</span> and <span class="math inline">\(\{\alpha_i: i=1,\ldots,n_\alpha\}\)</span>, respectively:</p>
<p><span id="eq-Yprocess_stbasis"><span class="math display">\[
Y(\mathbf{s};t) =  \mathbf{x}(\mathbf{s};t)'\boldsymbol{\beta}+ \eta(\mathbf{s};t)
\; = \;  \mathbf{x}(\mathbf{s};t)'\boldsymbol{\beta}+ \sum_{i=1}^{n_\alpha} \phi_{i}(\mathbf{s};t) \alpha_i + \nu(\mathbf{s};t),
\tag{4.27}\]</span></span></p>
<p>where <span class="math inline">\(\{\phi_{i}(\mathbf{s};t): i=1,\ldots,n_\alpha \}\)</span> are specified <em>spatio-temporal</em> corresponding to location <span class="math inline">\((\mathbf{s};t)\)</span>, <span class="math inline">\(\{\alpha_i\}\)</span> are <em>random effects</em>, and <span class="math inline">\(\nu(\mathbf{s};t)\)</span> is sometimes needed to represent small-scale spatio-temporal random effects not captured by the basis functions. So, in <a href="#eq-Yprocess_stbasis" class="quarto-xref">Equation&nbsp;<span>4.27</span></a> we are just decomposing the spatio-temporal random process, <span class="math inline">\(\eta(\mathbf{s};t)\)</span>, into a linear combination of random effects and a “residual” error term.</p>
<p>Let <span class="math inline">\(\boldsymbol{\alpha}\sim Gau({\mathbf{0}},\mathbf{C}_\alpha)\)</span>, where <span class="math inline">\(\boldsymbol{\alpha}\equiv (\alpha_1,\ldots,\alpha_{n_\alpha})'\)</span>. Suppose we are interested in making inference on the process <span class="math inline">\(Y\)</span> at <span class="math inline">\(n_y\)</span> spatio-temporal locations, which we denote by the <span class="math inline">\(n_y\)</span>-dimensional vector <span class="math inline">\(\mathbf{Y}\)</span>. The process model then becomes</p>
<p><span id="eq-Yprocess_basis_vec"><span class="math display">\[
\mathbf{Y}= \mathbf{X}\boldsymbol{\beta}+ \boldsymbol{\Phi}\boldsymbol{\alpha}+ \boldsymbol{\nu},
\tag{4.28}\]</span></span></p>
<p>where the <span class="math inline">\(i\)</span>th column of the <span class="math inline">\(n_y \times n_\alpha\)</span> matrix <span class="math inline">\(\boldsymbol{\Phi}\)</span> corresponds to the <span class="math inline">\(i\)</span>th basis function, <span class="math inline">\(\phi_{i}(\cdot;\cdot)\)</span>, at all of the <span class="math inline">\(n_y\)</span> spatio-temporal locations, and in the same order as that used to construct <span class="math inline">\(\mathbf{Y}\)</span>. The vector <span class="math inline">\(\boldsymbol{\nu}\)</span> also corresponds to the spatio-temporal ordering given in <span class="math inline">\(\mathbf{Y}\)</span>, and <span class="math inline">\(\boldsymbol{\nu}\sim Gau({\mathbf{0}},\mathbf{C}_\nu)\)</span>. In this case, one can see (<a href="#nte-technote-MargCond" class="quarto-xref">Note&nbsp;<span>4.3</span></a>) that the marginal distribution of <span class="math inline">\(\mathbf{Y}\)</span> is given by <span class="math inline">\(\mathbf{Y}\sim  Gau(\mathbf{X}\boldsymbol{\beta}, \boldsymbol{\Phi}\mathbf{C}_\alpha \boldsymbol{\Phi}' + \mathbf{C}_\nu )\)</span>, so that <span class="math inline">\(\mathbf{C}_y = \boldsymbol{\Phi}\mathbf{C}_\alpha \boldsymbol{\Phi}' + \mathbf{C}_\nu\)</span>. Now the vector of covariance parameters <span class="math inline">\(\boldsymbol{\theta}\)</span> is augmented to include parameters in <span class="math inline">\(\mathbf{C}_\nu\)</span>. The spatio-temporal dependence is accounted for by the spatio-temporal basis functions, <span class="math inline">\(\boldsymbol{\Phi}\)</span>, and in general this could accommodate non-separable dependence. A benefit of this approach is that the spatio-temporal modeling effort focuses on the fixed number <span class="math inline">\(n_\alpha\)</span> of random effects. In this case, note that the random effects <span class="math inline">\(\boldsymbol{\alpha}\)</span> are not indexed by space and time, so it should be easier to specify a model for them. For example, we can specify a <em>covariance matrix</em> to describe their dependence, which is easier than specifying a <em>covariance function</em>.</p>
<p>In situations where <span class="math inline">\(n_\alpha \ll n_y\)</span> (i.e., a <em>low-rank representation</em>), an additional benefit comes from being able to perform matrix inverses in terms of <span class="math inline">\(n_\alpha\)</span>-dimensional matrices (through well-known matrix-algebra relationships). Specifically, under model <a href="#eq-Yprocess_basis_vec" class="quarto-xref">Equation&nbsp;<span>4.28</span></a> we note that we can write <span class="math inline">\(\mathbf{C}_z = \boldsymbol{\Phi}\mathbf{C}_\alpha \boldsymbol{\Phi}' + \mathbf{V}\)</span>, where we define <span class="math inline">\(\mathbf{V}\equiv \mathbf{C}_\nu + \mathbf{C}_\epsilon\)</span>. Then, using the well-known Sherman–Morrison–Woodbury matrix identities [e.g., available at https://doi.org/10.1007/978-1-4757-2085-3] , we can write</p>
<p><span class="math display">\[
\mathbf{C}_z^{-1} = \mathbf{V}^{-1} - \mathbf{V}^{-1} \boldsymbol{\Phi}(\boldsymbol{\Phi}' \mathbf{V}^{-1} \boldsymbol{\Phi}+ \mathbf{C}_\alpha^{-1})^{-1} \boldsymbol{\Phi}' \mathbf{V}^{-1}.
\]</span></p>
<p>Importantly, if <span class="math inline">\(\mathbf{V}^{-1}\)</span> has simple structure (e.g., is sparse or diagonal) and <span class="math inline">\(n_\alpha \ll n_y\)</span>, then this inverse is easy to calculate because it is a function of a simple high-dimensional matrix <span class="math inline">\(\mathbf{V}^{-1}\)</span> and a low-dimensional matrix inverse <span class="math inline">\(\mathbf{C}_\alpha^{-1}\)</span>.</p>
<p>It is important to note that even in the <em>full-rank</em> (<span class="math inline">\(n_\alpha = n_y\)</span>) and <em>over-complete</em> (<span class="math inline">\(n_\alpha &gt; n_y\)</span>) cases there can still be computational benefits through induced sparsity in <span class="math inline">\(\mathbf{C}_\alpha\)</span> and the use of efficient matrix-multiplication routines that use multiresolution algorithms, orthogonality, and/or sparse precision matrices. In addition, basis-function implementations may assume that <span class="math inline">\(\boldsymbol{\nu}= {\mathbf{0}}\)</span> and often that <span class="math inline">\(\boldsymbol{\Phi}\)</span> is orthogonal, so that <span class="math inline">\(\boldsymbol{\Phi}\boldsymbol{\Phi}' = \mathbf{I}\)</span>; in those cases, one can reduce the computational burden significantly. Finally, we note that specific and methodologies are devised to take advantage of other properties of various matrices (e.g., sparse structure on the random-effects covariance matrix, <span class="math inline">\(\mathbf{C}_\alpha\)</span>, or on the random-effects precision matrix, <span class="math inline">\(\mathbf{C}_\alpha^{-1}\)</span>).</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
</div>
<div class="callout-body-container callout-body">
<p>Sparse matrices can be used in <code>R</code> using definitions in the packages <strong>Matrix</strong> or <strong>spam</strong>. For both these packages, arithmetic operations, decompositions (e.g., the Cholesky decomposition), back-solves and forward-solves, and other important matrix operations, can be done seamlessly using standard <code>R</code> commands. With <strong>Matrix</strong>, a sparse matrix can be constructed using the function <code>sparseMatrix</code>, while a sparse diagonal matrix can be constructed using the function <code>Diagonal</code>. With the former, the argument <code>symmetric = TRUE</code> can be used to specify a sparse symmetric matrix.</p>
</div>
</div>
<p>The definition of “basis function” in our spatio-temporal context is pretty liberal; the matrix <span class="math inline">\(\boldsymbol{\Phi}\)</span> in the product <span class="math inline">\(\boldsymbol{\Phi}\boldsymbol{\alpha}\)</span> is a spatio-temporal basis-function matrix so long as its coefficients <span class="math inline">\(\boldsymbol{\alpha}\)</span> are random and the columns of <span class="math inline">\(\boldsymbol{\Phi}\)</span> are spatio-temporally referenced. One decision associated with fitting model <a href="#eq-Yprocess_stbasis" class="quarto-xref">Equation&nbsp;<span>4.27</span></a> concerns the choice of . For spatial processes, the decisions one makes with regard to the choice of are usually not that critical, as there are multiple types of bases that can accommodate the same spatial variability. However, as one starts considering spatio-temporal processes, the choice of can make a difference, especially for the dynamical formulations presented in Chapter 5.</p>
<p>In general, one can use (i) fixed or parameterized basis functions, (ii) local or global , (iii) reduced-rank, complete, or over-complete bases, and (iv) basis functions with expansion coefficients possibly indexed by space, time, or space-time. Further, the choice is affected by the presence and type of residual structure and the distribution of the random effects. Historically, it has been fairly challenging to come up with good spatio-temporal basis functions (for the same reason it has been difficult to come up with truly realistic spatio-temporal covariance functions). One simplification is to consider tensor-product (mentioned in <a href="Chapter3.html#sec-reg_pred" class="quarto-xref"><span>Section 3.2</span></a> and <a href="#nte-technote-Kronecker" class="quarto-xref">Note&nbsp;<span>4.1</span></a>), where we define the spatio-temporal basis function as the product of a spatial basis function and a temporal basis function. Note that this does <em>not</em> yield a separable spatio-temporal model, in general. It is also quite common to see spatio-temporal-dependence models for <span class="math inline">\(Y\)</span>, where the statistical dependence comes from spatial-only whose coefficients are temporal stochastic processes (<a href="#sec-randeffspat" class="quarto-xref"><span>Section 4.4.2</span></a>).</p>
<section id="example-fixed-rank-kriging" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="example-fixed-rank-kriging">Example: Fixed Rank Kriging</h4>
<p>A widely adopted method for rank reduction is <em>fixed rank kriging</em> (FRK), implemented in <code>R</code> through the package <strong>FRK</strong>. Lab 4.2 demonstrates how FRK can be applied to the maximum temperature (<code>Tmax</code>) in the NOAA data set using <span class="math inline">\(n_\alpha = 1880\)</span> space-time tensor-product basis functions (see <a href="#nte-technote-Kronecker" class="quarto-xref">Note&nbsp;<span>4.1</span></a>) at two resolutions for <span class="math inline">\(\{\phi_i(\mathbf{s};t):i=1,\dots,n_\alpha\}\)</span>. In particular, <em>bisquare</em> basis functions are used (see Lab 4.2 for details). FRK also considers a fine-scale-variation component <span class="math inline">\(\boldsymbol{\nu}\)</span> such that <span class="math inline">\(\mathbf{C}_\nu\)</span> is diagonal. The matrix <span class="math inline">\(\mathbf{C}_\alpha\)</span> is constructed such that the coefficients <span class="math inline">\(\boldsymbol{\alpha}\)</span> at each resolution are independent, and such that the covariances between these coefficients within a resolution decay exponentially with the distance between the centers of the basis functions. Parameters are estimated using an EM algorithm for computing maximum likelihood estimates (see <a href="#nte-algorithm-EMbasic" class="quarto-xref">Note&nbsp;<span>4.4</span></a>).</p>
<p><a href="#fig-pred_FRK" class="quarto-xref">Figure&nbsp;<span>4.6</span></a> shows the predictions and prediction standard errors obtained using FRK; as is typical for kriging, the computations are made with <span class="math inline">\(\widehat{\boldsymbol{\theta}}\)</span> substituted in for the unknown covariance parameters <span class="math inline">\(\boldsymbol{\theta}\)</span>. Although the uncertainty in <span class="math inline">\(\widehat{\boldsymbol{\theta}}\)</span> is not accounted for in this setting, it is typically thought to be a fairly minor component of the variation in the spatio-temporal prediction. The predictions are similar to those obtained using S-T kriging in <a href="#fig-maxT-predictions" class="quarto-xref">Figure&nbsp;<span>4.2</span></a> of <a href="#sec-GaussDataProc" class="quarto-xref"><span>Section 4.2</span></a>, but they are also a bit “noisier” because of the assumed uncorrelated fine-scale variation term; see <a href="#eq-Yprocess_stbasis" class="quarto-xref">Equation&nbsp;<span>4.27</span></a>. The prediction standard errors show similar patterns to those obtained earlier (<a href="#fig-maxT-predictions" class="quarto-xref">Figure&nbsp;<span>4.2</span></a>), although there are notable differences upon visual examination. This is commonly observed when using reduced-rank methods, and it is particularly evident with very-low-rank implementations (e.g., with EOFs) accompanied with spatially uncorrelated fine-scale variation. In such cases, the prediction-standard-error maps can have prediction standard errors related more to the shapes of the basis functions and less to the prediction location’s proximity to an observation.</p>
<div id="fig-pred_FRK" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-pred_FRK-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/FRK_pred.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pred_FRK-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.6: Left: Predictions of <code>Tmax</code> and right: prediction standard errors in degrees Fahrenheit within a square box enclosing the domain of interest for six days (each 5 days apart) spanning the temporal window of the data, 01 July 1993–20 July 2003, using bisquare spatio-temporal and the <strong>R</strong> package <strong>FRK</strong>. Data for 14 July 1993 were omitted from the original data set.
</figcaption>
</figure>
</div>
<div id="nte-algorithm-EMbasic" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;4.4: Basic EM Algorithm
</div>
</div>
<div class="callout-body-container callout-body">
<p>In some cases, it can be computationally more efficient to perform maximum likelihood estimation using the expectation-maximization (EM) algorithm rather than through direct optimization of the likelihood function. The basic idea is that one defines <em>complete data</em> to be a combination of actual observations and missing observations. Let <span class="math inline">\(W\)</span> denote these complete data made up of observations (<span class="math inline">\(W_{\mathrm{obs}}\)</span>) and “missing” observations (<span class="math inline">\(W_{\mathrm{mis}}\)</span>), and <span class="math inline">\(\theta\)</span> represents the unknown parameters in the model, so that the complete-data log-likelihood is given by <span class="math inline">\(\log(L(\theta | W))\)</span>. The basic EM algorithm is given below.</p>
<p>Choose starting values for the parameter, <span class="math inline">\(\hat{\theta}^{(0)}\)</span></p>
<p><strong>repeat</strong> <span class="math inline">\(i=1,2,\ldots\)</span></p>
<ol type="1">
<li>E-Step: Obtain <span class="math inline">\(Q(\theta | \hat{\theta}^{(i-1)}) = E\{\log(L(\theta \mid W)) \mid W_{\mathrm{obs}}, \hat{\theta}^{(i-1)}\}\)</span></li>
<li>M-Step: Obtain <span class="math inline">\(\hat{\theta}^{(i)} = \max_{\theta} \{Q(\theta \mid \hat{\theta}^{(i-1)})\}\)</span></li>
</ol>
<p><strong>until</strong> convergence either in <span class="math inline">\(\hat{\theta}^{(i)}\)</span> or in <span class="math inline">\(\log(L(\theta \mid W))\)</span></p>
<p>In <a href="#sec-basisfunctions" class="quarto-xref"><span>Section 4.4</span></a>, <span class="math inline">\(W_{\mathrm{obs}}\)</span> corresponds to the data <span class="math inline">\(\mathbf{Z}\)</span>, while <span class="math inline">\(W_{\mathrm{mis}}\)</span> corresponds to the coefficients <span class="math inline">\(\boldsymbol{\alpha}\)</span>.</p>
</div>
</div>
</section>
</section>
<section id="sec-randeffspat" class="level3" data-number="4.4.2">
<h3 data-number="4.4.2" class="anchored" data-anchor-id="sec-randeffspat"><span class="header-section-number">4.4.2</span> Random Effects with Spatial Basis Functions</h3>
<p>Consider the case where the of the spatio-temporal process are functions of space only and their random coefficients are indexed by time:</p>
<p><span id="eq-Yprocess_spbasis"><span class="math display">\[
Y(\mathbf{s};t_j) = \mathbf{x}(\mathbf{s};t_j)'\boldsymbol{\beta}+ \sum_{i=1}^{n_\alpha} \phi_i(\mathbf{s}) \alpha_{i}(t_j) + \nu(\mathbf{s};t_j),\quad j=1,\ldots,T,
\tag{4.29}\]</span></span></p>
<p>where <span class="math inline">\(\{\phi_i(\mathbf{s}): i=1,\ldots,n_\alpha;\ \mathbf{s}\in D_s\}\)</span> are known spatial , <span class="math inline">\(\alpha_{i}(t_j)\)</span> are temporal random processes, and the other model components are defined as above. We can consider a wide variety of spatial for this model, and again these might be of reduced rank, of full rank, or over-complete. For example, we might consider complete global (e.g., Fourier), or reduced-rank empirically defined (e.g., EOFs), or a variety of non-orthogonal bases (e.g., Gaussian functions, wavelets, bisquare functions, or Wendland functions). We illustrate a few of these in one dimension in <a href="#fig-spat_basis_fn" class="quarto-xref">Figure&nbsp;<span>4.7</span></a> (see also <a href="Chapter3.html#sec-reg_pred" class="quarto-xref"><span>Section 3.2</span></a>). It is often not important which basis function is used; still, one has to be careful to ensure that the type and number of are flexible and large enough to model the true dependence in <span class="math inline">\(Y\)</span> (and the data <span class="math inline">\(\mathbf{Z}\)</span>). This requires some experimentation and model diagnostics (see, for example, Chapter 6).</p>
<div id="fig-spat_basis_fn" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-spat_basis_fn-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/spat_basis_fn.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spat_basis_fn-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.7: Some spatial that can be employed in spatio-temporal modeling, depicted in one-dimensional space. From left to right: bisquare, cosine, Gaussian, linear element, Mexican-hat wavelet, and first-order Wendland functions.
</figcaption>
</figure>
</div>
<p>Assuming interest in the spatio-temporal dependence at <span class="math inline">\(n\)</span> spatial locations <span class="math inline">\(\{\mathbf{s}_1,\ldots,\mathbf{s}_n\}\)</span> and at times <span class="math inline">\(\{t_j: j=1,2,\ldots,T\}\)</span>, we can write model <a href="#eq-Yprocess_spbasis" class="quarto-xref">Equation&nbsp;<span>4.29</span></a> in vector form as</p>
<p><span id="eq-Yprocess_spbasis_vec"><span class="math display">\[
\mathbf{Y}_{t_j} = \mathbf{X}_{t_j} \boldsymbol{\beta}+ \boldsymbol{\Phi}\boldsymbol{\alpha}_{t_j} + \boldsymbol{\nu}_{t_j},
\tag{4.30}\]</span></span></p>
<p>where <span class="math inline">\(\mathbf{Y}_{t_j}= (Y(\mathbf{s}_1;t_j),\ldots,Y(\mathbf{s}_n;t_j))'\)</span> is the <span class="math inline">\(n\)</span>-dimensional process vector, <span class="math inline">\(\boldsymbol{\nu}_{t_j} \; \sim \; Gau({\mathbf{0}},\mathbf{C}_\nu)\)</span>, <span class="math inline">\(\boldsymbol{\alpha}_{t_j} \equiv (\alpha_{1}(t_j),\ldots,\alpha_{n_\alpha}(t_j))'\)</span>, <span class="math inline">\(\boldsymbol{\Phi}\equiv (\boldsymbol{\phi}(\mathbf{s}_1),\ldots,\boldsymbol{\phi}(\mathbf{s}_n))'\)</span>, and <span class="math inline">\(\boldsymbol{\phi}(\mathbf{s}_i) \equiv (\phi_1(\mathbf{s}_i),\ldots,\phi_{n_\alpha}(\mathbf{s}_i))'\)</span>, <span class="math inline">\(i=1,\ldots,n\)</span>. An important question is then what the preferred distribution for <span class="math inline">\(\boldsymbol{\alpha}_{t_j}\)</span> is.</p>
<p>It can be shown that if <span class="math inline">\(\boldsymbol{\alpha}_{t_1}, \boldsymbol{\alpha}_{t_2},\ldots\)</span> are independent in time, where <span class="math inline">\(\boldsymbol{\alpha}_{t_j} \sim iid \; Gau({\mathbf{0}},\mathbf{C}_\alpha)\)</span>, then the marginal distribution of <span class="math inline">\(\mathbf{Y}_{t_j}\)</span> is <span class="math inline">\(Gau(\mathbf{X}_{t_j} \boldsymbol{\beta}, \boldsymbol{\Phi}\mathbf{C}_\alpha \boldsymbol{\Phi}' + \mathbf{C}_\nu)\)</span>, and <span class="math inline">\(\mathbf{Y}_{t_1}, \mathbf{Y}_{t_2},\ldots\)</span> are independent. Hence, the <span class="math inline">\(nT \times nT\)</span> joint spatio-temporal covariance matrix is given by the , <span class="math inline">\(\mathbf{C}_Y = \mathbf{I}_T \otimes (\boldsymbol{\Phi}\mathbf{C}_\alpha \boldsymbol{\Phi}' + \mathbf{C}_\nu)\)</span>, where <span class="math inline">\(\mathbf{I}_T\)</span> is the <span class="math inline">\(T\)</span>-dimensional identity matrix (see <a href="#nte-technote-Kronecker" class="quarto-xref">Note&nbsp;<span>4.1</span></a>). So the independence-in-time assumption implies a simple separable spatio-temporal dependence structure. To model a more complex spatio-temporal dependence structure using spatial-only , one must specify the model for the random coefficients such that <span class="math inline">\(\{\boldsymbol{\alpha}_{t_j}: j=1,\ldots,T\}\)</span> are <em>dependent in time</em>. This is simplified by assuming <em>conditional</em> temporal dependence (dynamics) as discussed in Chapter 5.</p>
</section>
<section id="random-effects-with-temporal-basis-functions" class="level3" data-number="4.4.3">
<h3 data-number="4.4.3" class="anchored" data-anchor-id="random-effects-with-temporal-basis-functions"><span class="header-section-number">4.4.3</span> Random Effects with Temporal Basis Functions</h3>
<p>We can also express the spatio-temporal random process in terms of temporal and spatially indexed random effects:</p>
<p><span id="eq-Yprocess_tbasis"><span class="math display">\[
Y(\mathbf{s};t) = \mathbf{x}(\mathbf{s};t)' \boldsymbol{\beta}+ \sum_{i=1}^{n_\alpha} \phi_{i}(t) \alpha_i(\mathbf{s}) + \nu(\mathbf{s};t),
\tag{4.31}\]</span></span></p>
<p>where <span class="math inline">\(\{\phi_{i}(t): i=1,\ldots,n_\alpha;\ t \in D_t\}\)</span> are temporal and <span class="math inline">\(\{\alpha_i(\mathbf{s})\}\)</span> are their spatially indexed random coefficients. In this case, one could model <span class="math inline">\(\{\alpha_i(\mathbf{s}): \mathbf{s}\in D_s;\ i=1,\ldots,n_\alpha\}\)</span> using multivariate geostatistics. The temporal-basis-function representation given in <a href="#eq-Yprocess_tbasis" class="quarto-xref">Equation&nbsp;<span>4.31</span></a> is not as common in spatio-temporal statistics as the spatial-basis-function representation given in <a href="#eq-Yprocess_spbasis" class="quarto-xref">Equation&nbsp;<span>4.29</span></a>. This is probably because most spatio-temporal processes have a scientific interpretation of spatial processes evolving in time. However, this need not be the case, and temporal are increasingly being used to model non-stationary-in-time processes (e.g., complex seasonal or high-frequency time behavior) that vary across space.</p>
<section id="example-using-temporal-basis-functions" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="example-using-temporal-basis-functions">Example Using Temporal Basis Functions</h4>
<p>Spatio-temporal modeling and prediction using temporal can be carried out with the package <strong>SpatioTemporal</strong> (see Lab 4.3). In the top panel of <a href="#fig-temp_basis_fn" class="quarto-xref">Figure&nbsp;<span>4.8</span></a> we show the three temporal used to model maximum temperature in the NOAA data set. These were obtained following a procedure similar to EOF analysis, which is described in <a href="Chapter2.html#nte-technote-EOFs" class="quarto-xref">Note&nbsp;<span>2.2</span></a>. Note that the basis function <span class="math inline">\(\phi_1(t) = 1\)</span> is time-invariant.</p>
<p>Once <span class="math inline">\(\phi_1(t), \phi_2(t)\)</span>, and <span class="math inline">\(\phi_3(t)\)</span> are selected, estimates (e.g., ordinary least squares) of <span class="math inline">\(\alpha_1(\mathbf{s}), \alpha_2(\mathbf{s})\)</span>, and <span class="math inline">\(\alpha_3(\mathbf{s})\)</span> can be found and used to indicate how they might be modeled. For example, in Lab 4.3 we see that while both <span class="math inline">\(\alpha_1(\mathbf{s})\)</span> and <span class="math inline">\(\alpha_2(\mathbf{s})\)</span> have a latitudinal trend, <span class="math inline">\(\alpha_3(\mathbf{s})\)</span> does not. Assigning these fields exponential covariance functions, we obtain the models:</p>
<p><span id="eq-alpha1"><span class="math display">\[
E(\alpha_1(\mathbf{s})) = \alpha_{11} + \alpha_{12}s_2, \quad \textrm{cov}(\alpha_1(\mathbf{s}), \alpha_1(\mathbf{s}+ \mathbf{h})) = \sigma^2_1 \exp(-\|\mathbf{h}\|/r_1),
\tag{4.32}\]</span></span></p>
<p><span id="eq-alpha2"><span class="math display">\[
E(\alpha_2(\mathbf{s})) = \alpha_{21} + \alpha_{22}s_2, \quad \textrm{cov}(\alpha_2(\mathbf{s}), \alpha_2(\mathbf{s}+ \mathbf{h})) = \sigma^2_2 \exp(-\|\mathbf{h}\|/r_2),
\tag{4.33}\]</span></span></p>
<p><span id="eq-alpha3"><span class="math display">\[
E(\alpha_3(\mathbf{s})) = \alpha_{31}, \quad\qquad~~~~~~~ \textrm{cov}(\alpha_3(\mathbf{s}), \alpha_3(\mathbf{s}+ \mathbf{h})) = \sigma^2_3 \exp(-\|\mathbf{h}\|/r_3),
\tag{4.34}\]</span></span></p>
<p>where <span class="math inline">\(s_2\)</span> denotes the latitude coordinate at <span class="math inline">\(\mathbf{s}= (s_1, s_2)'\)</span>, <span class="math inline">\(r_1, r_2\)</span>, and <span class="math inline">\(r_3\)</span> are scale parameters, and <span class="math inline">\(\sigma^2_1, \sigma^2_2\)</span>, and <span class="math inline">\(\sigma^2_3\)</span> are stationary variances. We further assume that <span class="math inline">\(\textrm{cov}(\alpha_k(\mathbf{s}),\alpha_{\ell}(\mathbf{s}')) = 0\)</span> for <span class="math inline">\(k \neq \ell\)</span>, which is a strong assumption.</p>
<p>Using maximum likelihood to estimate all unknown parameters and “plugging” the estimates in, the resulting prediction is the spatio-temporal smoothed map, <span class="math inline">\(E(Y(\cdot;\cdot)\mid \mathbf{Z})\)</span>, obtained from maps of <span class="math inline">\(E(\alpha_1(\cdot)\mid \mathbf{Z}), E(\alpha_2(\cdot)\mid \mathbf{Z})\)</span>, and <span class="math inline">\(E(\alpha_3(\cdot)\mid  \mathbf{Z})\)</span>, which can all be written in closed form. We show the first three basis-function times series in the top panel of <a href="#fig-temp_basis_fn" class="quarto-xref">Figure&nbsp;<span>4.8</span></a> and the predicted spatial maps (i.e., the basis-function coefficients), corresponding to these three basis functions in the bottom panel. Note how <span class="math inline">\(E(\alpha_1(\cdot) \mid  \mathbf{Z})\)</span> picks up the latitude component evident in the NOAA maximum-temperature data. On the other hand, the fields <span class="math inline">\(E(\alpha_2(\cdot) \mid  \mathbf{Z})\)</span> and <span class="math inline">\(E(\alpha_3(\cdot)\mid  \mathbf{Z})\)</span> appear to capture oblique and longitudinal trends that have not been considered up to now, but with much smaller magnitudes. Although not shown here, these predictions of the basis-function coefficients <span class="math inline">\(\alpha_1(\cdot)\)</span>, <span class="math inline">\(\alpha_2(\cdot)\)</span>, and <span class="math inline">\(\alpha_3(\cdot)\)</span> have associated uncertainties and those can be plotted as prediction standard-error maps as well.</p>
<p><img src="img/Chapter_4/temp_basis_fns.png" class="img-fluid"></p>
<div id="fig-temp_basis_fn" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-temp_basis_fn-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/alpha_fields_all.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-temp_basis_fn-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.8: Top: Basis functions <span class="math inline">\(\phi_1(t), \phi_2(t)\)</span>, and <span class="math inline">\(\phi_3(t)\)</span>, where the latter two were obtained from the left-singular vectors following a singular value decomposition of the data matrix. Bottom: <span class="math inline">\(E(\alpha_1(\mathbf{s}) \mid \mathbf{Z})\)</span>, <span class="math inline">\(E(\alpha_2(\mathbf{s}) \mid \mathbf{Z})\)</span>, and <span class="math inline">\(E(\alpha_3(\mathbf{s}) \mid \mathbf{Z})\)</span>.
</figcaption>
</figure>
</div>
</section>
</section>
<section id="confounding-of-fixed-effects-and-random-effects" class="level3" data-number="4.4.4">
<h3 data-number="4.4.4" class="anchored" data-anchor-id="confounding-of-fixed-effects-and-random-effects"><span class="header-section-number">4.4.4</span> Confounding of Fixed Effects and Random Effects</h3>
<p>Consider the general mixed-effects representation given in <a href="#eq-Yprocess_basis_vec" class="quarto-xref">Equation&nbsp;<span>4.28</span></a>:</p>
<p><span class="math display">\[
\mathbf{Y}= \mathbf{X}\boldsymbol{\beta}+ \boldsymbol{\Phi}\boldsymbol{\alpha}+ \boldsymbol{\nu},\quad \boldsymbol{\nu}\; \sim \; Gau({\mathbf{0}}, \mathbf{C}_\nu),
\]</span></p>
<p>and recall that <span class="math inline">\(\mathbf{Z}= \mathbf{Y}+ \boldsymbol{\varepsilon}\)</span>. Although the columns of <span class="math inline">\(\boldsymbol{\Phi}\)</span> are , they are indexed in space and time in the same way that the columns of <span class="math inline">\(\mathbf{X}\)</span> are. Then, depending on the structure of the columns in these two matrices, it is quite possible that the random effects can be confounded with the fixed effects, similarly to the way extreme can affect the estimation of fixed effects in traditional regression (recall <a href="Chapter3.html#sec-STcovinf" class="quarto-xref"><span>Section 3.2.2</span></a>). This suggests that if primary interest is in inference on the fixed-effect parameters (<span class="math inline">\(\boldsymbol{\beta}\)</span>), then one should mitigate potential associated with the random effects. As with , if the columns of <span class="math inline">\(\boldsymbol{\Phi}\)</span> and <span class="math inline">\(\mathbf{X}\)</span> are linearly independent, then there is no concern about . This has led to mitigation strategies that tend to restrict the random effects by selecting in <span class="math inline">\(\boldsymbol{\Phi}\)</span> that are orthogonal to the column space of <span class="math inline">\(\mathbf{X}\)</span> (or approximately so). If prediction of the hidden process <span class="math inline">\(\mathbf{Y}\)</span> is the primary goal, one is typically much less concerned about potential confounding.</p>
</section>
</section>
<section id="sec-nonGaussian" class="level2" data-number="4.5">
<h2 data-number="4.5" class="anchored" data-anchor-id="sec-nonGaussian"><span class="header-section-number">4.5</span> Non-Gaussian Data Models with Latent Gaussian Processes</h2>
<p>There is only one way to be Gaussian, but an infinite number of ways to be non-Gaussian! This is a challenge that we address in this section through the use of hierarchical statistical models. The modeling paradigm that we follow is to find a Gaussian process, possibly deep in the hierarchy, that describes the spatio-temporal behavior of a hidden process or of parameters that vary with space and time. The marginal distribution of the data is then non-Gaussian, but somewhere there is a Gaussian process that results in spatio-temporal dependence in the data through marginalization.</p>
<p>The examples presented thus far in this chapter have all assumed additive Gaussian error and random-effects distributions. Many spatio-temporal problems of interest deal with distinctly non-Gaussian data (e.g., counts, binary responses, extreme values). One of the most useful aspects of the hierarchical-modeling paradigm is that it allows one to accommodate fairly easily non-Gaussian data models, so long as the observations are <em>conditionally independent</em>, conditional on latent dependent Gaussian processes. This is the spatio-temporal manifestation of traditional generalized linear mixed models (GLMMs) and generalized additive mixed models (GAMMs) in statistics. That is, the likelihood assumes that the observations are conditionally independent given a spatio-temporal mean response that is some transformation of an additive mixed model. Our situation is a bit more flexible than the GLMM and GAMM in that our data model does not necessarily have to be from the , so long as we can allow conditional independence in the observations conditioned on spatio-temporal structure in the hidden process (and/or the associated process parameters).</p>
<p>As an example, consider a data model from the exponential family as in <a href="Chapter3.html#sec-GLMGAM" class="quarto-xref"><span>Section 3.4.1</span></a>, such that</p>
<p><span id="eq-EFdist"><span class="math display">\[
Z(\mathbf{s};t) \mid  Y(\mathbf{s};t), \gamma \; \sim \; \text{indep.} \; EF(Y(\mathbf{s};t), \gamma), \quad \mathbf{s}\in D_s,~t \in D_t,
\tag{4.35}\]</span></span></p>
<p>where <span class="math inline">\(EF\)</span> corresponds to a distribution from the exponential family with scale parameter <span class="math inline">\(\gamma\)</span> and mean <span class="math inline">\(Y(\mathbf{s};t)\)</span>. In <a href="Chapter3.html#sec-GLMGAM" class="quarto-xref"><span>Section 3.4.1</span></a>, we modeled a transformation of the mean response in terms of additive fixed effects (e.g., a linear combination of covariates). Here, we extend that and model the transformed mean response in terms of additive fixed effects and random effects,</p>
<p><span class="math display">\[
g(Y(\mathbf{s};t)) = \mathbf{x}(\mathbf{s};t)' \boldsymbol{\beta}+  \eta(\mathbf{s};t),\quad \mathbf{s}\in D_s, t \in D_t,
\]</span></p>
<p>where <span class="math inline">\(g(\cdot)\)</span> is a specified monotonic link function, <span class="math inline">\(\mathbf{x}(\mathbf{s};t)\)</span> is a <span class="math inline">\(p\)</span>-dimensional vector of covariates for spatial location <span class="math inline">\(\mathbf{s}\)</span> and time <span class="math inline">\(t\)</span>, and <span class="math inline">\(\eta(\mathbf{s};t)\)</span> is a spatio-temporal Gaussian random process that can be modeled either in terms of spatio-temporal covariances (as in <a href="#sec-GaussDataProc" class="quarto-xref"><span>Section 4.2</span></a>), a special case of which uses a basis-function expansion (<a href="#sec-randomeffects" class="quarto-xref"><span>Section 4.3</span></a>), or as a dynamic spatio-temporal process (Chapter 5). The same modeling issues associated with this latent Gaussian spatio-temporal process are present here as with the Gaussian-data case, but estimation of parameters and prediction of <span class="math inline">\(Y(\mathbf{s}_0;t_0)\)</span> are typically more involved given the non-Gaussian data model.</p>
<p>As an illustration, a simple model involving spatio-temporal count data could be represented by</p>
<p><span class="math display">\[
\mathbf{Z}_t \mid  \mathbf{Y}_t \; \sim \; \text{indep.} \; \text{Poi}(\mathbf{Y}_t),
\]</span></p>
<p><span class="math display">\[
\log(\mathbf{Y}_t) =  \mathbf{X}_t \boldsymbol{\beta}+ \boldsymbol{\Phi}_t \boldsymbol{\alpha}_t + \boldsymbol{\nu}_t,
\]</span></p>
<p>where <span class="math inline">\(\mathbf{Z}_t\)</span> is an <span class="math inline">\(m_t\)</span>-dimensional data vector of counts at <span class="math inline">\(m_t\)</span> spatial locations, <span class="math inline">\(\mathbf{Y}_t\)</span> represents the latent spatio-temporal mean process at <span class="math inline">\(m_t\)</span> locations, <span class="math inline">\(\boldsymbol{\Phi}_t\)</span> is an <span class="math inline">\(m_t \times n_\alpha\)</span> matrix of <span class="math inline">\(n_\alpha\)</span> spatial , and the associated random coefficients are modeled as <span class="math inline">\(\boldsymbol{\alpha}_t \; \sim \; \text{Gau}({\mathbf{0}},\mathbf{C}_\alpha)\)</span>, independent in time, with micro-scale error term <span class="math inline">\(\boldsymbol{\nu}_t \; \sim \; \text{indep.} \; \text{Gau}({\mathbf{0}},\sigma^2_\nu \mathbf{I})\)</span>; that is, <span class="math inline">\(\mathbf{C}_\nu = \sigma^2_\nu \mathbf{I}\)</span>. As discussed in <a href="#sec-randeffspat" class="quarto-xref"><span>Section 4.4.2</span></a>, it is often more realistic to consider temporal dependence through a dynamic model on <span class="math inline">\(\{\boldsymbol{\alpha}_t\}\)</span>, which will be explored in Chapter 5. As was the case for the Gaussian data models in <a href="#sec-adderrproc" class="quarto-xref"><span>Section 4.1</span></a>–<a href="#sec-basisfunctions" class="quarto-xref"><span>Section 4.4</span></a>, the parameters <span class="math inline">\(\boldsymbol{\beta}\)</span> and <span class="math inline">\(\boldsymbol{\theta}\)</span> (in <span class="math inline">\(\mathbf{C}_\alpha\)</span> and <span class="math inline">\(\mathbf{C}_\nu\)</span>) could be estimated or a prior distribution could be put on them.</p>
<section id="generalized-additive-models-gams" class="level3" data-number="4.5.1">
<h3 data-number="4.5.1" class="anchored" data-anchor-id="generalized-additive-models-gams"><span class="header-section-number">4.5.1</span> Generalized Additive Models (GAMs)</h3>
<p>We often seek more flexible models that can accommodate nonlinear structure in the mean function. Recall from <a href="Chapter3.html#sec-GLMGAM" class="quarto-xref"><span>Section 3.4.1</span></a> that one successful approach to this problem has been through the use of GAMs. In general, these models consider a transformation of the mean response to have an additive form in which the additive components are smooth functions (e.g., splines) of the covariates, where generally the functions themselves are expressed as basis-function expansions. In practical applications, the basis coefficients are treated as random coefficients in the estimation procedure. However, just as one can add random effects to generalized linear models (GLMs) to get generalized linear mixed models (GLMMs), one can also add (additional) random effects to GAMs to get generalized additive mixed models (GAMMs).</p>
<p>For example, consider data model (<a href="#eq-EFdist" class="quarto-xref">Equation&nbsp;<span>4.35</span></a>). Similarly to <a href="Chapter3.html#eq-gamlink" class="quarto-xref">Equation&nbsp;<span>3.12</span></a>, we can write the transformed mean response additively as</p>
<p><span id="eq-GAM_mgcv"><span class="math display">\[
g(Y(\mathbf{s};t)) = \mathbf{x}(\mathbf{s};t)' \boldsymbol{\beta}+ \sum_{i=1}^{n_f} f_i(\mathbf{x}(\mathbf{s};t);\mathbf{s};t) + \nu(\mathbf{s};t),
\tag{4.36}\]</span></span></p>
<p>where again <span class="math inline">\(g(\cdot)\)</span> is a specified monotonic ; <span class="math inline">\(\mathbf{x}(\mathbf{s};t)\)</span> is a <span class="math inline">\(p\)</span>-dimensional vector of covariates for spatial location <span class="math inline">\(\mathbf{s}\)</span> and time <span class="math inline">\(t\)</span>; <span class="math inline">\(f_i(\cdot)\)</span> are functions of the covariates, the spatial locations, and the time index; and <span class="math inline">\(\nu(\mathbf{s};t)\)</span> is a spatio-temporal random effect. Typically, the functions <span class="math inline">\(f_i(\cdot)\)</span> are modeled in terms of a truncated basis-function expansion; for example, <span class="math inline">\(f_i(x_1(\mathbf{s};t);\mathbf{s};t) = \sum_{k=1}^{q_i} \phi_k(x_1(\mathbf{s};t);\mathbf{s};t) \alpha_{ik}\)</span>. Thus, we can see that the basis-function expansions with random coefficients given in <a href="#eq-Yprocess_stbasis" class="quarto-xref">Equation&nbsp;<span>4.27</span></a>, <a href="#eq-Yprocess_spbasis" class="quarto-xref">Equation&nbsp;<span>4.29</span></a>, and <a href="#eq-Yprocess_tbasis" class="quarto-xref">Equation&nbsp;<span>4.31</span></a> are essentially GAMMs. But, whereas in those models the smooth functions are typically only a function of spatio-temporal location, spatial location, or time, respectively, it is more common in the GAM/GAMM setting to allow the to also depend nonlinearly on covariates. On the other hand, GAM/GAMMs typically assume that the are smooth functions, whereas there is no such requirement for spatio-temporal-basis-function models. GAM/GAMMs can easily be implemented in <code>R</code> (e.g., we provide an example with the <strong>mgcv</strong> package in Lab 4.4).</p>
</section>
<section id="sec-BHMest" class="level3" data-number="4.5.2">
<h3 data-number="4.5.2" class="anchored" data-anchor-id="sec-BHMest"><span class="header-section-number">4.5.2</span> Inference for Spatio-Temporal Hierarchical Models</h3>
<p>Implicit in the estimation associated with the linear Gaussian spatio-temporal model discussed in <a href="#sec-LGestimation" class="quarto-xref"><span>Section 4.2.3</span></a> is that the covariance and fixed-effects parameters can be estimated more easily when we marginalize (integrate) out the latent Gaussian spatio-temporal process. In general, the likelihood is</p>
<p><span id="eq-zmarg"><span class="math display">\[
[\mathbf{Z}\mid  \boldsymbol{\theta}, \boldsymbol{\beta}] = \int [\mathbf{Z}\mid  \mathbf{Y}, \boldsymbol{\theta}][\mathbf{Y}\mid  \boldsymbol{\theta}, \boldsymbol{\beta}] \textrm{d}\mathbf{Y},
\tag{4.37}\]</span></span></p>
<p>viewed as a function of <span class="math inline">\(\boldsymbol{\theta}\)</span> and <span class="math inline">\(\boldsymbol{\beta}\)</span>. For linear mixed models (<a href="#sec-adderrproc" class="quarto-xref"><span>Section 4.1</span></a>–<a href="#sec-basisfunctions" class="quarto-xref"><span>Section 4.4</span></a>), we assumed that the two distributions inside the integral in <a href="#eq-zmarg" class="quarto-xref">Equation&nbsp;<span>4.37</span></a> were Gaussian with linear relationships; this implied that the marginal likelihood function was in the form of a Gaussian density (e.g., <a href="#nte-technote-MargCond" class="quarto-xref">Note&nbsp;<span>4.3</span></a>), and thus can be written in closed form. More generally, we can relax the Gaussian assumption for the data model and, in the models presented here, the latent Gaussian spatio-temporal process <span class="math inline">\(\mathbf{Y}\)</span> is transformed through a nonlinear link function. This lack of Gaussianity and the presence of nonlinearity complicates the analysis, as generally the likelihood <a href="#eq-zmarg" class="quarto-xref">Equation&nbsp;<span>4.37</span></a> cannot be obtained in closed form.</p>
<p>The integral in <a href="#eq-zmarg" class="quarto-xref">Equation&nbsp;<span>4.37</span></a> can in principle be evaluated numerically, from which one can estimate the relatively few fixed effects and covariance parameters <span class="math inline">\(\{\boldsymbol{\beta}, \boldsymbol{\theta}\}\)</span> through numerical optimization. In spatio-temporal models this is complicated by the high dimensionality of the integral; recall that <span class="math inline">\(\mathbf{Y}\)</span> is a <span class="math inline">\((\sum_{t=1}^T m_t)\)</span>-dimensional vector. Traditional approaches to this problem are facilitated by the usual conditional-independence assumption in the data model and by exploiting the latent Gaussian nature of the random effects. These approaches include methods such as Laplace approximation, quasi-likelihood, generalized estimating equations, pseudo-likelihood, and penalized quasi-likelihood. For example, recent advances in automatic differentiation have led to very efficient Laplace approximation approaches for performing inference with such likelihoods, even when there are a very large number of random effects (see, for example, the Template Model Builder (<strong>TMB</strong>) <code>R</code> package). Although these methods are increasingly being used successfully in the spatial context, there has tended to be more focus on Bayesian estimation approaches for spatio-temporal models in the literature. Either way, some type of approximation is needed (approximating the integrals, approximating the models using linearization, or approximating the posterior distribution through various Bayesian computational methods).</p>
<section id="bayesian-hierarchical-modeling" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="bayesian-hierarchical-modeling">Bayesian Hierarchical Modeling</h4>
<p>The hierarchical model (BHM) paradigm provides the estimation and inferential framework for many complex spatio-temporal models in the literature. Recall from <a href="Chapter1.html#nte-BerlinerBHM" class="quarto-xref">Note&nbsp;<span>1.1</span></a> that we can decompose an arbitrary joint distribution in terms of a hierarchical sequence of conditional distributions and a marginal distribution; for example,</p>
<p><span class="math display">\[
[A,B,C] = [A \mid  B, C] [B \mid  C][C].
\]</span></p>
<p>In the context of our general spatio-temporal model given in <a href="#sec-GaussDataProc" class="quarto-xref"><span>Section 4.2</span></a>,</p>
<p><span class="math display">\[
[\mathbf{Z}, \mathbf{Y},\boldsymbol{\beta},\boldsymbol{\theta}] = [\mathbf{Z}\mid  \mathbf{Y}, \boldsymbol{\beta},\boldsymbol{\theta}][\mathbf{Y}\mid  \boldsymbol{\beta}, \boldsymbol{\theta}][\boldsymbol{\beta}\mid  \boldsymbol{\theta}][\boldsymbol{\theta}]
=  [\mathbf{Z}\mid  \mathbf{Y}, \boldsymbol{\theta}_\epsilon][\mathbf{Y}\mid  \boldsymbol{\beta}, \boldsymbol{\theta}_y][\boldsymbol{\theta}_\epsilon][\boldsymbol{\theta}_y][\boldsymbol{\beta}],
\]</span></p>
<p>where <span class="math inline">\(\boldsymbol{\theta}\)</span> contains all of the variance and covariance parameters from the data model and the process model. Note that the first equality is based on the probability decomposition and the second equality is based on writing <span class="math inline">\(\boldsymbol{\theta}=\{\boldsymbol{\theta}_\epsilon, \boldsymbol{\theta}_y\}\)</span> and assuming that <span class="math inline">\(\boldsymbol{\beta}\)</span>, <span class="math inline">\(\boldsymbol{\theta}_\epsilon\)</span>, and <span class="math inline">\(\boldsymbol{\theta}_y\)</span> are independent <em>a priori</em>. Now, Bayes’ Rule implies that</p>
<p><span id="eq-STBayes"><span class="math display">\[
[\mathbf{Y}, \boldsymbol{\beta}, \boldsymbol{\theta}\mid  \mathbf{Z}] \propto [\mathbf{Z}\mid  \mathbf{Y}, \boldsymbol{\theta}_\epsilon][\mathbf{Y}\mid  \boldsymbol{\beta}, \boldsymbol{\theta}_y][\boldsymbol{\beta}][\boldsymbol{\theta}_\epsilon][\boldsymbol{\theta}_y].
\tag{4.38}\]</span></span></p>
<p>For example, in the linear Gaussian case, <span class="math inline">\([\mathbf{Z}\mid  \mathbf{Y}, \boldsymbol{\theta}_\epsilon]\)</span> is given by <a href="#eq-Zdata_vec" class="quarto-xref">Equation&nbsp;<span>4.3</span></a> and <span class="math inline">\([\mathbf{Y}\mid  \boldsymbol{\beta}, \boldsymbol{\theta}_y]\)</span> is given by <a href="#eq-Yproc_vec" class="quarto-xref">Equation&nbsp;<span>4.4</span></a>. The prior distributions <span class="math inline">\([\boldsymbol{\beta}]\)</span>, <span class="math inline">\([\boldsymbol{\theta}_\epsilon]\)</span>, and <span class="math inline">\([\boldsymbol{\theta}_y]\)</span> are then specified according to the particular modeling choices made.</p>
<p>If we are interested in inference on the parameters, then we focus on the posterior distribution, <span class="math inline">\([\boldsymbol{\beta}, \boldsymbol{\theta}\mid \mathbf{Z}]\)</span>; if our interest is in prediction, we focus on the predictive distribution, <span class="math inline">\([\mathbf{Y}\mid \mathbf{Z}]\)</span>. In principle, we can obtain these posterior distributions if we can evaluate the normalizing constant in <a href="#eq-STBayes" class="quarto-xref">Equation&nbsp;<span>4.38</span></a>, which is a function of the data <span class="math inline">\(\mathbf{Z}\)</span>, specifically, the marginal distribution <span class="math inline">\([\mathbf{Z}]\)</span>. However, in the general spatio-temporal case (and in most hierarchical models) there is no analytical form for this normalizing constant, and one must use numerical approximations. A common and useful approach is to use Markov chain Monte Carlo (MCMC) techniques to obtain (Markov dependent) Monte Carlo (MC) samples from the posterior distribution and then to perform inference on the parameters and prediction of the hidden process by summarizing these MC samples (see <a href="#nte-algorithm-GibbsSampler" class="quarto-xref">Note&nbsp;<span>4.5</span></a> for a basic MCMC algorithm). The advantage of the BHM approach is that parameter uncertainty is accounted for directly. But, there is no “free lunch,” and this usually comes at a cost of greater computational complexity.</p>
<p>In cases where the BHM computational complexity is formidable, one can sometimes find approximations that help simplify the computational burden. For example, just as penalized-quasi-likelihood methods use Laplace approximations to deal with the integral in <a href="#eq-zmarg" class="quarto-xref">Equation&nbsp;<span>4.37</span></a>, the integrated nested Laplace approximation (INLA) approach is sometimes well suited for latent Gaussian spatial and spatio-temporal processes. The method exploits the Laplace approximation in Bayesian latent-Gaussian models and does not require generating samples from the posterior distribution. Hence, it can often be used for quite large data sets at reasonable computational expense. We use INLA to fit a latent separable spatio-temporal model in Lab 4.5.</p>
<p>Another way to mitigate the computational burden of a BHM is to obtain estimates <span class="math inline">\(\widehat{\boldsymbol{\theta}}\)</span> of the parameters <span class="math inline">\({\boldsymbol{\theta}}\)</span> outside of the fully <strong>Bayesian</strong> model as in <em>empirical Bayesian estimation</em> <span class="citation" data-cites="carlin2010bayes">(e.g., <a href="references.html#ref-carlin2010bayes" role="doc-biblioref">Carlin and Louis 2010</a>)</span>. As mentioned in Chapter 1, <span class="citation" data-cites="cressie2011statistics">N. Cressie and Wikle (<a href="references.html#ref-cressie2011statistics" role="doc-biblioref">2011</a>)</span> (pp.&nbsp;23–24) call this approach <em>empirical hierarchical modeling</em> in the spatio-temporal context. In this case, one focuses on the “empirical predictive distribution,” <span class="math inline">\([\mathbf{Y}\mid \mathbf{Z}, \widehat{\boldsymbol{\theta}}]\)</span>. The primary example of this in spatio-temporal statistics is S-T kriging as discussed in <a href="#sec-GaussDataProc" class="quarto-xref"><span>Section 4.2</span></a>. That is, rather than assigning prior distributions to the parameters, they are estimated and the estimates are “plugged in” to the closed-form kriging formulas. This typically has the advantage of substantially less computational burden but at a cost of overly liberal uncertainty quantification. Ideally, one should take additional steps to account for the uncertainty associated with using these plug-in estimates (e.g., via the bootstrap).</p>
<!-- ::: {#alg-GibbsSampler .algorithm} -->
<!-- ::::{.algorithm-header} -->
<!-- :::::{.algorithm-icon} -->
<!-- ::::: -->
<!-- Test note -->
<!-- :::: -->
<!-- ::::{.algorithm-body} -->
<!-- Test algorithm -->
<!-- :::: -->
<!-- ::: -->
<div id="nte-algorithm-GibbsSampler" class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;4.5: Basic Gibbs Sampler MCMC Algorithm
</div>
</div>
<div class="callout-body-container callout-body">
<p>Consider the joint posterior distribution of <span class="math inline">\(K\)</span> random variables, <span class="math inline">\(w_1, \ldots, w_K\)</span>, given data, <span class="math inline">\(\mathbf{Z}\)</span>, which we denote as <span class="math inline">\([w_1, \ldots, w_K \; | \; \mathbf{Z}]\)</span>. As is typical, assume that we do not know the normalizing constant for this posterior distribution. Markov chain Monte Carlo (MCMC) approaches can be used to obtain samples from such distributions indirectly. Specifically, rather than compute the posterior distribution directly, one computes successive simulations from a Markov chain constructed so that samples from the stationary distribution of this chain are equivalent to samples from the target posterior distribution. That is, after some “burn-in” time, samples of the chain are viewed as samples simulated from the posterior distribution. Note that these samples are statistically dependent. The posterior distribution can be explored by various Monte Carlo summaries of the MCMC samples.</p>
<p>One of the simplest MCMC algorithms is the <em>Gibbs sampler</em>, which is most appropriate when the distributions of each of the random variables conditioned on all of the others and the data (the “full-conditional” distributions) are available in closed form. For a basic overview, see <span class="citation" data-cites="gelman2013bayesian">Gelman et al. (<a href="references.html#ref-gelman2013bayesian" role="doc-biblioref">2014</a>)</span>. A generic Gibbs sampler algorithm is given below.</p>
<p>An initial step in the Gibbs sampler algorithm is to derive all of the full conditional distributions in closed form. That is, derive</p>
<p><span class="math display">\[
[w_1 | w_2,\ldots,w_K, \mathbf{Z}], \; [w_2 | w_1, w_3,\ldots,w_K, \mathbf{Z}], \ldots,  [w_K | w_1, w_2,\ldots,w_{K-1}, \mathbf{Z}].
\]</span></p>
<ul>
<li><p>Obtain starting values: <span class="math inline">\(\{w_1^{(0)}, \ldots, w_K^{(0)}\}\)</span></p></li>
<li><p>for <span class="math inline">\(i=1,2,\ldots, N_{\mathrm{gibbs}}\)</span> do</p>
<ul>
<li><ol type="1">
<li>Sample <span class="math inline">\(w_1^{(i)} \sim [w_1 | w_2^{(i-1)}, \ldots, w_K^{(i-1)}, \mathbf{Z}]\)</span></li>
</ol></li>
<li><ol start="2" type="1">
<li>Sample <span class="math inline">\(w_2^{(i)} \sim [w_2 | w_1^{(i)}, w_3^{(i-1)}, \ldots, w_K^{(i-1)}, \mathbf{Z}]\)</span></li>
</ol></li>
<li><p>…</p></li>
<li><p>K. Sample <span class="math inline">\(w_K^{(i)} \sim [w_K | w_1^{(i)}, \ldots, w_{K-1}^{(i)}, \mathbf{Z}]\)</span></p></li>
</ul></li>
<li><p>end for</p></li>
<li><p>Discard the first <span class="math inline">\(b\)</span> “burn-in” samples and use the remaining <span class="math inline">\(b+1,\ldots,N_{\mathrm{gibbs}}\)</span> samples as though they are coming from the posterior distribution <span class="math inline">\([w_1,\ldots,w_K | \mathbf{Z}]\)</span>.</p></li>
</ul>
<p>Note that this is one of the most basic MCMC algorithms. Many modifications exist to improve efficiency and deal with the common case where the full conditional distributions are not available in closed form <span class="citation" data-cites="gelman2013bayesian">(see, for example, <a href="references.html#ref-gelman2013bayesian" role="doc-biblioref">Gelman et al. 2014</a>)</span>.</p>
</div>
</div>
</section>
</section>
</section>
<section id="sec-Chap4wrapup" class="level2" data-number="4.6">
<h2 data-number="4.6" class="anchored" data-anchor-id="sec-Chap4wrapup"><span class="header-section-number">4.6</span> Chapter 4 Wrap-Up</h2>
<p>Time marches forward, but it can be valuable to look back at a changing landscape over a period of time. We can describe how space and time interact using spatio-temporal mean and covariance functions, without having to commit to a mechanistic model that expresses the interaction dynamically. Hence, in this chapter we considered spatio-temporal modeling using what we have called the “descriptive” approach. Importantly, we made a clear distinction between the data and the underlying that represents the real-world process upon which measurements were taken. That is, we need to think conditionally! Thus, we considered a data model where the conditional distribution was Gaussian and where the conditional distribution was non-Gaussian. In both cases, we conditioned on a latent Gaussian spatio-temporal process.</p>
<p>We also considered the latent spatio-temporal Gaussian process by specifying the first-order (mean) structure in terms of exogenous covariates (including functions of locations of space or time) and the second-order dependence in terms of spatio-temporal covariance functions. We discussed various assumptions for such models related to stationarity, separability, and full symmetry. These sorts of representations are ideally suited for problems where there are not too many observations or locations in time and space at which one wants to predict, and where either we feel comfortable that we know the dependence structure (and can represent it by covariance functions), or we just want to account for dependence and do not care so much that the model is not all that realistic. In situations with large data sets and/or large numbers of prediction locations, it is often more efficient computationally to consider random-effects representations of the second-order structure using basis-function expansions. The basis-function construction also frees the modeler from having to develop valid spatio-temporal covariance functions, as our conditional basis-function random effects <em>induce</em> a valid marginal covariance function. We considered this from the perspective of that are defined in space and time, in space only, and in time only. The descriptive-modeling framework is similar for each. In addition, we briefly showed how these spatio-temporal mixed models using are related to GAM/GAMMs, depending on the choice of and the estimation approach. An overview of GAMs can be found in <span class="citation" data-cites="R_mgcv">Wood (<a href="references.html#ref-R_mgcv" role="doc-biblioref">2017</a>)</span>.</p>
<p>A potential issue with performing parameter inference in descriptive models with spatial or spatio-temporal random effects is the problem of . Traditionally, this has not been as big a concern in spatial and spatio-temporal statistics because the focus has been on prediction. But, as these methods have increasingly been used to account for dependence when <em>interpreting</em> fixed effects, has received much more attention <span class="citation" data-cites="hodges2010adding">Hodges and Reich (<a href="references.html#ref-hodges2010adding" role="doc-biblioref">2010</a>)</span>; <span class="citation" data-cites="hughes2013dimension">Hughes and Haran (<a href="references.html#ref-hughes2013dimension" role="doc-biblioref">2013</a>)</span>; <span class="citation" data-cites="hanks2015restricted">Hanks et al. (<a href="references.html#ref-hanks2015restricted" role="doc-biblioref">2015</a>)</span>.</p>
<p>An overview of computation for spatial and spatio-temporal descriptive models is presented in <span class="citation" data-cites="diggle2007springer">P. J. Diggle and Ribeiro Jr. (<a href="references.html#ref-diggle2007springer" role="doc-biblioref">2007</a>)</span> and <span class="citation" data-cites="banerjee2015hierarchical">Banerjee, Carlin, and Gelfand (<a href="references.html#ref-banerjee2015hierarchical" role="doc-biblioref">2015</a>)</span>. The INLA approximate- methodology is discussed in <span class="citation" data-cites="rue2009approximate">Rue, Martino, and Chopin (<a href="references.html#ref-rue2009approximate" role="doc-biblioref">2009</a>)</span>, <span class="citation" data-cites="lindgren2011explicit">Lindgren, Rue, and Lindström (<a href="references.html#ref-lindgren2011explicit" role="doc-biblioref">2011</a>)</span>, <span class="citation" data-cites="blangiardo2015spatial">Blangiardo and Cameletti (<a href="references.html#ref-blangiardo2015spatial" role="doc-biblioref">2015</a>)</span>, and <span class="citation" data-cites="krainski2018">Krainski et al. (<a href="references.html#ref-krainski2018" role="doc-biblioref">2019</a>)</span>. Descriptive models that can be formulated using simple dynamic equations in a Bayesian framework can also be implemented using <strong>spTimer</strong> <span class="citation" data-cites="bakar2015sptimer">Bakar and Sahu (<a href="references.html#ref-bakar2015sptimer" role="doc-biblioref">2015</a>)</span> and the function <code>spDynLM</code> in <strong>spBayes</strong> <span class="citation" data-cites="finley2007spbayes">Finley, Banerjee, and Carlin (<a href="references.html#ref-finley2007spbayes" role="doc-biblioref">2007</a>)</span>. Computational methods for non-Bayesian approaches to non-Gaussian spatial data can be found in <span class="citation" data-cites="schabenberger2005statistical">Schabenberger and Gotway (<a href="references.html#ref-schabenberger2005statistical" role="doc-biblioref">2005</a>)</span>. An overview on using <code>R</code> to perform some exploratory and geostatistical modeling for spatio-temporal data can be found in <span class="citation" data-cites="allard2017analyzing">RESSTE Network et al. (<a href="references.html#ref-allard2017analyzing" role="doc-biblioref">2017</a>)</span>.</p>
<p>There are a number of informative books on spatio-temporal statistical methodology. These include <span class="citation" data-cites="le2006statistical">Le and Zidek (<a href="references.html#ref-le2006statistical" role="doc-biblioref">2006</a>)</span>, <span class="citation" data-cites="cressie2011statistics">N. Cressie and Wikle (<a href="references.html#ref-cressie2011statistics" role="doc-biblioref">2011</a>)</span>, <span class="citation" data-cites="sherman2011spatial">Sherman (<a href="references.html#ref-sherman2011spatial" role="doc-biblioref">2011</a>)</span>, <span class="citation" data-cites="blangiardo2015spatial">Blangiardo and Cameletti (<a href="references.html#ref-blangiardo2015spatial" role="doc-biblioref">2015</a>)</span>, <span class="citation" data-cites="diggle2013statistical">Peter J. Diggle (<a href="references.html#ref-diggle2013statistical" role="doc-biblioref">2013</a>)</span>, <span class="citation" data-cites="mateu2013spatio">Mateu and Müller (<a href="references.html#ref-mateu2013spatio" role="doc-biblioref">2013</a>)</span>, <span class="citation" data-cites="baddeley2015spatial">Baddeley, Rubak, and Turner (<a href="references.html#ref-baddeley2015spatial" role="doc-biblioref">2015</a>)</span>, <span class="citation" data-cites="banerjee2015hierarchical">Banerjee, Carlin, and Gelfand (<a href="references.html#ref-banerjee2015hierarchical" role="doc-biblioref">2015</a>)</span>, <span class="citation" data-cites="Montero2015spatial">Montero, Fernández-Avilés, and Mateu (<a href="references.html#ref-Montero2015spatial" role="doc-biblioref">2015</a>)</span>, <span class="citation" data-cites="shaddick2015spatio">Shaddick and Zidek (<a href="references.html#ref-shaddick2015spatio" role="doc-biblioref">2015</a>)</span>, and <span class="citation" data-cites="christakos2017spatiotemporal">Christakos (<a href="references.html#ref-christakos2017spatiotemporal" role="doc-biblioref">2017</a>)</span>.</p>
<p>One of the most challenging aspects of characterizing the spatio-temporal dependence structure, from either the marginal-covariance-model perspective or the conditional-basis-function perspective, is the ability to model real-world interactions that occur across time and space. In that case, the underlying processes are often best described by spatial fields that evolve through time according to “rules” that govern the spatio-temporal variability. That is, they represent a dynamical system. As we shall see in Chapter 5, spatio-temporal models that explicitly account for these dynamics offer the benefit of providing more realistic models in general, and they can simplify model construction and estimation through conditioning.</p>
</section>
<section id="lab-4.1-spatio-temporal-kriging-with-gstat" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="lab-4.1-spatio-temporal-kriging-with-gstat">Lab 4.1: Spatio-Temporal Kriging with <strong>gstat</strong></h2>
<p>In this Lab we go through the process of carrying out spatio-temporal universal kriging using the semivariogram with the package <strong>gstat</strong>. We focus on the maximum temperature data in the NOAA data set (<code>Tmax</code>) in July 1993. In addition to the packages used in Chapter 2 for data wrangling, we need <strong>RColorBrewer</strong> to color some of the surfaces that will be produced.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"sp"</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"spacetime"</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggplot2"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"dplyr"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"gstat"</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"RColorBrewer"</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"STRbook"</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"tidyr"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For S-T kriging of the maximum-temperature data set in July 1993, we need to fit a parametric function to the empirical semivariogram <code>vv</code> computed in Lab 2.3. The code is reproduced below for completeness.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"STObj3"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>STObj4 <span class="ot">&lt;-</span> STObj3[, <span class="st">"1993-07-01::1993-07-31"</span>]</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>vv <span class="ot">&lt;-</span> <span class="fu">variogram</span>(<span class="at">object =</span> z <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> lat, <span class="co"># fixed effect component</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">data =</span> STObj4,      <span class="co"># July data</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>                <span class="at">width =</span> <span class="dv">80</span>,         <span class="co"># spatial bin (80 km)</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>                <span class="at">cutoff =</span> <span class="dv">1000</span>,      <span class="co"># consider pts &lt; 1000 km apart</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>                <span class="at">tlags =</span> <span class="fl">0.01</span><span class="sc">:</span><span class="fl">6.01</span>)  <span class="co"># 0 days to 6 days</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A number of covariance-function models are available with the package <strong>gstat</strong>; see the <strong>gstat</strong> vignette “spatio-temporal-kriging” for details by typing</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">vignette</span>(<span class="st">"spatio-temporal-kriging"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The first semivariogram we consider here corresponds to the spatio-temporal separable covariance function in <a href="#eq-sep_cov" class="quarto-xref">Equation&nbsp;<span>4.18</span></a> and <a href="#eq-exp_cov" class="quarto-xref">Equation&nbsp;<span>4.19</span></a>. Observe from the vignette that a separable covariance function <a href="#eq-sep_cov" class="quarto-xref">Equation&nbsp;<span>4.18</span></a> corresponds to a semivariogram of the form</p>
<p><span class="math display">\[
\gamma^{\mathrm{sep}}(\mathbf{h}; \tau) = \mathrm{sill}\cdot\left(\bar\gamma^{(s)}(\| \mathbf{h}\|) + \bar\gamma^{(t)}(|\tau|) - \bar\gamma^{(s)}(\| \mathbf{h}\|)\bar\gamma^{(t)}(|\tau|)\right),
\]</span></p>
<p>where the “standardized” semivariograms <span class="math inline">\(\bar\gamma^{(s)}\)</span> and <span class="math inline">\(\bar\gamma^{(t)}\)</span> have separate nugget effects and sills equal to 1.</p>
<p>A spatio-temporal semivariogram is constructed with <strong>gstat</strong> using the function <code>vgmST</code>. The argument <code>stModel</code> = <code>"separable"</code> is used to define a separable model, while the function <code>vgm</code> is used to construct the individual semivariograms (one for space and one for time). Several arguments can be passed to <code>vgm</code>. The first four, which we use below, correspond to the partial sill, the model type, the range, and the nugget, respectively. The argument <code>sill</code> that is supplied to <code>vgmST</code> defines the joint spatio-temporal sill. The numbers used in their definition are initial values supplied to the optimization routine used for fitting in the function <code>fit.StVariogram</code>, which fits <code>sepVgm</code> to <code>vv</code>. These initial values should be reasonable – for example, the length scale <span class="math inline">\(\phi\)</span> can be set to a value that spans 10% of the spatial/temporal domain, and the variances/sills can be set such that they have similar orders of magnitude to the total variance of the measurements.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>sepVgm <span class="ot">&lt;-</span> <span class="fu">vgmST</span>(<span class="at">stModel =</span> <span class="st">"separable"</span>,</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>                <span class="at">space =</span> <span class="fu">vgm</span>(<span class="dv">10</span>, <span class="st">"Exp"</span>, <span class="dv">400</span>, <span class="at">nugget =</span> <span class="fl">0.1</span>),</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">time =</span> <span class="fu">vgm</span>(<span class="dv">10</span>, <span class="st">"Exp"</span>, <span class="dv">1</span>, <span class="at">nugget =</span> <span class="fl">0.1</span>),</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">sill =</span> <span class="dv">20</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>sepVgm <span class="ot">&lt;-</span> <span class="fu">fit.StVariogram</span>(vv, sepVgm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The second model we fit has the covariance function given in <a href="#eq-metric_cov" class="quarto-xref">Equation&nbsp;<span>4.20</span></a>. For this model, the function <code>vgmST</code> takes the <code>joint</code> semivariogram as an argument, as well as the sill (<code>sill</code>) and the scaling factor (<code>stAni</code>), denoted by <span class="math inline">\(a\)</span> in <span class="math inline">\(\mathbf{v}\)</span>, defined just below <a href="#eq-metric_cov" class="quarto-xref">Equation&nbsp;<span>4.20</span></a>. This parameter can be initially set by considering orders of magnitudes – if the spatial field is evolving on scales of the order of hundreds of kilometers and the temporal evolution has a scale on the order of days, then an initial value of <code>stAni</code> = <code>100</code> is reasonable.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>metricVgm <span class="ot">&lt;-</span> <span class="fu">vgmST</span>(<span class="at">stModel =</span> <span class="st">"metric"</span>,</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">joint =</span> <span class="fu">vgm</span>(<span class="dv">100</span>, <span class="st">"Exp"</span>, <span class="dv">400</span>, <span class="at">nugget =</span> <span class="fl">0.1</span>),</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>                   <span class="at">sill =</span> <span class="dv">10</span>,</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>                   <span class="at">stAni =</span> <span class="dv">100</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>metricVgm <span class="ot">&lt;-</span> <span class="fu">fit.StVariogram</span>(vv, metricVgm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can compare the fits of the two semivariograms by checking the mean squared error of the fits. These can be found by directly accessing the final function value of the optimizer used by <code>fit.StVariogram</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>metricMSE <span class="ot">&lt;-</span> <span class="fu">attr</span>(metricVgm, <span class="st">"optim"</span>)<span class="sc">$</span>value</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>sepMSE <span class="ot">&lt;-</span> <span class="fu">attr</span>(sepVgm, <span class="st">"optim"</span>)<span class="sc">$</span>value</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here the variable <code>metricMSE</code> is 2.1 while <code>sepMSE</code> is 1.4, indicating that the separable semivariogram gives a better fit to the empirical semivariogram in this case. The fitted semivariograms can be plotted using the standard <code>plot</code> function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(vv, <span class="fu">list</span>(sepVgm, metricVgm), <span class="at">main =</span> <span class="st">"Semi-variance"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Contour plots of the fitted variograms are shown in the bottom panels of <a href="#fig-cov_fits" class="quarto-xref">Figure&nbsp;<span>4.4</span></a>. The corresponding stationary S-T covariance function is obtained from <a href="#eq-var2ndorder" class="quarto-xref">Equation&nbsp;<span>4.15</span></a>.</p>
<p>Next, we use the fitted S-T covariance models for prediction using S-T kriging, in this case <em>universal</em> S-T kriging since we are treating the latitude coordinate as a covariate. First, we need to create a space-time prediction grid. For our spatial grid, we consider 20 spatial locations between 100°W and 80°W, and 20 spatial locations between 32°N and 46°N. In the code below, when converting to <code>SpatialPoints</code>, we ensure that the coordinate reference system (CRS) of the prediction grid is the same as that of the observations.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>spat_pred_grid <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">lon =</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="dv">100</span>, <span class="sc">-</span><span class="dv">80</span>, <span class="at">length =</span> <span class="dv">20</span>),</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                      <span class="at">lat =</span> <span class="fu">seq</span>(<span class="dv">32</span>, <span class="dv">46</span>, <span class="at">length =</span> <span class="dv">20</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>            <span class="fu">SpatialPoints</span>(<span class="at">proj4string =</span> <span class="fu">CRS</span>(<span class="fu">proj4string</span>(STObj3)))</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="fu">gridded</span>(spat_pred_grid) <span class="ot">&lt;-</span> <span class="cn">TRUE</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For our temporal grid, we consider six equally spaced days in July 1993.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>temp_pred_grid <span class="ot">&lt;-</span> <span class="fu">as.Date</span>(<span class="st">"1993-07-01"</span>) <span class="sc">+</span> <span class="fu">seq</span>(<span class="dv">3</span>, <span class="dv">28</span>, <span class="at">length =</span> <span class="dv">6</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can then combine <code>spat_pred_grid</code> and <code>temp_pred_grid</code> to construct an <code>STF</code> object for our space-time prediction grid.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>DE_pred <span class="ot">&lt;-</span> <span class="fu">STF</span>(<span class="at">sp =</span> spat_pred_grid,    <span class="co"># spatial part</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>               <span class="at">time =</span> temp_pred_grid)  <span class="co"># temporal part</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Since there are missing observations in <code>STObj4</code>, we first need to cast <code>STObj4</code> into either an <code>STSDF</code> or an <code>STIDF</code>, and remove the data recording missing observations. For simplicity here, we consider the <code>STIDF</code> (considering <code>STSDF</code> would be around twice as fast). Also, in order to show the capability of S-T kriging to predict across time, we omitted data on 14 July 1993 from the data set.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>STObj5 <span class="ot">&lt;-</span> <span class="fu">as</span>(STObj4[, <span class="sc">-</span><span class="dv">14</span>], <span class="st">"STIDF"</span>)         <span class="co"># convert to STIDF</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>STObj5 <span class="ot">&lt;-</span> <span class="fu">subset</span>(STObj5, <span class="sc">!</span><span class="fu">is.na</span>(STObj5<span class="sc">$</span>z))   <span class="co"># remove missing data</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can call <code>krigeST</code> using <code>STObj5</code> as our data.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>pred_kriged <span class="ot">&lt;-</span> <span class="fu">krigeST</span>(z <span class="sc">~</span> <span class="dv">1</span> <span class="sc">+</span> lat,         <span class="co"># latitude trend</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>                       <span class="at">data =</span> STObj5,       <span class="co"># data set w/o 14 July</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>                       <span class="at">newdata =</span> DE_pred,   <span class="co"># prediction grid</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>                       <span class="at">modelList =</span> sepVgm,  <span class="co"># semivariogram</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>                       <span class="at">computeVar =</span> <span class="cn">TRUE</span>)   <span class="co"># compute variances</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To plot the predictions and accompanying prediction standard errors, it is straightforward to use the function <code>stplot</code>. First, we define our color palette using the function <code>brewer.pal</code> and the function <code>colorRampPalette</code> (see help files for details on what these functions do).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>color_pal <span class="ot">&lt;-</span> <span class="fu">rev</span>(<span class="fu">colorRampPalette</span>(<span class="fu">brewer.pal</span>(<span class="dv">11</span>, <span class="st">"Spectral"</span>))(<span class="dv">16</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Second, we call the <code>stplot</code> function with the object containing the results.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">stplot</span>(pred_kriged,</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>       <span class="at">main =</span> <span class="st">"Predictions (degrees Fahrenheit)"</span>,</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>       <span class="at">layout =</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">2</span>),</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>       <span class="at">col.regions =</span> color_pal)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The prediction (kriging) standard errors can be plotted in a similar way.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>pred_kriged<span class="sc">$</span>se <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(pred_kriged<span class="sc">$</span>var1.var)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">stplot</span>(pred_kriged[, , <span class="st">"se"</span>],</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>       <span class="at">main =</span> <span class="st">"Prediction std. errors (degrees Fahrenheit)"</span>,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>       <span class="at">layout =</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">2</span>),</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>       <span class="at">col.regions =</span> color_pal)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Spatio-temporal kriging as shown in this Lab is relatively quick and easy to implement for small data sets, but it starts to become prohibitive as data sets grow in size, unless some approximation is used. For example, the function <code>krigeST</code> allows one to use the argument <code>nmax</code> to determine the maximum number of observations to use when doing prediction. The predictor is no longer optimal, but it is close enough to the optimal predictor in many cases of practical interest.</p>
</section>
<section id="lab-4.2-spatio-temporal-basis-functions-with-frk" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="lab-4.2-spatio-temporal-basis-functions-with-frk">Lab 4.2: Spatio-Temporal Basis Functions with <strong>FRK</strong></h2>
<p>In this Lab we shall focus on modeling the maximum temperature in July 1993 from data in the NOAA data set using spatio-temporal basis functions. The packages we need are the following:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"dplyr"</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"FRK"</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggplot2"</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"gstat"</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"RColorBrewer"</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"sp"</span>)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"spacetime"</span>)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"STRbook"</span>)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"tidyr"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The package <strong>FRK</strong> implements a low-rank approach to spatial and spatio-temporal modeling known as <em>fixed rank kriging</em> (FRK). FRK considers the random-effects model <a href="#eq-Yprocess_stbasis" class="quarto-xref">Equation&nbsp;<span>4.27</span></a>, sometimes known as the spatio-temporal random-effects model <span class="citation" data-cites="cressie2010fixed">(<a href="references.html#ref-cressie2010fixed" role="doc-biblioref">Noel Cressie, Shi, and Kang 2010</a>)</span>, and provides functionality to the user for choosing the basis functions <span class="math inline">\(\{\phi_i(\mathbf{s};t) : i = 1,\dots,n_\alpha\}\)</span> from the data.</p>
<p>A key difference between <strong>FRK</strong> and other geostatistical packages is that, in <strong>FRK</strong>, modeling and prediction are carried out on a fine, regular discretization of the spatio-temporal domain. The small grid cells are known as <em>basic areal units</em> (BAUs), and their primary utility is to account for problems of change of support (varying measurement footprint), which we do not consider in this Lab. The package is loaded by typing in the console</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"FRK"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For spatio-temporal modeling and prediction, <strong>FRK</strong> requires the user to provide the point-level data as objects of class <code>STIDF</code>. Hence, for this exercise, we use <code>STObj5</code> from Lab 3.1, which we reconstruct below (for completeness) from <code>STObj3</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"STObj3"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)          <span class="co"># load STObj3</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>STObj4 <span class="ot">&lt;-</span> STObj3[, <span class="st">"1993-07-01::1993-07-31"</span>] <span class="co"># subset time</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>STObj5 <span class="ot">&lt;-</span> <span class="fu">as</span>(STObj4[, <span class="sc">-</span><span class="dv">14</span>], <span class="st">"STIDF"</span>)         <span class="co"># omit t = 14</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>STObj5 <span class="ot">&lt;-</span> <span class="fu">subset</span>(STObj5, <span class="sc">!</span><span class="fu">is.na</span>(STObj5<span class="sc">$</span>z))   <span class="co"># remove NAs</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="fu">proj4string</span>(STObj5) <span class="ot">&lt;-</span> <span class="fu">CRS</span>(<span class="st">"+proj=longlat +ellps=WGS84 +no_defs"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The spatio-temporal BAUs are constructed using the function <code>auto_BAUs</code> which takes several arguments, as shown below and detailed using the in-line comments. For more details see <code>help(auto_BAUs)</code>. Note that as <code>cellsize</code> we chose <code>c(1, 0.75, 1)</code> which indicates a BAU size of 1 degree longitude <span class="math inline">\(\times\)</span> 0.75 degrees latitude <span class="math inline">\(\times\)</span> 1 day – this choice ensures that the BAUs are similar to the prediction grid used in Lab 3.1. The argument <code>convex</code> is an “extension radius” used in domain construction via the package <strong>INLA</strong>. See the help file of <code>inla.nonconvex.hull</code> for details.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>BAUs <span class="ot">&lt;-</span> <span class="fu">auto_BAUs</span>(<span class="at">manifold =</span> <span class="fu">STplane</span>(),   <span class="co"># ST field on the plane</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>                  <span class="at">type =</span> <span class="st">"grid"</span>,          <span class="co"># gridded (not "hex")</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>                  <span class="at">data =</span> STObj5,          <span class="co"># data</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>                  <span class="at">cellsize =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="fl">0.75</span>, <span class="dv">1</span>), <span class="co"># BAU cell size</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>                  <span class="at">convex =</span> <span class="sc">-</span><span class="fl">0.12</span>,           <span class="co"># hull extension</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>                  <span class="at">tunit =</span> <span class="st">"days"</span>)           <span class="co"># time unit is "days"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The BAUs are of class <code>STFDF</code> since they are three-dimensional pixels arranged regularly in both space and in time. To plot the spatial BAUs overlaid with the data locations, we run</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">as</span>(BAUs[, <span class="dv">1</span>], <span class="st">"SpatialPixels"</span>))    <span class="co"># plot pixel BAUs</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">SpatialPoints</span>(STObj5),</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">add =</span> <span class="cn">TRUE</span>, <span class="at">col =</span> <span class="st">"red"</span>)           <span class="co"># plot data points</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This generates the left panel of <a href="#fig-BAUs" class="quarto-xref">Figure&nbsp;<span>4.9</span></a>. The BAUs, which we will also use as our prediction grid, overlap all the data points. The user has other options in BAU construction; for example, the following code generates <em>hexagonal</em> BAUs using a convex hull for a boundary.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>BAUs_hex <span class="ot">&lt;-</span> <span class="fu">auto_BAUs</span>(<span class="at">manifold =</span> <span class="fu">STplane</span>(), <span class="co"># model on the plane</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>                  <span class="at">type =</span> <span class="st">"hex"</span>,             <span class="co"># hex (not "grid")</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>                  <span class="at">data =</span> STObj5,            <span class="co"># data</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>                  <span class="at">cellsize =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="fl">0.75</span>, <span class="dv">1</span>), <span class="co"># BAU cell size</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>                  <span class="at">nonconvex_hull =</span> <span class="cn">FALSE</span>,   <span class="co"># convex hull</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>                  <span class="at">tunit =</span> <span class="st">"days"</span>)           <span class="co"># time unit is "days"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Plotting proceeds in a similar fashion, except that the first line in the code chunk above now becomes</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">as</span>(BAUs_hex[, <span class="dv">1</span>], <span class="st">"SpatialPolygons"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This allows for the fact that the BAUs are now (hexagonal) polygons and not rectangular pixels. The resulting plot is shown in the right panel of <a href="#fig-BAUs" class="quarto-xref">Figure&nbsp;<span>4.9</span></a>.</p>
<div id="fig-BAUs" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-BAUs-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/BAUs.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-BAUs-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.9: BAUs constructed for modeling and predicting maximum temperature from data in the NOAA data set. Left: Gridded BAUs arranged within a non-convex hull enclosing the data. Right: Hexagonal BAUs arranged within a convex hull enclosing the data.
</figcaption>
</figure>
</div>
<p>Next, we construct the basis functions <span class="math inline">\(\{\phi_i(\mathbf{s};t) : i = 1,\dots,n_\alpha\}\)</span>. In <strong>FRK</strong>, these are constructed by taking the tensor product of spatial basis functions with temporal basis functions. Specifically, consider a set of <span class="math inline">\(r_s\)</span> spatial basis functions <span class="math inline">\(\{\phi_{p}(\mathbf{s}): p = 1,\dots,r_s\}\)</span>, and a set of <span class="math inline">\(r_t\)</span> temporal basis functions <span class="math inline">\(\{\psi_{q}(t): q = 1,\dots,r_t\}\)</span>. Then we construct the set of spatio-temporal basis functions as <span class="math inline">\(\{\phi_{st,u}(s,t) : u = 1,\dots,r_sr_t\} = \{\phi_{p}(\mathbf{s})\psi_{q}(t) : p = 1,\dots,r_s;\ q = 1,\dots,r_t\}\)</span>.</p>
<p>The generic basis function that <strong>FRK</strong> uses by default is the bisquare function (see <a href="#fig-spat_basis_fn" class="quarto-xref">Figure&nbsp;<span>4.7</span></a>) given by</p>
<p><span class="math display">\[
b(\mathbf{s},\mathbf{v}) \equiv \left\{\begin{array}{ll} \{1 - (\|\mathbf{v}- \mathbf{s}\|/r)^2\}^2, &amp;\| \mathbf{v}-\mathbf{s}\| \le r, \\
0, &amp; \textrm{otherwise}, \end{array} \right.
\]</span></p>
<p>where <span class="math inline">\(r\)</span> is the aperture parameter. Basis functions can be either regularly placed or irregularly placed, and they are often multiresolutional. We choose two resolutions below, yielding <span class="math inline">\(r_s = 94\)</span> spatial basis functions in total, and place them irregularly in the domain. (Note that <span class="math inline">\(r_s\)</span> and the bisquare apertures are determined automatically by <code>auto_basis</code>.)</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>G_spatial <span class="ot">&lt;-</span> <span class="fu">auto_basis</span>(<span class="at">manifold =</span> <span class="fu">plane</span>(),      <span class="co"># fns on plane</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>                        <span class="at">data =</span> <span class="fu">as</span>(STObj5, <span class="st">"Spatial"</span>), <span class="co"># project</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>                        <span class="at">nres =</span> <span class="dv">2</span>,                     <span class="co"># 2 res.</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>                        <span class="at">type =</span> <span class="st">"bisquare"</span>,            <span class="co"># bisquare.</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>                        <span class="at">regular =</span> <span class="dv">0</span>)                  <span class="co"># irregular</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Temporal basis functions also need to be defined. We use the function <code>local_basis</code> below to construct a regular sequence of <span class="math inline">\(r_t = 20\)</span> bisquare basis functions between day 1 and day 31 of the month. Each of these bisquare basis functions is assigned an aperture of 2 days; that is, the support of each bisquare function is 4 days. The temporal grid is defined through</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>t_grid <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">seq</span>(<span class="dv">1</span>, <span class="dv">31</span>, <span class="at">length =</span> <span class="dv">20</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The basis functions are constructed using the following commands.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>G_temporal <span class="ot">&lt;-</span> <span class="fu">local_basis</span>(<span class="at">manifold =</span> <span class="fu">real_line</span>(),  <span class="co"># fns on R1</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>                          <span class="at">type =</span> <span class="st">"bisquare"</span>,       <span class="co"># bisquare</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>                          <span class="at">loc =</span> t_grid,            <span class="co"># centroids</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>                          <span class="at">scale =</span> <span class="fu">rep</span>(<span class="dv">2</span>, <span class="dv">20</span>))      <span class="co"># aperture par.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, we construct the <span class="math inline">\(r_sr_t = 1880\)</span> spatio-temporal basis functions by taking the tensor product of the spatial and the temporal ones, using the function <code>TensorP</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>G <span class="ot">&lt;-</span> <span class="fu">TensorP</span>(G_spatial, G_temporal)      <span class="co"># take the tensor product</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The basis functions <code>G_spatial</code> and <code>G_temporal</code> can be visualized using the plotting function <code>show_basis</code>; see <a href="#fig-ST_basis" class="quarto-xref">Figure&nbsp;<span>4.10</span></a>. While the basis functions are of tensor-product form, the resulting S-T covariance function obtained from the spatio-temporal random effects model is not separable in space and time.</p>
<div id="fig-ST_basis" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ST_basis-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/STbasis.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ST_basis-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.10: Spatial and temporal basis functions used to construct the spatio-temporal basis functions. Left: Locations of spatial basis functions (circles denote spatial support). Right: Temporal basis functions.
</figcaption>
</figure>
</div>
<p>In <strong>FRK</strong>, the fine-scale variation term at the BAU level, <a href="#eq-Yprocess_basis_vec" class="quarto-xref">Equation&nbsp;<span>4.28</span></a>, is assumed to be Gaussian with covariance matrix proportional to <span class="math inline">\(\textrm{diag}(\{\sigma^2_{\nu,i}\})\)</span>, where <span class="math inline">\(\{\sigma^2_{\nu,i}: i = 1,\dots,n_y\}\)</span> are pre-specified at the BAU level (the constant of proportionality is then estimated by <strong>FRK</strong>). Typically, these are related to some geographically related quantity such as surface roughness. In our case, we simply set <span class="math inline">\(\sigma^2_{\nu,i} = 1\)</span> for all <span class="math inline">\(i\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>BAUs<span class="sc">$</span>fs <span class="ot">=</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The fine-scale variance at the BAU level is confounded with the measurement-error variance. In some cases, the measurement-error variance is known; when it is not (as in this case), one can carry out a simple analysis to estimate the value of the semivariogram at the origin. In this case, we simply assume that the nugget effect estimated when fitting the separable covariance function in Lab 4.1 is the measurement-error variance – any residual nugget component is then assumed to be the fine-scale variance introduced as a consequence of the low-rank approximation to the process. The measurement-error variance is specified in the <code>std</code> field in the data <code>ST</code> object.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>STObj5<span class="sc">$</span>std <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fl">0.049</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The response variable and covariates are identified through a standard <code>R</code> formula. In this case, we use latitude as a covariate and set</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">&lt;-</span> z <span class="sc">~</span> lat <span class="sc">+</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We are now ready to call the main function <code>FRK</code>, which estimates all the unknown parameters in the models, including the covariance matrix of the basis-function coefficients and the fine-scale variance. We need to supply the formula, the data, the basis functions, the BAUs, and any other parameters configuring the expectation-maximization (EM) algorithm used for finding the maximum likelihood estimates. To reduce processing time, we have set the number of EM-algorithm steps to 3. Convergence of the EM algorithm can be assessed visually by setting <code>print_lik = TRUE</code> below.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>S <span class="ot">&lt;-</span> <span class="fu">FRK</span>(<span class="at">f =</span> f,               <span class="co"># formula</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>         <span class="at">data =</span> <span class="fu">list</span>(STObj5), <span class="co"># (list of) data</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">basis =</span> G,           <span class="co"># basis functions</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>         <span class="at">BAUs =</span> BAUs,         <span class="co"># BAUs</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>         <span class="at">n_EM =</span> <span class="dv">3</span>,            <span class="co"># max. no. of EM iterations</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>         <span class="at">tol =</span> <span class="fl">0.01</span>)          <span class="co"># tol. on change in log-likelihood</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Once the model is fitted, prediction proceeds via the function <code>predict</code>. If the argument <code>newdata</code> is not specified, then prediction is done at all the BAUs.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>grid_BAUs <span class="ot">&lt;-</span> <span class="fu">predict</span>(S)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The resulting object, <code>grid_BAUs</code>, is also of class <code>STFDF</code>, and plotting proceeds as per Lab 4.1 using the <code>stplot</code> function. The resulting predictions and prediction standard errors are illustrated in <a href="#fig-pred_FRK" class="quarto-xref">Figure&nbsp;<span>4.6</span></a>.</p>
</section>
<section id="lab-4.3-temporal-basis-functions-with-spatiotemporal" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="lab-4.3-temporal-basis-functions-with-spatiotemporal">Lab 4.3: Temporal Basis Functions with <strong>SpatioTemporal</strong></h2>
<p>In this Lab we model the maximum temperature in the NOAA data set (<code>Tmax</code>) using temporal basis functions and spatial random fields. Specifically, we use the model</p>
<p><span id="eq-Yprocess_tbasis2"><span class="math display">\[
Y(\mathbf{s};t) = \mathbf{x}(\mathbf{s};t)' \boldsymbol{\beta}+ \sum_{i=1}^{n_\alpha} \phi_{i}(t) \alpha_i(\mathbf{s}) + \nu(\mathbf{s};t),
\tag{4.39}\]</span></span></p>
<p>where <span class="math inline">\(\mathbf{x}(\mathbf{s};t)\)</span> are the covariates; <span class="math inline">\(\boldsymbol{\beta}\)</span> are the regression coefficients; <span class="math inline">\(\{\phi_i(t)\}\)</span> are the temporal basis functions; <span class="math inline">\(\{\alpha_i(\mathbf{s})\}\)</span> are coefficients of the temporal basis functions, modeled as multivariate (spatial) random fields; and <span class="math inline">\(\nu(\mathbf{s};t)\)</span> is a spatially correlated, but temporally independent, random process.</p>
<p>Spatio-temporal modeling using temporal basis functions can be carried out using the package <strong>SpatioTemporal</strong>. For this Lab we require the following packages.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"dplyr"</span>)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggplot2"</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"gstat"</span>)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"RColorBrewer"</span>)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"sp"</span>)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"spacetime"</span>)</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"SpatioTemporal"</span>)</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"STRbook"</span>)</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"tidyr"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The space-time object used by <strong>SpatioTemporal</strong> is of class <code>STdata</code> and is created using the function <code>createSTdata</code>. This function takes the data either as a space-wide matrix with the row names containing the date and the column names the station ID, or as a data frame in long form. Here we use the latter. This data frame needs to have the station ID as characters in the field <code>ID</code>, the data in the field <code>obs</code>, and the date in the field <code>date</code>. A new data frame of this form can be easily created using the function <code>transmute</code> from the package <strong>dplyr</strong>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"NOAA_df_1990"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)   <span class="co"># load NOAA data</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>NOAA_sub <span class="ot">&lt;-</span> <span class="fu">filter</span>(NOAA_df_1990,       <span class="co"># filter data to only</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>                   year <span class="sc">==</span> <span class="dv">1993</span> <span class="sc">&amp;</span>      <span class="co"># contain July 1993</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>                   month <span class="sc">==</span> <span class="dv">7</span> <span class="sc">&amp;</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>                   proc <span class="sc">==</span> <span class="st">"Tmax"</span>)     <span class="co"># and just max. temp.</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>NOAA_sub_for_STdata <span class="ot">&lt;-</span> NOAA_sub <span class="sc">%&gt;%</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>                       <span class="fu">transmute</span>(<span class="at">ID =</span> <span class="fu">as.character</span>(id),</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">obs =</span> z,</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">date =</span> date)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The covariates that will be used to model the spatially varying effects also need to be supplied as a data frame. In our case we only consider the station coordinates as covariates. The station coordinates are extracted from the maximum temperature data as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>covars <span class="ot">&lt;-</span>  dplyr<span class="sc">::</span><span class="fu">select</span>(NOAA_sub, id, lat, lon) <span class="sc">%&gt;%</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>           <span class="fu">unique</span>() <span class="sc">%&gt;%</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>           dplyr<span class="sc">::</span><span class="fu">rename</span>(<span class="at">ID =</span> id)      <span class="co"># createSTdata expects "ID"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can construct the <code>STdata</code> object by calling the function <code>createSTdata</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>STdata <span class="ot">&lt;-</span> <span class="fu">createSTdata</span>(NOAA_sub_for_STdata, <span class="at">covars =</span> covars)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The model used in <strong>SpatioTemporal</strong> assumes that <span class="math inline">\(\nu(\mathbf{s};t)\)</span> is temporally uncorrelated. Consequently, all temporal variability needs to be captured through the covariates or the basis functions. To check whether the data exhibit temporal autocorrelation (before adding any temporal basis functions), one can use the <code>plot</code> function. For example, we plot the estimated autocorrelation function for station 3812 in the left panel of <a href="#fig-ACFs" class="quarto-xref">Figure&nbsp;<span>4.11</span></a> (after the mean is removed from the data). The plot suggests that the data are correlated (the estimated lag-1 autocorrelation coefficient is larger than would be expected by chance at the 5% level of significance).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(STdata, <span class="st">"acf"</span>, <span class="at">ID =</span> <span class="st">"3812"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The role of the temporal basis functions is to adequately capture temporal modes of variation. When modeling data over a time interval that spans years, one of these is typically a seasonal component. As another example, when modeling trace-gas emissions, one basis function to use would be one that captures weekday/weekend cycles typically found in gaseous pollutants (e.g., due to vehicular traffic). The package <strong>SpatioTemporal</strong> allows for user-defined basis functions (see the example at the end of this Lab) or data-driven basis functions (which we consider now). In both cases, the first temporal basis function, <span class="math inline">\(\phi_1(t)\)</span>, is a constant; that is, <span class="math inline">\(\phi_1(t) = 1\)</span>.</p>
<p>The basis functions extracted from the data are <em>smoothed</em>, <em>left singular vectors</em> (i.e., smoothed temporal EOFs) of the matrix <span class="math inline">\(\widetilde{\mathbf{Z}}\)</span>, described in <a href="Chapter2.html#nte-technote-EOFs" class="quarto-xref">Note&nbsp;<span>2.2</span></a>. These make up the remaining <span class="math inline">\(n_\alpha - 1\)</span> basis functions, upon which smoothing is carried out using splines. In <strong>SpatioTemporal</strong>, these basis functions are found (or set) using the function <code>updateTrend</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>STdata <span class="ot">&lt;-</span> <span class="fu">updateTrend</span>(STdata, <span class="at">n.basis =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can see that the lag-1 autocorrelation coefficient is no longer significant (at the 5% level) after adding in these basis functions; see the right panel of <a href="#fig-ACFs" class="quarto-xref">Figure&nbsp;<span>4.11</span></a>. In practice, one should add basis functions until temporal autocorrelation in the data (at most stations) is considerably reduced. In this case study, it can be shown that 69% of stations record maximum temperature data that have lag-1 autocorrelation coefficients that are significant at the 5% level. On the other hand, with <code>n.basis = 2</code> (i.e., with two temporal basis functions for capturing temporal variation), the proportion of stations with residuals exhibiting a significant lag-1 autocorrelation coefficient is 26%.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(STdata, <span class="st">"acf"</span>, <span class="at">ID =</span> <span class="st">"3812"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fig-ACFs" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-ACFs-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/ACF1_ACF2_combined.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-ACFs-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.11: Left: Estimated autocorrelation function for the time series of maximum temperature <code>Tmax</code> at Station 3812. Right: Same as left panel, but with the data first detrended using an intercept and the two temporal basis functions shown in the top panel of <a href="#fig-temp_basis_fn" class="quarto-xref">Figure&nbsp;<span>4.8</span></a>.
</figcaption>
</figure>
</div>
<p>The basis functions, available in <code>STdata$trend</code>, are shown in the top panel of <a href="#fig-temp_basis_fn" class="quarto-xref">Figure&nbsp;<span>4.8</span></a>.</p>
<p>In <strong>SpatioTemporal</strong>, the spatial quantities <span class="math inline">\(\{\alpha_i(\mathbf{s})\}\)</span> are themselves modeled as spatial fields. Once the <span class="math inline">\(\{\phi_i(t)\}\)</span> are declared, empirical estimates of <span class="math inline">\(\{\alpha_i(\mathbf{s})\}\)</span> can be found using the function <code>estimateBetaFields</code>. Note that we use the Greek letter “alpha” to denote these fields, which differs from the name “Beta” inside the command. The following and all subsequent references to “Beta” and “beta” should be interpreted as representing spatial fields <span class="math inline">\(\{\alpha_i(\mathbf{s})\}\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>beta.lm <span class="ot">&lt;-</span> <span class="fu">estimateBetaFields</span>(STdata)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The resulting object, <code>beta.lm</code>, contains two fields; <code>beta</code> (estimated coefficients) and <code>beta.sd</code> (standard error of the estimates) with row names equal to the station ID, and three columns corresponding to estimates of <span class="math inline">\(\alpha_1(\mathbf{s})\)</span>, <span class="math inline">\(\alpha_2(\mathbf{s})\)</span>, and <span class="math inline">\(\alpha_3(\mathbf{s})\)</span>, respectively. We are interested in seeing whether the empirical estimates are correlated with our covariate, latitude. To this end, the authors of <strong>SpatioTemporal</strong> suggest using the package <strong>plotrix</strong>, and the function <code>plotCI</code>, to plot the estimates and covariance intervals against a covariate of choice. When plotting using <code>plotCI</code>, care should be taken that the ordering of the stations in <code>beta</code> and <code>beta.sd</code> is the same as that if the covariate data frame. For example, consider</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">row.names</span>(beta.lm<span class="sc">$</span>beta))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "13865" "13866" "13871" "13873" "13874" "13876"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(covars<span class="sc">$</span>ID)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 3804 3810 3811 3812 3813 3816</code></pre>
</div>
</div>
<p>This illustrates a discrepancy, since the ordering of strings is not necessarily that of the ordered integers. For this reason, we recommend employing best practice and always merging (e.g., using <code>left_join</code>) on a column variable; in this case, we choose the integer version of the field <code>ID</code>. In the following commands, we first convert the <code>beta</code> and <code>beta.sd</code> objects into data frames, add the column <code>ID</code>, join into a data frame <code>BETA</code>, and then combine with <code>covars</code> containing the latitude data.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>beta.lm<span class="sc">$</span>beta <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(beta.lm<span class="sc">$</span>beta)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>beta.lm<span class="sc">$</span>beta.sd <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(beta.lm<span class="sc">$</span>beta.sd)</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>beta.lm<span class="sc">$</span>beta<span class="sc">$</span>ID <span class="ot">&lt;-</span> <span class="fu">as.integer</span>(<span class="fu">row.names</span>(beta.lm<span class="sc">$</span>beta))</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>BETA <span class="ot">&lt;-</span> <span class="fu">cbind</span>(beta.lm<span class="sc">$</span>beta, beta.lm<span class="sc">$</span>beta.sd)</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(BETA) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"alpha1"</span>, <span class="st">"alpha2"</span>, <span class="st">"alpha3"</span>, <span class="st">"ID"</span>,</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>                    <span class="st">"alpha1_CI"</span>, <span class="st">"alpha2_CI"</span>, <span class="st">"alpha3_CI"</span>)</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>BETA <span class="ot">&lt;-</span> <span class="fu">left_join</span>(BETA, covars, <span class="at">by =</span> <span class="st">"ID"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Once <code>BETA</code> is constructed, the empirical estimates can be plotted using <code>ggplot</code>, with <code>geom_errorbar</code> to also plot error bars, as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(BETA) <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">x =</span> lat, <span class="at">y =</span> alpha1)) <span class="sc">+</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_errorbar</span>(<span class="fu">aes</span>(<span class="at">x =</span> lat,</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>                      <span class="at">ymin =</span> alpha1 <span class="sc">-</span> <span class="fl">1.96</span><span class="sc">*</span>alpha1_CI,</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>                      <span class="at">ymax =</span> alpha1 <span class="sc">+</span> <span class="fl">1.96</span><span class="sc">*</span>alpha1_CI)) <span class="sc">+</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ylab</span>(<span class="fu">expression</span>(alpha[<span class="dv">1</span>](s))) <span class="sc">+</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">xlab</span>(<span class="st">"lat (deg)"</span>) <span class="sc">+</span> <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The three empirical estimates, plotted as a function of latitude, are shown in <a href="#fig-alpha_emp_ests" class="quarto-xref">Figure&nbsp;<span>4.12</span></a>. The function <span class="math inline">\(\alpha_1(\mathbf{s})\)</span> exhibits a strong latitudinal trend, as expected; <span class="math inline">\(\alpha_2(\mathbf{s})\)</span> shows a weak latitudinal trend; and <span class="math inline">\(\alpha_3(\mathbf{s})\)</span> exhibits no trend. For this reason, we model the expectations of these fields as <a href="#eq-alpha1" class="quarto-xref">Equation&nbsp;<span>4.32</span></a>–<a href="#eq-alpha3" class="quarto-xref">Equation&nbsp;<span>4.34</span></a>, where <span class="math inline">\(s_2\)</span> denotes the latitude coordinate at <span class="math inline">\(\mathbf{s}= (s_1, s_2)'\)</span>. Note that in this model we do not consider any spatio-temporal covariates, and hence the term <span class="math inline">\(\mathbf{x}(\mathbf{s};t)'\boldsymbol{\beta}= 0\)</span> in <a href="#eq-Yprocess_tbasis2" class="quarto-xref">Equation&nbsp;<span>4.39</span></a>. This does not mean that we do not have an intercept in our model: although it is random, the spatial field <span class="math inline">\(\alpha_1(\mathbf{s})\)</span> acts as a temporally invariant spatial covariate and includes a global space-time mean (<span class="math inline">\(\alpha_{11}\)</span> in <a href="#eq-alpha1" class="quarto-xref">Equation&nbsp;<span>4.32</span></a>), which is estimated.</p>
<div id="fig-alpha_emp_ests" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-alpha_emp_ests-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/alpha_emp_ests.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-alpha_emp_ests-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.12: Empirical estimates of <span class="math inline">\(\alpha_1(\mathbf{s})\)</span>, <span class="math inline">\(\alpha_2(\mathbf{s})\)</span>, and <span class="math inline">\(\alpha_3(\mathbf{s})\)</span> at each station, with 95% confidence intervals, plotted as a function of latitude.
</figcaption>
</figure>
</div>
<p>We let the covariance functions <span class="math inline">\(\textrm{cov}(\alpha_i(\mathbf{s}),\alpha_i(\mathbf{s}+ \mathbf{h}))\)</span>, <span class="math inline">\(i = 1,2,3\)</span>, be exponential covariance functions without a nugget-effect term. In <strong>SpatioTemporal</strong> these are declared as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>cov.beta <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">covf =</span> <span class="st">"exp"</span>, <span class="at">nugget =</span> <span class="cn">FALSE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>All that remains for constructing the spatio-temporal model is to define the spatial covariance function of the zero-mean, temporally independent, residual process <span class="math inline">\(\nu(\mathbf{s};t)\)</span>; see <a href="#eq-Yprocess_tbasis2" class="quarto-xref">Equation&nbsp;<span>4.39</span></a>. We choose this to be an exponential covariance function with a nugget effect to account for measurement error. The argument <code>random.effect = FALSE</code> is used to indicate that there is no random mean offset for the field at each time point.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>cov.nu <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">covf =</span> <span class="st">"exp"</span>,</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>               <span class="at">nugget =</span> <span class="sc">~</span><span class="dv">1</span>,</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>               <span class="at">random.effect =</span> <span class="cn">FALSE</span>) <span class="co"># No random mean</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>                                      <span class="co"># for each nu</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The function to create the spatio-temporal model is <code>createSTmodel</code>. This takes as data the object <code>STdata</code>, the covariates for the <span class="math inline">\(\alpha\)</span>-fields (an intercept and latitude for <span class="math inline">\(\alpha_1(\mathbf{s})\)</span> and <span class="math inline">\(\alpha_2(\mathbf{s})\)</span>, and just an intercept for <span class="math inline">\(\alpha_3(\mathbf{s})\)</span>; see <a href="#eq-alpha1" class="quarto-xref">Equation&nbsp;<span>4.32</span></a>–<a href="#eq-alpha3" class="quarto-xref">Equation&nbsp;<span>4.34</span></a>), the covariance functions of the <span class="math inline">\(\alpha\)</span>-fields and the <span class="math inline">\(\nu\)</span>-field, and a list containing the names of station coordinate fields (<code>lon</code> and <code>lat</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>locations <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">coords =</span> <span class="fu">c</span>(<span class="st">"lon"</span>, <span class="st">"lat"</span>))</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>LUR <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="sc">~</span>lat, <span class="sc">~</span>lat, <span class="sc">~</span><span class="dv">1</span>)  <span class="co"># lat trend for phi1 and phi2 only</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>STmodel <span class="ot">&lt;-</span> <span class="fu">createSTmodel</span>(STdata,              <span class="co"># data</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>                         <span class="at">LUR =</span> LUR,           <span class="co"># spatial covariates</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>                         <span class="at">cov.beta =</span> cov.beta, <span class="co"># cov. of alphas</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>                         <span class="at">cov.nu =</span> cov.nu,     <span class="co"># cov. of nu</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>                         <span class="at">locations =</span> locations) <span class="co"># coord. names</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In order to fit the spatio-temporal model to the data, we need to provide initial values of the parameter estimates. The required parameter names can be extracted using the function <code>loglikeSTnames</code> and, for our model, are as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>parnames <span class="ot">&lt;-</span> <span class="fu">loglikeSTnames</span>(STmodel, <span class="at">all =</span> <span class="cn">FALSE</span>)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(parnames)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "log.range.const.exp"           "log.sill.const.exp"           
[3] "log.range.V1.exp"              "log.sill.V1.exp"              
[5] "log.range.V2.exp"              "log.sill.V2.exp"              
[7] "nu.log.range.exp"              "nu.log.sill.exp"              
[9] "nu.log.nugget.(Intercept).exp"</code></pre>
</div>
</div>
<p>Noting that all parameters are log-transforms of the quantities of interest, we let all of the initial values be equal to 3 (so that all initial ranges and sills are <span class="math inline">\(e^3 \approx 20\)</span>). This seems reasonable when the temperature is varying on the order of several degrees Fahrenheit, and where the domain also spans several degrees (in latitude and longitude).</p>
<p>We use the function <code>estimate</code> below to fit the spatio-temporal model to the data. This may take several minutes on a standard desktop computer. In this instance, the resulting object <code>SpatioTemporalfit1</code> has been pre-computed and can be loaded directly from <strong>STRbook</strong> by typing <code>data("SpatioTemporalfit1", package = "STRbook")</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>x.init <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">3</span>, <span class="dv">9</span>, <span class="dv">1</span>)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(x.init) <span class="ot">&lt;-</span> <span class="fu">loglikeSTnames</span>(STmodel, <span class="at">all =</span> <span class="cn">FALSE</span>)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>SpatioTemporalfit1 <span class="ot">&lt;-</span> <span class="fu">estimate</span>(STmodel, x.init)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The fitted coefficients for the parameters described by <code>parnames</code> above can be extracted from the fitted object using the function <code>coef</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>x.final <span class="ot">&lt;-</span> <span class="fu">coef</span>(SpatioTemporalfit1, <span class="at">pars =</span> <span class="st">"cov"</span>)<span class="sc">$</span>par</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Having fitted the model, we now predict at unobserved locations. First, we establish the spatial and temporal grid upon which to predict; this proceeds by first initializing an <code>STdata</code> object on a grid. We construct the grid following a very similar approach to what was done in Lab 4.1.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Define space-time grid</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>spat_pred_grid <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(<span class="at">lon =</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="dv">100</span>, <span class="sc">-</span><span class="dv">80</span>, <span class="at">length =</span> <span class="dv">20</span>),</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>                      <span class="at">lat =</span> <span class="fu">seq</span>(<span class="dv">32</span>, <span class="dv">46</span>, <span class="at">length =</span> <span class="dv">20</span>))</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>spat_pred_grid<span class="sc">$</span>id <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(spat_pred_grid)</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>temp_pred_grid <span class="ot">&lt;-</span> <span class="fu">as.Date</span>(<span class="st">"1993-07-01"</span>) <span class="sc">+</span> <span class="fu">seq</span>(<span class="dv">3</span>, <span class="dv">28</span>, <span class="at">length =</span> <span class="dv">6</span>)</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="do">## Initialize data matrix</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>obs_pred_wide <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, <span class="at">nrow =</span> <span class="dv">6</span>, <span class="at">ncol =</span> <span class="dv">400</span>)</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a><span class="do">## Set row names and column names</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(obs_pred_wide) <span class="ot">&lt;-</span> <span class="fu">as.character</span>(temp_pred_grid)</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(obs_pred_wide) <span class="ot">&lt;-</span> spat_pred_grid<span class="sc">$</span>id</span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>covars_pred <span class="ot">&lt;-</span> spat_pred_grid                     <span class="co"># covariates</span></span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>STdata_pred <span class="ot">&lt;-</span> <span class="fu">createSTdata</span>(<span class="at">obs =</span> obs_pred_wide,  <span class="co"># ST object</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>                            <span class="at">covars =</span> covars_pred)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now prediction proceeds using the function <code>predict</code>, which requires as arguments the model, the fitted model parameters, and the data matrix <code>STdata_pred</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>E <span class="ot">&lt;-</span> <span class="fu">predict</span>(STmodel, x.final, <span class="at">STdata =</span> STdata_pred)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The returned object <code>E</code> contains both the <span class="math inline">\(\alpha\)</span>-fields predictions as well as the <span class="math inline">\(Y\)</span>-field prediction at the unobserved locations. For example, <code>E$beta$EX</code> contains the conditional expectations of <span class="math inline">\(\alpha_1(\mathbf{s}),\alpha_2(\mathbf{s})\)</span>, and <span class="math inline">\(\alpha_3(\mathbf{s})\)</span> given the data. For conciseness, we do not illustrate the plotting commands here. In the bottom panels of <a href="#fig-temp_basis_fn" class="quarto-xref">Figure&nbsp;<span>4.8</span></a>, we show the conditional expectations, while in <a href="#fig-SpatioTemporal_pred" class="quarto-xref">Figure&nbsp;<span>4.13</span></a> and <a href="#fig-SpatioTemporal_se" class="quarto-xref">Figure&nbsp;<span>4.14</span></a> we show the predictions and prediction standard errors of maximum temperature over six days of interest in July 1993.</p>
<div id="fig-SpatioTemporal_pred" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-SpatioTemporal_pred-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/SpatioTemporal_pred.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-SpatioTemporal_pred-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.13: Predictions of <code>Tmax</code> in degrees Fahrenheit within a square lat-lon box defining the spatial domain of interest, for six days in July 1993, using temporal basis functions. Data for 14 July 1993 were deliberately omitted from the original data set.
</figcaption>
</figure>
</div>
<div id="fig-SpatioTemporal_se" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-SpatioTemporal_se-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/SpatioTemporal_se.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-SpatioTemporal_se-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.14: Prediction standard errors of <code>Tmax</code> in degrees Fahrenheit within a square lat-lon box enclosing the spatial domain of interest, for six days in July 1993, using temporal basis functions. Data for 14 July 1993 were deliberately omitted from the original data set.
</figcaption>
</figure>
</div>
<section id="using-spatiotemporal-for-modeling-spatial-effects-of-temporal-covariates" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="using-spatiotemporal-for-modeling-spatial-effects-of-temporal-covariates"><strong>Using SpatioTemporal for Modeling Spatial Effects of Temporal Covariates</strong></h4>
<p>In the first part of this Lab, we extracted the temporal basis functions from the data. However, <strong>SpatioTemporal</strong> can also be used to model the spatially varying effect of exogenous temporal covariates. This can be done by manually setting the <code>STdata$trend</code> data frame. When modeling temperature, interesting covariates may include a periodic signal with period equal to one year, or an index such as the El Niño Southern Oscillation (ENSO) Index.</p>
<p>To use a pre-existing covariate, we need to use the <code>fnc</code> argument in <code>updateTrend</code> to define a function that takes a <code>Date</code> object as an input and returns the covariate at these dates. The easiest way to do this in this example is to specify a look-up table in the function containing the covariate for each date, but an interpolant can also be used when the covariate has missing information for one or more dates.</p>
<p>As an exercise, repeat the Lab above, but this time use a single linear temporal trend as a temporal covariate. The look-up table we need is just a two-column data frame containing the <code>date</code> in the first column, and <code>V1</code> (first covariate) in the second column. This can be set up as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>all_dates <span class="ot">&lt;-</span> NOAA_sub<span class="sc">$</span>date <span class="sc">%&gt;%</span> <span class="fu">unique</span>()     <span class="co"># dates</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>lookup <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">date =</span> all_dates,      <span class="co"># covariate (linear)</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>                     <span class="at">V1 =</span> <span class="fu">scale</span>(<span class="fu">as.numeric</span>(all_dates)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Type <code>plot(lookup)</code> to see the temporal covariate that we have just created. Now we need to create the function that takes a <code>Date</code> object as input and returns the required covariate values. This can be done using <code>left_join</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Function that returns the covariates in a data frame</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="do">## at the required dates</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>fnc <span class="ot">&lt;-</span> <span class="cf">function</span>(dates) {</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">left_join</span>(<span class="fu">data.frame</span>(<span class="at">date =</span> dates),</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>            lookup, <span class="at">by =</span> <span class="st">"date"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">-</span>date)</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can call <code>updateTrend</code> with our covariate function as argument.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>STdata <span class="ot">&lt;-</span> <span class="fu">updateTrend</span>(STdata, <span class="at">fnc =</span> fnc)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The rest of the code remains largely similar, except that now we are considering only two temporal basis functions and not three (the first basis function is constant in time, and the second one is linear in time). Changing the required parts of the code is left as an exercise.</p>
<!-- ```{r SpatioTemporal_plots, message=FALSE, echo=FALSE, fig.keep="none"} -->
<!-- par(mfrow=c(2,2), mar=c(3.3,3.3,1.5,1), mgp=c(2,1,0), pty="s") -->
<!-- latorder <- order(as.integer(row.names(beta.lm$beta))) -->
<!-- for(i in 1:3){ -->
<!--     plotCI(x=beta.lm$beta[latorder,i], y=pred$beta$EX[,i], -->
<!--            uiw=1.96*beta.lm$beta.sd[,i], err="x", -->
<!--            pch=NA, sfrac=0.005, -->
<!--            main=paste("Beta-field for f", i, "(t)", sep=""), -->
<!--            xlab="Empirical estimate", -->
<!--            ylab="Spatio-Temporal Model") -->
<!--     plotCI(x=beta.lm$beta[latorder,i], y=pred$beta$EX[,i], -->
<!--            uiw=1.96*sqrt(pred$beta$VX[,i]), -->
<!--            add=TRUE, pch=NA, sfrac=0.005) -->
<!--     abline(0, 1, col="grey") -->
<!-- } -->
<!-- with(pred$LTA, plotCI(colMeans(obs_wide, na.rm=TRUE), EX, uiw=1.96*sqrt(VX.pred), -->
<!--                       ylab="Predictions", xlab="Observations", -->
<!--                       main="Average NOx (log ppb)")) -->
<!-- abline(0, 1, col="grey") -->
<!-- new_pred_loc <- data.frame(lon=cv_lon - lonmean, -->
<!--                            lat=cv_lat - latmean, -->
<!--                            x= cv_lon*100, -->
<!--                            y = cv_lat*100, -->
<!--                            row.names=as.character(cv_station)) -->
<!-- covars_pred <- rbind(covars,new_pred_loc) -->
<!-- STdata_pred <-  createSTdata(obs=obs_wide, covars=covars_pred) -->
<!-- STdata_pred <- updateTrend(STdata_pred, n.basis=2) -->
<!-- STmodel_pred <- createSTmodel(STdata_pred, LUR=LUR, -->
<!--                               cov.beta=cov.beta, cov.nu=cov.nu, -->
<!--                               locations=locations) -->
<!-- x <- coef(est.STmodel2, pars="cov")$par -->
<!-- ``` -->
</section>
</section>
<section id="lab-4.4-non-gaussian-spatio-temporal-gams-with-mgcv" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="lab-4.4-non-gaussian-spatio-temporal-gams-with-mgcv">Lab 4.4: Non-Gaussian Spatio-Temporal GAMs with <strong>mgcv</strong></h2>
<p>Generalized additive models (GAMs) and generalized additive mixed models (GAMMs) can be implemented quickly and efficiently with the package <strong>mgcv</strong> and the functions <code>gam</code> and <code>gamm</code>, respectively. For a comprehensive treatment of GAMs and GAMMs and their implementation through <strong>mgcv</strong>, see <span class="citation" data-cites="R_mgcv">Wood (<a href="references.html#ref-R_mgcv" role="doc-biblioref">2017</a>)</span>.</p>
<p>In this Lab, we aim to predict the expected counts at arbitrary spatio-temporal locations from the vector of observed counts <span class="math inline">\(\mathbf{Z}\)</span>. The data we use are the Carolina wren counts in the BBS data set described in <a href="Chapter2.html#sec-STdata" class="quarto-xref"><span>Section 2.1</span></a>. We require the package <strong>mgcv</strong> as well as <strong>dplyr</strong>, <strong>tidyr</strong>, <strong>ggplot2</strong>, and <strong>STRbook</strong>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"dplyr"</span>)</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggplot2"</span>)</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"mgcv"</span>)</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"STRbook"</span>)</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"tidyr"</span>)</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"MOcarolinawren_long"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>GAMs and GAMMs rely on constructing smooth functions of the covariates, and in a spatio-temporal context, these will inevitably include space and time. In this Lab, we consider the following simple GAM (see <a href="#eq-GAM_mgcv" class="quarto-xref">Equation&nbsp;<span>4.36</span></a>):</p>
<p><span id="eq-GAMform"><span class="math display">\[
g(Y(\mathbf{s};t)) = \beta + f(\mathbf{s};t) + \nu(\mathbf{s};t),
\tag{4.40}\]</span></span></p>
<p>where <span class="math inline">\(g(\cdot)\)</span> is a link function, <span class="math inline">\(\beta\)</span> is an intercept, the function <span class="math inline">\(f(\mathbf{s};t)\)</span> is a random smooth function of space and time, and <span class="math inline">\(\nu(\mathbf{s};t)\)</span> is a spatio-temporal white-noise error process.</p>
<p>In <strong>mgcv</strong>, the random function <span class="math inline">\(f(\mathbf{s};t)\)</span> is generally decomposed using a separable <em>spline</em> basis. Now, there are several basis functions that can be used to reconstruct <span class="math inline">\(f(\mathbf{s};t)\)</span>, some of which are knot-based (e.g., B-splines). For the purpose of this Lab, it is sufficient to know that splines, of whatever order, are decomposed into a set of basis functions. Thus, <span class="math inline">\(f(\mathbf{s};t)\)</span> is decomposed as <span class="math inline">\(\sum_{i=1}^{r_1}\phi_{1i}(\mathbf{s};t)\alpha_{1i}\)</span>, where the <span class="math inline">\(\{\alpha_{1i}\}\)</span> are unknown random effects that need to be predicted, and the <span class="math inline">\(\{\phi_{1i}\}\)</span> are given below.</p>
<p>There are a number of basis functions that can be chosen. Those derived from thin-plate regression splines are convenient, as they are easily amenable to multiple covariates (e.g., functions of <span class="math inline">\((\mathbf{s};t) \equiv (s_1,s_2; t)\)</span>). Thin-plate splines are isotropic and invariant to rotation but not invariant to covariate scaling. Hence, the use of thin-plate splines for fitting a curve over space <em>and</em> time is not recommended, since units in time are different from those in space.</p>
<p>To combine interacting covariates with different units, such as space and time, <strong>mgcv</strong> implements a tensor-product structure, whereby the basis functions smoothing the individual covariates are combined productwise. That is,</p>
<p><span class="math display">\[
f(\mathbf{s};t) = \sum_{i=1}^{r_1}\sum_{j=1}^{r_2}\phi_{1i}(\mathbf{s})\phi_{2j}(t)\alpha_{ij} \equiv \boldsymbol{\phi}(\mathbf{s};t)' \boldsymbol{\alpha}.
\]</span></p>
<p>The function <code>te</code> forms the product from the marginals; for example, in our case this can be achieved by using <code>te(lon,lat,t)</code>. Other arguments can be passed to <code>te</code> for added functionality; for example, the basis-function class is specified through <code>bs</code>, the number of basis functions through <code>k</code>, and the dimension of each spline through <code>d</code>. In this case, we employ a thin-plate spline basis over longitude and latitude (<code>"tp"</code>) and a cubic regression spline over time (<code>"cr"</code>). A GAM formula for <a href="#eq-GAMform" class="quarto-xref">Equation&nbsp;<span>4.40</span></a> is implemented as follows:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">&lt;-</span> cnt <span class="sc">~</span> <span class="fu">te</span>(lon, lat, t,         <span class="co"># inputs over which to smooth</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>              <span class="at">bs =</span> <span class="fu">c</span>(<span class="st">"tp"</span>, <span class="st">"cr"</span>),  <span class="co"># types of bases</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>              <span class="at">k =</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">10</span>),       <span class="co"># knot count in each dimension</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>              <span class="at">d =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">1</span>))         <span class="co"># (s,t) basis dimension</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We chose <span class="math inline">\(r_1 = 50\)</span> basis functions for the spatial component and <span class="math inline">\(r_2 = 10\)</span> for the temporal component. These values were chosen after some trial and error. The number of knots could have been set using cross-validation; see Chapter 3. In general, the estimated degrees of freedom should be considerably lower than the total number of knots; if this is not the case, probably the number of knots should be increased.</p>
<p>In Lab 3.4 we saw that the Carolina wren counts are over-dispersed. To account for this, we use the negative-binomial distribution to model the response in <a href="#eq-EFdist" class="quarto-xref">Equation&nbsp;<span>4.35</span></a> (a quasi-Poisson model would also be suitable). The <code>gam</code> function is called in the code below, where we specify the negative-binomial family and a log link (the function <span class="math inline">\(g(\cdot)\)</span> in <a href="#eq-GAMform" class="quarto-xref">Equation&nbsp;<span>4.40</span></a>):</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>cnts <span class="ot">&lt;-</span> <span class="fu">gam</span>(f, <span class="at">family =</span> <span class="fu">nb</span>(<span class="at">link =</span> <span class="st">"log"</span>),</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>             <span class="at">data =</span> MOcarolinawren_long)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The returned object is a <code>gam</code> object, which extends <code>glm</code> and <code>lm</code> objects (i.e., functions that can be applied to <code>glm</code> and <code>lm</code> objects, such as <code>residuals</code>, can also be applied to <code>gam</code> objects). The negative-binomial distribution handles over-dispersion in the data through a size parameter <span class="math inline">\(r\)</span>, such that, for a fixed mean, the negative-binomial distribution approaches the Poisson distribution as <span class="math inline">\(r \rightarrow \infty\)</span>. In this case, the estimated value for <span class="math inline">\(r\)</span> (named <code>Theta</code> in <strong>mgcv</strong>) is</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>cnts<span class="sc">$</span>family<span class="sc">$</span><span class="fu">getTheta</span>(<span class="at">trans =</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 5.178305</code></pre>
</div>
</div>
<p>which is not large and suggestive of over-dispersion. Several graphical diagnostics relating to the fit can be explored using the <code>gam.check</code> function.</p>
<p>To predict the field at unobserved locations using the hierarchical model, we first construct a space-time grid upon which to predict.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>MOlon <span class="ot">&lt;-</span> MOcarolinawren_long<span class="sc">$</span>lon</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>MOlat <span class="ot">&lt;-</span> MOcarolinawren_long<span class="sc">$</span>lat</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="do">## Construct space-time grid {.unnumbered}</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>grid_locs <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(<span class="at">lon =</span> <span class="fu">seq</span>(<span class="fu">min</span>(MOlon) <span class="sc">-</span> <span class="fl">0.2</span>,</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>                                   <span class="fu">max</span>(MOlon) <span class="sc">+</span> <span class="fl">0.2</span>,</span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">length.out =</span> <span class="dv">80</span>),</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>                         <span class="at">lat =</span> <span class="fu">seq</span>(<span class="fu">min</span>(MOlat) <span class="sc">-</span> <span class="fl">0.2</span>,</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>                                   <span class="fu">max</span>(MOlat) <span class="sc">+</span> <span class="fl">0.2</span>,</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">length.out =</span> <span class="dv">80</span>),</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>                         <span class="at">t =</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">max</span>(MOcarolinawren_long<span class="sc">$</span>t))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then we call the function <code>predict</code> which, when <code>se.fit = TRUE</code>, returns a list containing the predictions and their associated prediction standard errors.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">predict</span>(cnts, grid_locs, <span class="at">se.fit =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Specifically, the predictions and prediction standard errors are available in <code>X$fit</code> and <code>X$se.fit</code>, respectively. These can be plotted using <strong>ggplot2</strong> as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Put data to plot into data frame</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>grid_locs<span class="sc">$</span>pred <span class="ot">&lt;-</span> X<span class="sc">$</span>fit</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>grid_locs<span class="sc">$</span>se <span class="ot">&lt;-</span> X<span class="sc">$</span>se.fit</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a><span class="do">## Plot predictions and overlay observations</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>g1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_raster</span>(<span class="at">data =</span> grid_locs,</span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>                <span class="fu">aes</span>(lon, lat, <span class="at">fill =</span> <span class="fu">pmin</span>(<span class="fu">pmax</span>(pred, <span class="sc">-</span><span class="dv">1</span>), <span class="dv">5</span>))) <span class="sc">+</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">facet_wrap</span>(<span class="sc">~</span>t, <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">ncol =</span> <span class="dv">7</span>) <span class="sc">+</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="at">data =</span> <span class="fu">filter</span>(MOcarolinawren_long, <span class="sc">!</span><span class="fu">is.na</span>(cnt)),</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>               <span class="fu">aes</span>(lon, lat),</span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>               <span class="at">colour =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="dv">3</span>) <span class="sc">+</span></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="at">data=</span><span class="fu">filter</span>(MOcarolinawren_long, <span class="sc">!</span><span class="fu">is.na</span>(cnt)),</span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>               <span class="fu">aes</span>(lon, lat, <span class="at">colour =</span> <span class="fu">log</span>(cnt)),</span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>               <span class="at">size =</span> <span class="dv">2</span>) <span class="sc">+</span></span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fill_scale</span>(<span class="at">limits =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>, <span class="dv">5</span>),</span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>               <span class="at">name =</span> <span class="fu">expression</span>(<span class="fu">log</span>(Y[t]))) <span class="sc">+</span></span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a>    <span class="fu">col_scale</span>(<span class="at">name =</span> <span class="st">"log(cnt)"</span>, <span class="at">limits=</span><span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>, <span class="dv">5</span>)) <span class="sc">+</span></span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_bw</span>()</span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true" tabindex="-1"></a><span class="do">## Plot prediction standard errors</span></span>
<span id="cb65-22"><a href="#cb65-22" aria-hidden="true" tabindex="-1"></a>g2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb65-23"><a href="#cb65-23" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_raster</span>(<span class="at">data =</span> grid_locs,</span>
<span id="cb65-24"><a href="#cb65-24" aria-hidden="true" tabindex="-1"></a>                <span class="fu">aes</span>(lon, lat, <span class="at">fill =</span> <span class="fu">pmin</span>(se, <span class="fl">2.5</span>))) <span class="sc">+</span></span>
<span id="cb65-25"><a href="#cb65-25" aria-hidden="true" tabindex="-1"></a>    <span class="fu">facet_wrap</span>(<span class="sc">~</span>t, <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">ncol =</span> <span class="dv">7</span>) <span class="sc">+</span></span>
<span id="cb65-26"><a href="#cb65-26" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fill_scale</span>(<span class="at">palette =</span> <span class="st">"BrBG"</span>,</span>
<span id="cb65-27"><a href="#cb65-27" aria-hidden="true" tabindex="-1"></a>               <span class="at">limits =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">2.5</span>),</span>
<span id="cb65-28"><a href="#cb65-28" aria-hidden="true" tabindex="-1"></a>               <span class="at">name =</span> <span class="fu">expression</span>(s.e.)) <span class="sc">+</span></span>
<span id="cb65-29"><a href="#cb65-29" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The plots are shown in <a href="#fig-GAMpred" class="quarto-xref">Figure&nbsp;<span>4.15</span></a> and <a href="#fig-GAMse" class="quarto-xref">Figure&nbsp;<span>4.16</span></a>, respectively. One may also use the <code>plot.gam</code> function on <code>cnts</code> to quickly generate plots of the tensor products.</p>
<div id="fig-GAMpred" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-GAMpred-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/GAM_predictions.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-GAMpred-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.15: Posterior mean of <span class="math inline">\(\log(Y(\cdot))\)</span> on a grid for <span class="math inline">\(t=1\)</span> (the year 1994) to <span class="math inline">\(t=21\)</span> (the year 2014), based on a negative-binomial data model using the package <strong>mgcv</strong>. The log of the observed count is shown in circles using the same color scale.
</figcaption>
</figure>
</div>
<div id="fig-GAMse" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-GAMse-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/GAM_se.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-GAMse-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.16: Posterior standard deviation (i.e., prediction standard error) of <span class="math inline">\(\log(Y(\cdot))\)</span> on a grid for <span class="math inline">\(t=1\)</span> (the year 1994) to <span class="math inline">\(t=21\)</span> (the year 2014), based on a negative-binomial data model using the package <strong>mgcv</strong>.
</figcaption>
</figure>
</div>
</section>
<section id="lab-4.5-non-gaussian-spatio-temporal-models-with-inla" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="lab-4.5-non-gaussian-spatio-temporal-models-with-inla">Lab 4.5: Non-Gaussian Spatio-Temporal Models with <strong>INLA</strong></h2>
<p>Integrated Nested Laplace Approximation (INLA) is a Bayesian method that provides approximate marginal (posterior) distributions over all states and parameters. The package <strong>INLA</strong> allows for a variety of modeling approaches, and the reader is referred to the book by <span class="citation" data-cites="blangiardo2015spatial">Blangiardo and Cameletti (<a href="references.html#ref-blangiardo2015spatial" role="doc-biblioref">2015</a>)</span> for an extensive treatment. Other useful resources are <span class="citation" data-cites="R_INLA">Lindgren and Rue (<a href="references.html#ref-R_INLA" role="doc-biblioref">2015</a>)</span> and <span class="citation" data-cites="krainski2018">Krainski et al. (<a href="references.html#ref-krainski2018" role="doc-biblioref">2019</a>)</span>.</p>
<p>In this Lab we shall predict expected counts at arbitrary space-time locations from the vector of observed counts <span class="math inline">\(\mathbf{Z}\)</span>. The data we use are the Carolina wren counts in the BBS data set described in <a href="Chapter2.html#sec-STdata" class="quarto-xref"><span>Section 2.1</span></a>. For this Lab, we require the package <strong>INLA</strong> as well as <strong>dplyr</strong>, <strong>tidyr</strong>, <strong>ggplot2</strong>, and <strong>STRbook</strong>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"INLA"</span>)</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"dplyr"</span>)</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"tidyr"</span>)</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"ggplot2"</span>)</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">"STRbook"</span>)</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"MOcarolinawren_long"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Consider the data model,</p>
<p><span id="eq-INLAmodel1"><span class="math display">\[
\mathbf{Z}_t | \mathbf{Y}_t \; \sim \; ind.~NB(\mathbf{Y}_t, r),
\tag{4.41}\]</span></span></p>
<p>and the process model,</p>
<p><span id="eq-INLAmodel2"><span class="math display">\[
\log(\mathbf{Y}_t) =  \mathbf{X}_t \boldsymbol{\beta}+ \boldsymbol{\Phi}_t \boldsymbol{\alpha}_t.
\tag{4.42}\]</span></span></p>
<p>In <a href="#eq-INLAmodel1" class="quarto-xref">Equation&nbsp;<span>4.41</span></a> and <a href="#eq-INLAmodel2" class="quarto-xref">Equation&nbsp;<span>4.42</span></a>, <span class="math inline">\(\mathbf{Z}_t\)</span> is an <span class="math inline">\(m_t\)</span>-dimensional data vector of counts at <span class="math inline">\(m_t\)</span> spatial locations, <span class="math inline">\(E(\mathbf{Z}_t | \mathbf{Y}_t) = \mathbf{Y}_t\)</span>, <span class="math inline">\(\mathbf{Y}_t\)</span> represents the latent spatio-temporal mean process at <span class="math inline">\(m_t\)</span> locations, <span class="math inline">\(\boldsymbol{\Phi}_t\)</span> is an <span class="math inline">\(m_t \times n_\alpha\)</span> matrix of spatial basis functions, <span class="math inline">\(r\)</span> is the size parameter, and the associated random coefficients are modeled as <span class="math inline">\(\boldsymbol{\alpha}_t \; \sim \; \text{Gau}({\mathbf{0}},\mathbf{C}_\alpha)\)</span>.</p>
<p>In order to fit this hierarchical model, we need to generate the basis functions with which to construct the matrices <span class="math inline">\(\{\boldsymbol{\Phi}_t: t = 1,\dots,T\}\)</span>. In <strong>INLA</strong>, the basis functions used are typically “tent” (finite element) functions constructed over a triangulation of the domain. To establish a “boundary” for the domain, we can use the function <code>inla.nonconvex.hull</code>, as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>coords <span class="ot">&lt;-</span> <span class="fu">unique</span>(MOcarolinawren_long[<span class="fu">c</span>(<span class="st">"loc.ID"</span>, <span class="st">"lon"</span>, <span class="st">"lat"</span>)])</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>boundary <span class="ot">&lt;-</span> <span class="fu">inla.nonconvex.hull</span>(<span class="fu">as.matrix</span>(coords[, <span class="dv">2</span><span class="sc">:</span><span class="dv">3</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The triangulation of the domain is then carried out using the function <code>inla.mesh.2d</code>. This function takes several arguments (see its help file for details). Two of the most important arguments are <code>max.edge</code> and <code>cutoff</code>. When the former is supplied with a vector of length <span class="math inline">\(2\)</span>, the first element is the maximum edge length in the interior of the domain, and the second element is the maximum edge length in the exterior of the domain (obtained from a small buffer that is automatically created to reduce boundary effects). The second argument, <code>cutoff</code>, establishes the minimum edge length. Below we choose a maximum edge length of 0.8 in the domain interior. This is probably too large for the problem at hand, but reducing this considerably increases the computational burden when fitting the model.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>MOmesh <span class="ot">&lt;-</span> <span class="fu">inla.mesh.2d</span>(<span class="at">boundary =</span> boundary,</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>                       <span class="at">max.edge =</span> <span class="fu">c</span>(<span class="fl">0.8</span>, <span class="fl">1.2</span>), <span class="co"># max. edge length</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>                       <span class="at">cutoff =</span> <span class="fl">0.1</span>)           <span class="co"># min. edge length</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The mesh and the data locations are plotted using the following commands.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(MOmesh, <span class="at">asp =</span> <span class="dv">1</span>, <span class="at">main =</span> <span class="st">""</span>)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="fu">lines</span>(coords[<span class="fu">c</span>(<span class="st">"lon"</span>, <span class="st">"lat"</span>)], <span class="at">col =</span> <span class="st">"red"</span>, <span class="at">type =</span> <span class="st">"p"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>These are shown in <a href="#fig-mesh" class="quarto-xref">Figure&nbsp;<span>4.17</span></a>. Note that the triangulation is irregular and contains an extension with triangles that are larger than those in the interior of the domain.</p>
<div id="fig-mesh" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-mesh-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/mesh.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mesh-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.17: Triangulation for the Carolina wren data locations over which the “tent” functions are constructed (black), and the observation locations (red circles) are superimposed. The blue line denotes the interior non-convex domain of interest that includes all the data points.
</figcaption>
</figure>
</div>
<p>As in the standard Gaussian case, the modeling effort lies in establishing the covariance matrix of <span class="math inline">\(\boldsymbol{\alpha}\equiv (\boldsymbol{\alpha}_1',\dots,\boldsymbol{\alpha}_T')'\)</span>. When using <strong>INLA</strong>, typically the covariance matrix of <span class="math inline">\(\boldsymbol{\alpha}\)</span> is chosen to be separable and of the form <span class="math inline">\(\boldsymbol{\Sigma}_t(\rho) \otimes \boldsymbol{\Sigma}_s(\tau,\kappa,\nu)\)</span> in such a way that its inverse (i.e., the precision matrix) is sparse. The matrix <span class="math inline">\(\boldsymbol{\Sigma}_t\)</span> is constructed assuming an AR(1) process, and thus it is parameterized using a single AR parameter, <span class="math inline">\(\rho\)</span>. This parameter dictates the correlation of <span class="math inline">\(\boldsymbol{\alpha}\)</span> across time; the closer <span class="math inline">\(\rho\)</span> is to 1, the higher the temporal correlation. The matrix <span class="math inline">\(\boldsymbol{\Sigma}_s\)</span> is parameterized using three parameters, and it reflects the spatial covariance required such that the reconstructed field is, approximately, a solution to the stochastic partial differential equation (SPDE)</p>
<p><span class="math display">\[
(\kappa^2 - \Delta)^{\alpha/2}(\tau Y(\cdot)) = \epsilon(\cdot),
\]</span></p>
<p>where <span class="math inline">\(\Delta\)</span> is the Laplacian, <span class="math inline">\(\epsilon(\cdot)\)</span> is a white-noise process, and <span class="math inline">\(\tau\)</span> controls the variance. The resulting field has a Matérn covariance function. The parameter <span class="math inline">\(\kappa\)</span> is a scaling parameter that translates to a “practical” spatial correlation length (i.e., the spatial separation at which the correlation is 0.1) <span class="math inline">\(l = (\sqrt{8\nu})/\kappa\)</span>, while <span class="math inline">\(\alpha = \nu + d/2\)</span> is a smoothness parameter and <span class="math inline">\(d\)</span> is the spatial dimension. Here we fix <span class="math inline">\(\nu = 1\)</span> (<span class="math inline">\(\alpha = 2\)</span>); this parameter is notoriously difficult to estimate and frequently set using cross-validation. Note that there are other “practical” length scales used to characterize the range of a correlation function (e.g., “effective range” when the correlation is 0.05); our choice here is motivated by the <strong>INLA</strong> package that readily provides a marginal distribution over the parameter <span class="math inline">\(l\)</span> as defined here.</p>
<p>The SPDE can be constructed on the mesh using the function <code>inla.spde2.pcmatern</code>. The <code>pc</code> in <code>pcmatern</code> is short for “penalized complexity,” and it is used to refer to prior distributions over the hyperparameters that are both interpretable and that have interesting theoretical properties <span class="citation" data-cites="simpson2017penalising">Simpson et al. (<a href="references.html#ref-simpson2017penalising" role="doc-biblioref">2017</a>)</span>. We define prior distributions below over the range parameter <span class="math inline">\(l\)</span> such that <span class="math inline">\(P(l &lt; 1) = 0.01\)</span>, and over the marginal standard deviation such that <span class="math inline">\(P(\sigma &gt; 4) = 0.01\)</span>. We elicited these distributions by looking at the count data – it is highly unlikely that the spatial correlation length is less than 1 degree and that the expected counts are of the order of 50 or more (we will use a log link, and <span class="math inline">\(e^4 \approx 55\)</span>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>spde <span class="ot">&lt;-</span> <span class="fu">inla.spde2.pcmatern</span>(<span class="at">mesh =</span> MOmesh,</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>                            <span class="at">alpha =</span> <span class="dv">2</span>,</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>                            <span class="at">prior.range =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="fl">0.01</span>),</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>                            <span class="at">prior.sigma =</span> <span class="fu">c</span>(<span class="dv">4</span>, <span class="fl">0.01</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With the discretization shown in <a href="#fig-mesh" class="quarto-xref">Figure&nbsp;<span>4.17</span></a>, <span class="math inline">\(\alpha_{t,i}\)</span> can be viewed as the weight of the <span class="math inline">\(i\)</span>th basis function at time <span class="math inline">\(t\)</span>. The observation matrix <span class="math inline">\(\boldsymbol{\Phi}_t\)</span> then maps the observations to the finite-element space at time <span class="math inline">\(t\)</span>; if the observation lies exactly on a vertex, then the associated row in <span class="math inline">\(\boldsymbol{\Phi}_t\)</span> will be 0 everywhere except for a 1 in the column corresponding to the vertex. Otherwise, the row has three non-zero elements, with each representing the proportion being assigned to each vertex. For point predictions or areal averages, all rows in <span class="math inline">\(\boldsymbol{\Phi}_t\)</span> sum to 1. Finally, for this example, we choose each element in <span class="math inline">\(\mathbf{X}_t\)</span> to be equal to 1. The coefficient <span class="math inline">\(\beta_0\)</span> is then the intercept.</p>
<p>The package <strong>INLA</strong> requires space and time to be “blocked up” with an ordering of the variables in which space runs faster than time (i.e., the first few variables are spatial nodes at the first time point, the next few are at the second time point, and so on). Hence we have the block-matrix structure</p>
<p><span id="eq-INLA-blocking"><span class="math display">\[
\log\left(\begin{bmatrix} \mathbf{Y}_1 \\ \vdots \\ \mathbf{Y}_T \end{bmatrix}\right) = \begin{bmatrix} \mathbf{X}_1 \\ \vdots \\ \mathbf{X}_T \end{bmatrix}\boldsymbol{\beta}+ \begin{bmatrix} \boldsymbol{\Phi}_1 &amp; \mathbf{0}&amp; \dots \\ \vdots &amp; \ddots &amp; \vdots \\ \mathbf{0}&amp; \dots &amp; \boldsymbol{\Phi}_T \end{bmatrix} \begin{bmatrix} \boldsymbol{\alpha}_1 \\ \vdots \\ \boldsymbol{\alpha}_T \end{bmatrix},
\tag{4.43}\]</span></span></p>
<p>where <span class="math inline">\(\log(\cdot)\)</span> corresponds to a vector of elementwise logarithms. This can be further simplified to</p>
<p><span id="eq-INLA-blocking2"><span class="math display">\[
\log(\mathbf{Y}) = \mathbf{X}\boldsymbol{\beta}+ \boldsymbol{\Phi}\boldsymbol{\alpha},
\tag{4.44}\]</span></span></p>
<p>where <span class="math inline">\(\mathbf{Y}= (\mathbf{Y}_1',\dots,\mathbf{Y}_T')'\)</span>, <span class="math inline">\(\mathbf{X}= (\mathbf{X}_1',\dots,\mathbf{X}_T')'\)</span>, <span class="math inline">\(\boldsymbol{\Phi}\equiv \textrm{bdiag}(\{\boldsymbol{\Phi}_t : t = 1,\dots,T\})\)</span>, <span class="math inline">\(\textrm{bdiag}(\cdot)\)</span> constructs a block-diagonal matrix from its arguments, and <span class="math inline">\(\boldsymbol{\alpha}\equiv (\boldsymbol{\alpha}_1',\dots,\boldsymbol{\alpha}_T')'\)</span>.</p>
<p>A space-time index needs to be constructed for this representation. This index is a double index that identifies both the spatial location and the associated time point. In Lab 2.2 we saw how the function <code>expand.grid</code> can be used to generate such indices from a set of spatial locations and time points. In <strong>INLA</strong>, we instead use the function <code>inla.spde.make.index</code>. It takes as arguments the index name, the number of spatial points in the mesh, and the number of time points.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>n_years <span class="ot">&lt;-</span> <span class="fu">length</span>(<span class="fu">unique</span>(MOcarolinawren_long<span class="sc">$</span>t))</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>n_spatial <span class="ot">&lt;-</span> MOmesh<span class="sc">$</span>n</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>s_index <span class="ot">&lt;-</span> <span class="fu">inla.spde.make.index</span>(<span class="at">name =</span> <span class="st">"spatial.field"</span>,</span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>                                <span class="at">n.spde =</span> n_spatial,</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>                                <span class="at">n.group =</span> n_years)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The list <code>s_index</code> contains two important items, the <code>spatial.field</code> index, which runs from 1 to <code>n_spatial</code> for <code>n_years</code> times, and <code>spatial.field.group</code>, which runs from 1 to <code>n_years</code>, with each element replicated <code>n_spatial</code> times. Note how this is similar to what one would obtain from <code>expand.grid</code>.</p>
<p>The matrix <span class="math inline">\(\boldsymbol{\Phi}\)</span> in <a href="#eq-INLA-blocking2" class="quarto-xref">Equation&nbsp;<span>4.44</span></a> is found using the <code>inla.spde.make.A</code> function. This function takes as arguments the mesh, the measurement locations <code>loc</code>, the measurement group (in our case the year of observation) and the number of groups.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>coords.allyear <span class="ot">&lt;-</span> MOcarolinawren_long[<span class="fu">c</span>(<span class="st">"lon"</span>, <span class="st">"lat"</span>)] <span class="sc">%&gt;%</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">as.matrix</span>()</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>PHI <span class="ot">&lt;-</span> <span class="fu">inla.spde.make.A</span>(<span class="at">mesh =</span> MOmesh,</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>                        <span class="at">loc =</span> coords.allyear,</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>                        <span class="at">group =</span> MOcarolinawren_long<span class="sc">$</span>t,</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>                        <span class="at">n.group =</span> n_years)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Note that</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dim</span>(PHI)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1575 5439</code></pre>
</div>
</div>
<p>This is a matrix equal in dimension to (number of observations) <span class="math inline">\(\times\)</span> (number of indices) of our basis functions in space and time.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="fu">nrow</span>(MOcarolinawren_long)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1575</code></pre>
</div>
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span>(s_index<span class="sc">$</span>spatial.field)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 5439</code></pre>
</div>
</div>
<p>The latent Gaussian model is constructed in <strong>INLA</strong> through a <em>stack</em>. Stacks are handy as they allow one to define data, effects, and observation matrices in groups (e.g., one accounting for the measurement locations and another accounting for the prediction locations), which can then be stacked together into one bigger stack. In order to build a stack we need to further block up <a href="#eq-INLA-blocking" class="quarto-xref">Equation&nbsp;<span>4.43</span></a> into a representation amenable to the <code>inla</code> function (called later on) as follows:</p>
<p><span class="math display">\[
\log(\mathbf{Y}) = \boldsymbol{\Pi}\boldsymbol{\gamma},
\]</span></p>
<p>where <span class="math inline">\(\boldsymbol{\Pi}= (\boldsymbol{\Phi}, \mathbf{1})\)</span> and <span class="math inline">\(\boldsymbol{\gamma}= (\boldsymbol{\alpha}',\beta_0)'\)</span>.</p>
<p>A stack containing the data and covariates at the measurement locations is constructed by supplying the data (argument <code>data</code>), the matrix <span class="math inline">\(\boldsymbol{\Pi}\)</span> (argument <code>A</code>), and information on the vector <span class="math inline">\(\boldsymbol{\gamma}\)</span>. The stack is then tagged with the label <code>"est"</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="do">## First stack: Estimation</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>n_data <span class="ot">&lt;-</span> <span class="fu">nrow</span>(MOcarolinawren_long)</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>stack_est <span class="ot">&lt;-</span> <span class="fu">inla.stack</span>(</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>                 <span class="at">data =</span> <span class="fu">list</span>(<span class="at">cnt =</span> MOcarolinawren_long<span class="sc">$</span>cnt),</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>                 <span class="at">A =</span> <span class="fu">list</span>(PHI, <span class="dv">1</span>),</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>                 <span class="at">effects =</span> <span class="fu">list</span>(s_index,</span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>                                <span class="fu">list</span>(<span class="at">Intercept =</span> <span class="fu">rep</span>(<span class="dv">1</span>, n_data))),</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>                 <span class="at">tag =</span> <span class="st">"est"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We next construct a stack containing the matrices and vectors defining the model at the prediction locations. In this case, we choose the triangulation vertices as the prediction locations; then <span class="math inline">\(\boldsymbol{\Phi}\)</span> is simply the identity matrix, and <span class="math inline">\(\mathbf{X}\)</span> is a vector of ones. We store the information on the prediction locations in <code>df_pred</code> and that for <span class="math inline">\(\boldsymbol{\Phi}\)</span> in <code>PHI_pred</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>df_pred <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">lon =</span> <span class="fu">rep</span>(MOmesh<span class="sc">$</span>loc[,<span class="dv">1</span>], n_years),</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">lat =</span> <span class="fu">rep</span>(MOmesh<span class="sc">$</span>loc[,<span class="dv">2</span>], n_years),</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>                      <span class="at">t =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>n_years, <span class="at">each =</span> MOmesh<span class="sc">$</span>n))</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>n_pred <span class="ot">&lt;-</span> <span class="fu">nrow</span>(df_pred)</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>PHI_pred <span class="ot">&lt;-</span> <span class="fu">Diagonal</span>(<span class="at">n =</span> n_pred)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The prediction stack is constructed in a very similar way to the estimation stack, but this time we set the data values to <code>NA</code> to indicate that prediction should be carried out at these locations.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="do">## Second stack: Prediction</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>stack_pred <span class="ot">&lt;-</span> <span class="fu">inla.stack</span>(</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>                 <span class="at">data =</span> <span class="fu">list</span>(<span class="at">cnt =</span> <span class="cn">NA</span>),</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>                 <span class="at">A =</span> <span class="fu">list</span>(PHI_pred, <span class="dv">1</span>),</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>                 <span class="at">effects =</span> <span class="fu">list</span>(s_index,</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>                                <span class="fu">list</span>(<span class="at">Intercept =</span> <span class="fu">rep</span>(<span class="dv">1</span>, n_pred))),</span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>                 <span class="at">tag =</span> <span class="st">"pred"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The estimation stack and prediction stack are combined using the <code>inla.stack</code> function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>stack <span class="ot">&lt;-</span> <span class="fu">inla.stack</span>(stack_est, stack_pred)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>All <code>inla.stack</code> does is block-concatenate the matrices and vectors in the individual stacks. Denote the log-expected counts at the prediction locations as <span class="math inline">\(\mathbf{Y}^*\)</span>, the covariates as <span class="math inline">\(\mathbf{X}^*\)</span>, and the basis functions evaluated at the prediction locations as <span class="math inline">\(\boldsymbol{\Phi}^*\)</span>. Then</p>
<p><span class="math display">\[
\begin{bmatrix} \log(\mathbf{Y})  \\ \log(\mathbf{Y}^*) \end{bmatrix} = \begin{bmatrix} \boldsymbol{\Pi}\\ \boldsymbol{\Pi}^* \end{bmatrix}   \boldsymbol{\gamma},
\]</span></p>
<p>recalling that <span class="math inline">\(\boldsymbol{\gamma}= (\boldsymbol{\alpha}',\beta_0)'\)</span>. Note that, internally, some columns of <span class="math inline">\(\boldsymbol{\Pi}\)</span> and <span class="math inline">\(\boldsymbol{\Pi}^*\)</span> corresponding to unobserved states are not stored. For example <span class="math inline">\(\boldsymbol{\Phi}\)</span>, internally, has dimension</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="fu">dim</span>(stack_est<span class="sc">$</span>A)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1575 1702</code></pre>
</div>
</div>
<p>The number of rows corresponds to the number of data points, while the number of columns corresponds to the number of observed states (<code>sum(colSums(PHI) &gt; 0)</code>) plus one for the intercept term.</p>
<p>All that remains before fitting the model is for us to define the formula, which is a combination of a standard <code>R</code> formula for the fixed effects and an <strong>INLA</strong> formula for the spatio-temporal residual component. For the latter, we need to specify the name of the index we created as the first argument (in this case <code>spatial.field</code>), the model (in this case <code>spde</code>), the name of the grouping/time index (in this case <code>spatial.field.group</code>) and, finally, the model to be constructed across groups (in this case an AR(1) model). The latter modeling choice implies that <span class="math inline">\(E(\boldsymbol{\alpha}_{t+1}\mid \boldsymbol{\alpha}_t) = \rho \boldsymbol{\alpha}_t\)</span>, <span class="math inline">\(t = 1,\dots,T-1\)</span>. Our choice for the prior on the AR(1) coefficient, <span class="math inline">\(\rho\)</span>, is a penalized complexity prior, such that <span class="math inline">\(P(\rho &gt; 0) = 0.9\)</span> to reflect the prior belief that we highly doubt a negative temporal correlation.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="do">## PC prior on rho</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>rho_hyper <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">theta=</span><span class="fu">list</span>(<span class="at">prior =</span> <span class="st">'pccor1'</span>,</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>                             <span class="at">param =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.9</span>)))</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a><span class="do">## Formula</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>formula <span class="ot">&lt;-</span> cnt <span class="sc">~</span> <span class="sc">-</span><span class="dv">1</span> <span class="sc">+</span> Intercept <span class="sc">+</span></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">f</span>(spatial.field,</span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>                   <span class="at">model =</span> spde,</span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>                   <span class="at">group =</span> spatial.field.group,</span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>                   <span class="at">control.group =</span> <span class="fu">list</span>(<span class="at">model =</span> <span class="st">"ar1"</span>,</span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>                                        <span class="at">hyper =</span> rho_hyper))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we have everything in place to run the main function for fitting the model, <code>inla</code>. This needs the data from the stack (extracted through <code>inla.stack.data</code>) and the exponential family (in this case negative-binomial). The remaining options indicate the desired outputs. In the command given below, we instruct <code>inla</code> to fit the model and also to compute the predictions at the required locations.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>output <span class="ot">&lt;-</span> <span class="fu">inla</span>(formula,</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>               <span class="at">data =</span> <span class="fu">inla.stack.data</span>(stack, <span class="at">spde =</span> spde),</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>               <span class="at">family =</span> <span class="st">"nbinomial"</span>,</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>               <span class="at">control.predictor =</span> <span class="fu">list</span>(<span class="at">A =</span> <span class="fu">inla.stack.A</span>(stack),</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>                                        <span class="at">compute =</span> <span class="cn">TRUE</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This operation takes a long time. In <strong>STRbook</strong> we provide the important components of this object, which can be loaded through</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"INLA_output"</span>, <span class="at">package =</span> <span class="st">"STRbook"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>INLA provides approximate marginal posterior distributions for each <span class="math inline">\(\boldsymbol{\alpha}_t\)</span> in <span class="math inline">\(\boldsymbol{\alpha}\)</span> and <span class="math inline">\(\{\boldsymbol{\beta},\rho,\tau\,\kappa\}\)</span>. The returned object, <code>output</code>, contains all the results as well as summaries of these results for quick analysis. From the posterior distributions over the precision parameter <span class="math inline">\(\tau\)</span> and scale parameter <span class="math inline">\(\kappa\)</span>, we can readily obtain marginal posterior distributions over the more interpretable variance parameter <span class="math inline">\(\sigma^2\)</span> and practical range parameter <span class="math inline">\(l\)</span>. Posterior distributions of some of the parameters are shown in <a href="#fig-inla-pars" class="quarto-xref">Figure&nbsp;<span>4.18</span></a>, where we can see that the AR(1) coefficient of the latent field, <span class="math inline">\(\rho\)</span>, is large (most of the mass of the posterior distribution is close to <span class="math inline">\(1\)</span>), and the practical range parameter, <span class="math inline">\(l\)</span>, is of the order of 2 degrees (<span class="math inline">\(\approx 200\)</span>,km). The posterior distribution of the marginal variance of the latent field is largest between 2 and 4. These values suggest that there are strong spatial and temporal dependencies in the data. We give code below for plotting the posterior marginal distributions shown in <a href="#fig-inla-pars" class="quarto-xref">Figure&nbsp;<span>4.18</span></a>.</p>
<div id="fig-inla-pars" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-inla-pars-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/INLA_posteriors.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-inla-pars-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.18: Marginal posterior distributions of <span class="math inline">\(\beta_0\)</span>, the temporal correlation <span class="math inline">\(\rho\)</span>, the variance <span class="math inline">\(\sigma^2\)</span>, and the range parameter <span class="math inline">\(l\)</span>.
</figcaption>
</figure>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>output.field <span class="ot">&lt;-</span> <span class="fu">inla.spde2.result</span>(<span class="at">inla =</span> output,</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">name =</span> <span class="st">"spatial.field"</span>,</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">spde =</span> spde,</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">do.transf =</span> <span class="cn">TRUE</span>)</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a><span class="do">## plot p(beta0 | Z)</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(output<span class="sc">$</span>marginals.fix<span class="sc">$</span>Intercept,</span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>     <span class="at">type=</span><span class="st">'l'</span>,</span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab=</span><span class="fu">expression</span>(beta[<span class="dv">0</span>]),</span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="fu">expression</span>(<span class="fu">p</span>(beta[<span class="dv">0</span>]<span class="sc">*</span><span class="st">"|"</span><span class="sc">*</span>Z)))</span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a><span class="do">## plot p(rho | Z)</span></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(output<span class="sc">$</span>marginals.hyperpar<span class="sc">$</span><span class="st">`</span><span class="at">GroupRho for spatial.field</span><span class="st">`</span>,</span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>     <span class="at">type=</span><span class="st">'l'</span>,</span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab=</span><span class="fu">expression</span>(rho),</span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="fu">expression</span>(<span class="fu">p</span>(rho<span class="sc">*</span><span class="st">"|"</span><span class="sc">*</span>Z)))</span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a><span class="do">## plot p(sigma^2 | Z)</span></span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(output.field<span class="sc">$</span>marginals.variance.nominal[[<span class="dv">1</span>]],</span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a>     <span class="at">type=</span><span class="st">'l'</span>,</span>
<span id="cb88-20"><a href="#cb88-20" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab=</span><span class="fu">expression</span>(sigma<span class="sc">^</span><span class="dv">2</span>),</span>
<span id="cb88-21"><a href="#cb88-21" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="fu">expression</span>(<span class="fu">p</span>(sigma<span class="sc">^</span><span class="dv">2</span><span class="sc">*</span><span class="st">"|"</span><span class="sc">*</span>Z)))</span>
<span id="cb88-22"><a href="#cb88-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-23"><a href="#cb88-23" aria-hidden="true" tabindex="-1"></a><span class="do">## plot p(range | Z)</span></span>
<span id="cb88-24"><a href="#cb88-24" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(output.field<span class="sc">$</span>marginals.range.nominal[[<span class="dv">1</span>]],</span>
<span id="cb88-25"><a href="#cb88-25" aria-hidden="true" tabindex="-1"></a>     <span class="at">type=</span><span class="st">'l'</span>,</span>
<span id="cb88-26"><a href="#cb88-26" aria-hidden="true" tabindex="-1"></a>     <span class="at">xlab=</span><span class="fu">expression</span>(l),</span>
<span id="cb88-27"><a href="#cb88-27" aria-hidden="true" tabindex="-1"></a>     <span class="at">ylab=</span><span class="fu">expression</span>(<span class="fu">p</span>(l<span class="sc">*</span><span class="st">"|"</span><span class="sc">*</span>Z)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We provide the prediction (posterior mean) and prediction standard error (posterior standard deviation) for <span class="math inline">\(\log(Y(\cdot))\)</span> in Figures <a href="#fig-inla-pred" class="quarto-xref">Figure&nbsp;<span>4.19</span></a> and <a href="#fig-inla-se" class="quarto-xref">Figure&nbsp;<span>4.20</span></a>, respectively. These figures were generated by linearly interpolating the posterior mean and posterior standard deviation of <span class="math inline">\(\log(\mathbf{Y}^*)\)</span> on a fine grid. Note how a high observed count at a certain location in one year affects the predictions at the same location in neighboring years, even if unobserved.</p>
<div id="fig-inla-pred" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-inla-pred-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/INLA_predictions.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-inla-pred-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.19: Posterior mean of <span class="math inline">\(\log(Y(\cdot))\)</span> on a grid for <span class="math inline">\(t=1\)</span> (the year 1994) to <span class="math inline">\(t=21\)</span> (the year 2014), based on a negative-binomial data model using the package <strong>INLA</strong>. The log of the observed count is shown in circles using the same color scale.
</figcaption>
</figure>
</div>
<div id="fig-inla-se" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-inla-se-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/Chapter_4/INLA_sd.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-inla-se-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4.20: Posterior standard deviation (i.e., prediction standard error) of <span class="math inline">\(\log(Y(\cdot))\)</span> on a grid for <span class="math inline">\(t=1\)</span> (the year 1994) to <span class="math inline">\(t=21\)</span> (the year 2014), based on a negative-binomial data model using the package <strong>INLA</strong>.
</figcaption>
</figure>
</div>
<p>Plotting spatial fields, such as those shown in Figures <a href="#fig-inla-pred" class="quarto-xref">Figure&nbsp;<span>4.19</span></a> and <a href="#fig-inla-se" class="quarto-xref">Figure&nbsp;<span>4.20</span></a>, from the <strong>INLA</strong> output can be a bit involved since each prediction and prediction standard error of <span class="math inline">\(\boldsymbol{\alpha}_t\)</span> for each <span class="math inline">\(t\)</span> needs to be projected spatially. First, we extract the predictions and prediction standard errors of <span class="math inline">\(\boldsymbol{\alpha}= (\boldsymbol{\alpha}_1',\dots,\boldsymbol{\alpha}_T')'\)</span> as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>index_pred <span class="ot">&lt;-</span> <span class="fu">inla.stack.index</span>(stack, <span class="st">"pred"</span>)<span class="sc">$</span>data</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>lp_mean <span class="ot">&lt;-</span> output<span class="sc">$</span>summary.fitted.values<span class="sc">$</span>mean[index_pred]</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>lp_sd <span class="ot">&lt;-</span> output<span class="sc">$</span>summary.fitted.values<span class="sc">$</span>sd[index_pred]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, we need to create a spatial grid upon which we map the predictions and their associated prediction standard errors. This can be constructed using the function <code>expand.grid</code>. We construct an 80 <span class="math inline">\(\times\)</span> 80 grid below.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>grid_locs <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>                 <span class="at">lon =</span> <span class="fu">seq</span>(<span class="fu">min</span>(MOcarolinawren_long<span class="sc">$</span>lon) <span class="sc">-</span> <span class="fl">0.2</span>,</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>                           <span class="fu">max</span>(MOcarolinawren_long<span class="sc">$</span>lon) <span class="sc">+</span> <span class="fl">0.2</span>,</span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>                           <span class="at">length.out =</span> <span class="dv">80</span>),</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>                 <span class="at">lat =</span> <span class="fu">seq</span>(<span class="fu">min</span>(MOcarolinawren_long<span class="sc">$</span>lat) <span class="sc">-</span> <span class="fl">0.2</span>,</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>                           <span class="fu">max</span>(MOcarolinawren_long<span class="sc">$</span>lat) <span class="sc">+</span> <span class="fl">0.2</span>,</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>                           <span class="at">length.out =</span> <span class="dv">80</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The function <code>inla.mesh.projector</code> provides all the information required, based on the created spatial grid, to carry out the mapping.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>proj.grid <span class="ot">&lt;-</span> <span class="fu">inla.mesh.projector</span>(MOmesh,</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>                    <span class="at">xlim =</span> <span class="fu">c</span>(<span class="fu">min</span>(MOcarolinawren_long<span class="sc">$</span>lon) <span class="sc">-</span> <span class="fl">0.2</span>,</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>                             <span class="fu">max</span>(MOcarolinawren_long<span class="sc">$</span>lon) <span class="sc">+</span> <span class="fl">0.2</span>),</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>                    <span class="at">ylim =</span> <span class="fu">c</span>(<span class="fu">min</span>(MOcarolinawren_long<span class="sc">$</span>lat) <span class="sc">-</span> <span class="fl">0.2</span>,</span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>                             <span class="fu">max</span>(MOcarolinawren_long<span class="sc">$</span>lat) <span class="sc">+</span> <span class="fl">0.2</span>),</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>                    <span class="at">dims =</span> <span class="fu">c</span>(<span class="dv">80</span>, <span class="dv">80</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we have everything in place to map each <span class="math inline">\(\boldsymbol{\alpha}_t\)</span> on our spatial grid. We iterate through <span class="math inline">\(t\)</span>, and for each <span class="math inline">\(t = 1,\dots,T\)</span> we map both the prediction and prediction standard errors of <span class="math inline">\(\boldsymbol{\alpha}_t\)</span> on the spatial grid as follows.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>pred <span class="ot">&lt;-</span> sd <span class="ot">&lt;-</span>  <span class="cn">NULL</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n_years) {</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>    ii <span class="ot">&lt;-</span> (i<span class="dv">-1</span>)<span class="sc">*</span>MOmesh<span class="sc">$</span>n <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>    jj <span class="ot">&lt;-</span> i<span class="sc">*</span>MOmesh<span class="sc">$</span>n</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>    pred[[i]] <span class="ot">&lt;-</span> <span class="fu">cbind</span>(grid_locs,</span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>                       <span class="at">z =</span> <span class="fu">c</span>(<span class="fu">inla.mesh.project</span>(proj.grid,</span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>                                             lp_mean[ii<span class="sc">:</span>jj])),</span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a>                       <span class="at">t =</span> i)</span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a>    sd[[i]] <span class="ot">&lt;-</span> <span class="fu">cbind</span>(grid_locs,</span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a>                     <span class="at">z =</span> <span class="fu">c</span>(<span class="fu">inla.mesh.project</span>(proj.grid,</span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a>                                             lp_sd[ii<span class="sc">:</span>jj])),</span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a>                     <span class="at">t =</span> i)</span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The last thing we need to do is compile all the data (which are in lists) into one data frame for plotting with <strong>ggplot2</strong>. We concatenate all the list elements rowwise and remove those elements that are <code>NA</code> because they fall outside of the support of any basis function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>pred <span class="ot">&lt;-</span> <span class="fu">do.call</span>(<span class="st">"rbind"</span>, pred) <span class="sc">%&gt;%</span> <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(z))</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>sd <span class="ot">&lt;-</span> <span class="fu">do.call</span>(<span class="st">"rbind"</span>, sd) <span class="sc">%&gt;%</span> <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(z))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The data frames <code>pred</code> and <code>sd</code> now contain the spatio-temporal predictions and spatio-temporal prediction standard errors. Plotting of these fields using <strong>ggplot2</strong> is left as an exercise for the reader.</p>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-baddeley2015spatial" class="csl-entry" role="listitem">
Baddeley, Adrian, Ege Rubak, and Rolf Turner. 2015. <em>Spatial Point Patterns: Methodology and Applications with r</em>. Boca Raton, FL: Chapman &amp; Hall/CRC.
</div>
<div id="ref-bakar2015sptimer" class="csl-entry" role="listitem">
Bakar, Khandoker Shuvo, and Sujit K Sahu. 2015. <span>“spTimer: Spatio-Temporal Bayesian Modelling Using r.”</span> <em>Journal of Statistical Software</em> 63 (15): 1–32.
</div>
<div id="ref-banerjee2015hierarchical" class="csl-entry" role="listitem">
Banerjee, S., B. P. Carlin, and A. E. Gelfand. 2015. <em>Hierarchical Modeling and Analysis for Spatial Data</em>. Second. Boca Raton, FL: Chapman &amp; Hall/CRC.
</div>
<div id="ref-blangiardo2015spatial" class="csl-entry" role="listitem">
Blangiardo, Marta, and Michela Cameletti. 2015. <em>Spatial and Spatio-Temporal Bayesian Models with <span>R-INLA</span></em>. Hoboken, NJ: John Wiley &amp; Sons.
</div>
<div id="ref-carlin2010bayes" class="csl-entry" role="listitem">
Carlin, Bradley P, and Thomas A Louis. 2010. <em>Bayes and Empirical Bayes Methods for Data Analysis</em>. Boca Raton, FL: Chapman &amp; Hall/CRC.
</div>
<div id="ref-christakos2017spatiotemporal" class="csl-entry" role="listitem">
Christakos, George. 2017. <em>Spatiotemporal Random Fields: Theory and Applications</em>. Second. Amsterdam: Elsevier.
</div>
<div id="ref-cressie1999classes" class="csl-entry" role="listitem">
Cressie, Noel, and Hsin-Cheng Huang. 1999. <span>“Classes of Nonseparable, Spatio-Temporal Stationary Covariance Functions.”</span> <em>Journal of the American Statistical Association</em> 94 (448): 1330–39.
</div>
<div id="ref-cressie2010fixed" class="csl-entry" role="listitem">
Cressie, Noel, Tao Shi, and Emily L Kang. 2010. <span>“Fixed Rank Filtering for Spatio-Temporal Data.”</span> <em>Journal of Computational and Graphical Statistics</em> 19 (3): 724–45.
</div>
<div id="ref-cressie2011statistics" class="csl-entry" role="listitem">
Cressie, N., and C. K. Wikle. 2011. <em>Statistics for Spatio-Temporal Data</em>. Hoboken, NJ: John Wiley &amp; Sons.
</div>
<div id="ref-crujeiras2010nonparametric" class="csl-entry" role="listitem">
Crujeiras, Rosa M, Rubén Fernández-Casal, and Wenceslao González-Manteiga. 2010. <span>“Nonparametric Test for Separability of Spatio-Temporal Processes.”</span> <em>Environmetrics</em> 21 (3-4): 382–99.
</div>
<div id="ref-diggle2007springer" class="csl-entry" role="listitem">
Diggle, P J, and P J Ribeiro Jr. 2007. <em>Model-Based Geostatistics</em>. New York: Springer.
</div>
<div id="ref-diggle2013statistical" class="csl-entry" role="listitem">
Diggle, Peter J. 2013. <em>Statistical Analysis of Spatial and Spatio-Temporal Point Patterns</em>. Boca Raton, FL: Chapman &amp; Hall/CRC.
</div>
<div id="ref-finley2007spbayes" class="csl-entry" role="listitem">
Finley, Andrew O, Sudipto Banerjee, and Bradley P Carlin. 2007. <span>“spBayes: An r Package for Univariate and Multivariate Hierarchical Point-Referenced Spatial Models.”</span> <em>Journal of Statistical Software</em> 19 (4): 1–24.
</div>
<div id="ref-gelman2013bayesian" class="csl-entry" role="listitem">
Gelman, Andrew, John B Carlin, Hal S Stern, David B Dunson, Aki Vehtari, and Donald B Rubin. 2014. <em>Bayesian Data Analysis</em>. 3rd ed. Boca Raton, FL: Chapman &amp; Hall/CRC.
</div>
<div id="ref-hanks2015restricted" class="csl-entry" role="listitem">
Hanks, Ephraim M, Erin M Schliep, Mevin B Hooten, and Jennifer A Hoeting. 2015. <span>“Restricted Spatial Regression in Practice: Geostatistical Models, Confounding, and Robustness Under Model Misspecification.”</span> <em>Environmetrics</em> 26 (4): 243–54.
</div>
<div id="ref-hodges2010adding" class="csl-entry" role="listitem">
Hodges, James S, and Brian J Reich. 2010. <span>“Adding Spatially-Correlated Errors Can Mess up the Fixed Effect You Love.”</span> <em>American Statistician</em> 64 (4): 325–34.
</div>
<div id="ref-hughes2013dimension" class="csl-entry" role="listitem">
Hughes, John, and Murali Haran. 2013. <span>“Dimension Reduction and Alleviation of Confounding for Spatial Generalized Linear Mixed Models.”</span> <em>Journal of the Royal Statistical Society, Series B</em> 75 (1): 139–59.
</div>
<div id="ref-johnson1992applied" class="csl-entry" role="listitem">
Johnson, Richard A., and Dean W. Wichern. 1992. <em>Applied Multivariate Statistical Analysis</em>. <em>Prentice Hall</em>. 3rd ed. Englewood Cliffs, NJ: Prentice Hall.
</div>
<div id="ref-kendall1969advanced" class="csl-entry" role="listitem">
Kendall, M. G., and A. Stuart. 1969. <em>The Advanced Theory of Statistics</em>. 3rd ed. Vol. 1. New York: Hafner.
</div>
<div id="ref-krainski2018" class="csl-entry" role="listitem">
Krainski, E. T., V. Gómez-Rubio, H. Bakka, A. Lenzi, D. Castro-Camilo, D. Simpson, F. Lindgren, and H. Rue. 2019. <em>Advanced Spatial Modeling with Stochastic Partial Differential Equations Using r and INLA</em>. Boca Raton, FL: Chapman; Hall/CRC.
</div>
<div id="ref-laird1982random" class="csl-entry" role="listitem">
Laird, Nan M, and James H Ware. 1982. <span>“Random-Effects Models for Longitudinal Data.”</span> <em>Biometrics</em>, 963–74.
</div>
<div id="ref-le2006statistical" class="csl-entry" role="listitem">
Le, Nhu D, and James V Zidek. 2006. <em>Statistical Analysis of Environmental Space-Time Processes</em>. New York: Springer.
</div>
<div id="ref-R_INLA" class="csl-entry" role="listitem">
Lindgren, Finn, and Håvard Rue. 2015. <span>“Bayesian Spatial Modelling with <code>R</code>-<span>INLA</span>.”</span> <em>Journal of Statistical Software</em> 63 (19): 1–25. <a href="http://www.jstatsoft.org/v63/i19/">http://www.jstatsoft.org/v63/i19/</a>.
</div>
<div id="ref-lindgren2011explicit" class="csl-entry" role="listitem">
Lindgren, Finn, Håvard Rue, and Johan Lindström. 2011. <span>“An Explicit Link Between Gaussian Fields and Gaussian Markov Random Fields: The Stochastic Partial Differential Equation Approach.”</span> <em>Journal of the Royal Statistical Society, Series B</em> 73 (4): 423–98.
</div>
<div id="ref-mateu2013spatio" class="csl-entry" role="listitem">
Mateu, Jorge, and Werner G Müller. 2013. <em>Spatio-Temporal Design: Advances in Efficient Data Acquisition</em>. Chichester: John Wiley &amp; Sons.
</div>
<div id="ref-mcculloch2001generalized" class="csl-entry" role="listitem">
McCulloch, Charles E, and Shayle R Searle. 2001. <em>Generalized, Linear, and Mixed Models</em>. New York: John Wiley &amp; Sons.
</div>
<div id="ref-Montero2015spatial" class="csl-entry" role="listitem">
Montero, José-Marı́a, Gema Fernández-Avilés, and Jorge Mateu. 2015. <em>Spatial and Spatio-Temporal Geostatistical Modeling and Kriging</em>. Chichester: John Wiley &amp; Sons.
</div>
<div id="ref-patterson1971recovery" class="csl-entry" role="listitem">
Patterson, H Desmond, and Robin Thompson. 1971. <span>“Recovery of Inter-Block Information When Block Sizes Are Unequal.”</span> <em>Biometrika</em> 58 (3): 545–54.
</div>
<div id="ref-rasmussen2006gaussian" class="csl-entry" role="listitem">
Rasmussen, Carl Edward, and Christopher K. I. Williams. 2006. <em>Gaussian Processes for Machine Learning</em>. Cambridge, MA: MIT Press.
</div>
<div id="ref-allard2017analyzing" class="csl-entry" role="listitem">
RESSTE Network et al. 2017. <span>“Analyzing Spatio-Temporal Data with r: Everything You Always Wanted to Know – but Were Afraid to Ask.”</span> <em>Journal de La Société Française de Statistique</em> 158: 124–58.
</div>
<div id="ref-rue2009approximate" class="csl-entry" role="listitem">
Rue, Håvard, Sara Martino, and Nicolas Chopin. 2009. <span>“Approximate Bayesian Inference for Latent Gaussian Models by Using Integrated Nested Laplace Approximations.”</span> <em>Journal of the Royal Statistical Society, Series B</em> 71 (2): 319–92.
</div>
<div id="ref-schabenberger2005statistical" class="csl-entry" role="listitem">
Schabenberger, Oliver, and Carol A Gotway. 2005. <em>Statistical Methods for Spatial Data Analysis</em>. Boca Raton, FL: Chapman &amp; Hall/CRC.
</div>
<div id="ref-shaddick2015spatio" class="csl-entry" role="listitem">
Shaddick, Gavin, and James V Zidek. 2015. <em>Spatio-Temporal Methods in Environmental Epidemiology</em>. Boca Raton, FL: Chapman &amp; Hall/CRC.
</div>
<div id="ref-sherman2011spatial" class="csl-entry" role="listitem">
Sherman, Michael. 2011. <em>Spatial Statistics and Spatio-Temporal Data: Covariance Functions and Directional Properties</em>. Chichester: John Wiley &amp; Sons.
</div>
<div id="ref-simpson2017penalising" class="csl-entry" role="listitem">
Simpson, Daniel, Håvard Rue, Andrea Riebler, Thiago G Martins, and Sigrunn H Sørbye. 2017. <span>“Penalising Model Component Complexity: A Principled, Practical Approach to Constructing Priors.”</span> <em>Statistical Science</em> 32 (1): 1–28.
</div>
<div id="ref-verbeke2009linear" class="csl-entry" role="listitem">
Verbeke, Geert, and Geert Molenberghs. 2009. <em>Linear Mixed Models for Longitudinal Data</em>. New York: Springer.
</div>
<div id="ref-R_mgcv" class="csl-entry" role="listitem">
Wood, S. N. 2017. <em>Generalized Additive Models: An Introduction with r</em>. 2nd ed. Boca Raton, FL: Chapman &amp; Hall/CRC.
</div>
<div id="ref-wu2001comparison" class="csl-entry" role="listitem">
Wu, Chi-Tsung, Marcia L Gumpertz, and Dennis D Boos. 2001. <span>“Comparison of GEE, MINQUE, ML, and REML Estimating Equations for Normally Distributed Data.”</span> <em>American Statistician</em> 55 (2): 125–30.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Chapter3.html" class="pagination-link" aria-label="Spatio-Temporal Statistical Models">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Spatio-Temporal Statistical Models</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./Chapter5.html" class="pagination-link" aria-label="Dynamic Spatio-Temporal Models">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Dynamic Spatio-Temporal Models</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>